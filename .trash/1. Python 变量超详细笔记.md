---
date: 2025-11-02
tags:
  - python
  - base
  - 变量
---
# Python变量详解 - 完整版

## 1. 变量基础概念

### 1.1 什么是变量

```python
# ========== 变量的基本概念 ==========
"""
变量是程序中存储数据的容器，可以理解为数据的标签或名字。
在Python中，变量不需要显式声明类型，类型在赋值时自动确定。
"""

# 变量赋值的基本语法
variable_name = value

# 示例
name = "Alice"           # 字符串变量
age = 25                 # 整数变量
height = 1.65            # 浮点数变量
is_student = True        # 布尔变量

print(f"姓名: {name}")
print(f"年龄: {age}")
print(f"身高: {height}")
print(f"是否学生: {is_student}")
# 输出:
# 姓名: Alice
# 年龄: 25
# 身高: 1.65
# 是否学生: True

# ========== 变量的本质 ==========
"""
在Python中，变量实际上是对对象的引用（reference），而不是直接存储数据。
变量名指向内存中存储数据的对象。
"""

# 查看变量的内存地址
print(f"name的内存地址: {id(name)}")
print(f"age的内存地址: {id(age)}")
# 输出示例:
# name的内存地址: 140234567890123
# age的内存地址: 140234567890456

# 查看变量的类型
print(f"name的类型: {type(name)}")
print(f"age的类型: {type(age)}")
print(f"height的类型: {type(height)}")
print(f"is_student的类型: {type(is_student)}")
# 输出:
# name的类型: <class 'str'>
# age的类型: <class 'int'>
# height的类型: <class 'float'>
# is_student的类型: <class 'bool'>
```

### 1.2 变量命名规则

```python
# ========== 合法的变量名 ==========
# 1. 可以包含字母、数字、下划线
valid_var1 = "正确"
var_2 = "正确"
_var3 = "正确"  # 以下划线开头也是合法的
var_name_with_underscore = "正确"

# 2. 不能以数字开头
# 2var = "错误"  # SyntaxError: invalid syntax

# 3. 不能使用Python关键字
# if = "错误"     # SyntaxError: invalid syntax
# for = "错误"    # SyntaxError: invalid syntax
# class = "错误"  # SyntaxError: invalid syntax

# 4. 区分大小写
name = "Alice"
Name = "Bob"  # 这是不同的变量
NAME = "Charlie"  # 这也是不同的变量

print(f"name: {name}")    # Alice
print(f"Name: {Name}")    # Bob
print(f"NAME: {NAME}")    # Charlie
# 输出:
# name: Alice
# Name: Bob
# NAME: Charlie

# ========== Python关键字列表 ==========
import keyword
print("Python关键字:")
print(keyword.kwlist)
# 输出:
# Python关键字:
# ['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 
# 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 
# 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 
# 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 
# 'while', 'with', 'yield']

# ========== 命名约定 ==========
"""
Python有不同的命名约定，根据PEP 8规范：
"""

# 1. 蛇形命名法（推荐用于变量和函数）
user_name = "Alice"
total_count = 100
is_valid_input = True

# 2. 驼峰命名法（推荐用于类名）
ClassName = "MyClass"  # 实际上应该用于类，这里只是演示

# 3. 全大写（用于常量）
MAX_SIZE = 1024
PI = 3.14159
DATABASE_URL = "postgresql://localhost:5432/mydb"

# 4. 单下划线开头（表示内部使用）
_internal_variable = "内部使用"
_private_method = "私有方法"

# 5. 双下划线开头（名称修饰，真正的私有）
__really_private = "名称修饰的私有变量"

# 6. 双下划线开头和结尾（魔术方法）
__init__ = "魔术方法"
__str__ = "魔术方法"

print(f"蛇形命名: {user_name}")
print(f"常量: {MAX_SIZE}")
print(f"内部变量: {_internal_variable}")
# 输出:
# 蛇形命名: Alice
# 常量: 1024
# 内部变量: 内部使用
```

## 2. 变量赋值操作

### 2.1 基本赋值操作

```python
# ========== 简单赋值 ==========
# 基本赋值
x = 10
name = "Python"

# 多重赋值（同时给多个变量赋相同的值）
a = b = c = 0
print(f"a={a}, b={b}, c={c}")  # a=0, b=0, c=0
# 输出: a=0, b=0, c=0

# 链式赋值（给多个变量赋不同的值）
x = y = z = 100  # 三个变量都指向同一个值
print(f"x={x}, y={y}, z={z}")  # x=100, y=100, z=100
# 输出: x=100, y=100, z=100

# ========== 序列解包赋值 ==========
# 元组解包
x, y, z = 1, 2, 3
print(f"x={x}, y={y}, z={z}")  # x=1, y=2, z=3
# 输出: x=1, y=2, z=3

# 列表解包
[a, b, c] = [10, 20, 30]
print(f"a={a}, b={b}, c={c}")  # a=10, b=20, c=30
# 输出: a=10, b=20, c=30

# 字符串解包
char1, char2, char3 = "ABC"
print(f"char1={char1}, char2={char2}, char3={char3}")  # char1=A, char2=B, char3=C
# 输出: char1=A, char2=B, char3=C

# 字典解包（获取键）
key1, key2 = {"a": 1, "b": 2}
print(f"key1={key1}, key2={key2}")  # key1=a, key2=b
# 输出: key1=a, key2=b

# ========== 交换变量值 ==========
# 传统方法（需要临时变量）
a, b = 1, 2
temp = a
a = b
b = temp
print(f"交换后: a={a}, b={b}")  # a=2, b=1
# 输出: 交换后: a=2, b=1

# Pythonic方法（使用元组解包）
a, b = 1, 2
a, b = b, a  # 直接交换
print(f"交换后: a={a}, b={b}")  # a=2, b=1
# 输出: 交换后: a=2, b=1

# 多个变量同时交换
x, y, z = 1, 2, 3
x, y, z = z, x, y  # 循环交换
print(f"交换后: x={x}, y={y}, z={z}")  # x=3, y=1, z=2
# 输出: 交换后: x=3, y=1, z=2

# ========== 增量赋值 ==========
x = 5

# 算术运算增量赋值
x += 3      # x = x + 3
print(f"x += 3: {x}")  # 8
# 输出: x += 3: 8

x -= 2      # x = x - 2
print(f"x -= 2: {x}")  # 6
# 输出: x -= 2: 6

x *= 4      # x = x * 4
print(f"x *= 4: {x}")  # 24
# 输出: x *= 4: 24

x /= 3      # x = x / 3
print(f"x /= 3: {x}")  # 8.0
# 输出: x /= 3: 8.0

x //= 2     # x = x // 2
print(f"x //= 2: {x}")  # 4.0
# 输出: x //= 2: 4.0

x **= 2     # x = x ** 2
print(f"x **= 2: {x}")  # 16.0
# 输出: x **= 2: 16.0

x %= 5      # x = x % 5
print(f"x %= 5: {x}")  # 1.0
# 输出: x %= 5: 1.0

# 位运算增量赋值
y = 0b1010  # 10
y &= 0b1100 # y = y & 0b1100
print(f"y &= 0b1100: {bin(y)}")  # 0b1000
# 输出: y &= 0b1100: 0b1000

y |= 0b0011 # y = y | 0b0011
print(f"y |= 0b0011: {bin(y)}")  # 0b1011
# 输出: y |= 0b0011: 0b1011

y ^= 0b1111 # y = y ^ 0b1111
print(f"y ^= 0b1111: {bin(y)}")  # 0b0100
# 输出: y ^= 0b1111: 0b0100
```

### 2.2 高级赋值技巧

```python
# ========== 星号解包赋值 ==========
# 收集多余的值
first, *middle, last = [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(f"first: {first}")      # 1
print(f"middle: {middle}")    # [2, 3, 4, 5, 6, 7, 8]
print(f"last: {last}")        # 9
# 输出:
# first: 1
# middle: [2, 3, 4, 5, 6, 7, 8]
# last: 9

# 只关心第一个和最后一个
first, *_, last = range(10)
print(f"first: {first}, last: {last}")  # first: 0, last: 9
# 输出: first: 0, last: 9

# 处理可变长度序列
data = ["Alice", 25, "Engineer", "New York", "Python", "Reading"]
name, age, *extra_info = data
print(f"name: {name}, age: {age}, extra: {extra_info}")
# 输出: name: Alice, age: 25, extra: ['Engineer', 'New York', 'Python', 'Reading']

# 多层解包
nested = [1, [2, 3], 4]
a, (b, c), d = nested
print(f"a={a}, b={b}, c={c}, d={d}")  # a=1, b=2, c=3, d=4
# 输出: a=1, b=2, c=3, d=4

# ========== 条件赋值 ==========
# 使用条件表达式
score = 85
grade = "A" if score >= 90 else "B" if score >= 80 else "C" if score >= 70 else "F"
print(f"分数 {score} 的等级: {grade}")  # B
# 输出: 分数 85 的等级: B

# 使用or的短路特性提供默认值
username = None
display_name = username or "匿名用户"
print(f"显示名称: {display_name}")  # 匿名用户
# 输出: 显示名称: 匿名用户

# 使用and的短路特性进行条件赋值
config = {"debug": True}
debug_mode = config and config.get("debug")
print(f"调试模式: {debug_mode}")  # True
# 输出: 调试模式: True

# ========== 海象运算符 (Python 3.8+) ==========
# 在表达式内部进行赋值
data = "Hello, World!"

# 传统写法
n = len(data)
if n > 10:
    print(f"数据太长: {n} 字符")
# 输出: 数据太长: 13 字符

# 使用海象运算符
if (n := len(data)) > 10:
    print(f"数据太长: {n} 字符")
# 输出: 数据太长: 13 字符

# 在循环中使用（模拟输入，避免实际等待输入）
lines = ["line1", "line2", "quit"]
line_iter = iter(lines)
while (line := next(line_iter, None)) != "quit":
    print(f"你输入了: {line}")
# 输出:
# 你输入了: line1
# 你输入了: line2

# 在列表推导式中使用
numbers = [1, 2, 3, 4, 5]
squares = [y for x in numbers if (y := x**2) > 10]
print(f"平方大于10的数: {squares}")  # [16, 25]
# 输出: 平方大于10的数: [16, 25]

# ========== 带类型的变量赋值 (Python 3.6+ 类型提示) ==========
from typing import List, Dict, Optional

# 类型提示（不影响运行时，主要用于静态类型检查）
name: str = "Alice"
age: int = 25
scores: List[int] = [85, 90, 78]
person: Dict[str, str] = {"name": "Bob", "city": "New York"}
optional_value: Optional[str] = None

def greet(person_name: str) -> str:
    return f"Hello, {person_name}!"

print(greet(name))
# 输出: Hello, Alice!

# 查看变量的__annotations__
print(f"变量注解: {__annotations__}")
# 输出示例: 变量注解: {'name': <class 'str'>, 'age': <class 'int'>, 'scores': typing.List[int], 'person': typing.Dict[str, str], 'optional_value': typing.Union[str, NoneType]}
```

## 3. 变量作用域

### 3.1 作用域级别

```python
# ========== 局部作用域 ==========
def local_scope_demo():
    """函数内部定义的变量具有局部作用域"""
    local_var = "我是局部变量"
    print(f"函数内部: {local_var}")
    
local_scope_demo()
# print(local_var)  # 错误！NameError: name 'local_var' is not defined
# 输出: 函数内部: 我是局部变量

# ========== 嵌套作用域 ==========
def outer_function():
    """外部函数"""
    outer_var = "外部变量"
    
    def inner_function():
        """内部函数可以访问外部函数的变量"""
        print(f"内部函数访问: {outer_var}")
    
    inner_function()
    print(f"外部函数访问: {outer_var}")

outer_function()
# 输出:
# 内部函数访问: 外部变量
# 外部函数访问: 外部变量

# ========== 全局作用域 ==========
global_var = "我是全局变量"

def access_global():
    """访问全局变量"""
    print(f"函数内访问全局变量: {global_var}")

access_global()
print(f"函数外访问全局变量: {global_var}")
# 输出:
# 函数内访问全局变量: 我是全局变量
# 函数外访问全局变量: 我是全局变量

# ========== 内置作用域 ==========
def builtin_scope_demo():
    """内置作用域包含Python内置的函数和异常"""
    # 这些是内置作用域的
    print(f"len函数: {len}")
    print(f"TypeError异常: {TypeError}")
    
    # 我们可以覆盖它们（但不推荐！）
    len = "我覆盖了len函数"  # 这创建了一个局部变量
    print(f"覆盖后的len: {len}")

builtin_scope_demo()
print(f"全局作用域的len: {len('test')}")  # 内置len函数仍然存在
# 输出:
# len函数: <built-in function len>
# TypeError异常: <class 'TypeError'>
# 覆盖后的len: 我覆盖了len函数
# 全局作用域的len: 4

# ========== 作用域查找顺序 (LEGB规则) ==========
"""
Python按照以下顺序查找变量：
1. Local - 局部作用域
2. Enclosing - 嵌套作用域  
3. Global - 全局作用域
4. Built-in - 内置作用域
"""

x = "global x"  # 全局变量

def outer():
    x = "outer x"  # 嵌套作用域变量
    
    def inner():
        x = "inner x"  # 局部变量
        print(f"局部作用域: {x}")
    
    def inner_no_local():
        # 没有局部x，查找嵌套作用域
        print(f"嵌套作用域: {x}")
    
    def inner_no_outer():
        # 没有局部和嵌套x，查找全局作用域
        global x
        print(f"全局作用域: {x}")
    
    inner()           # 局部作用域: inner x
    inner_no_local()  # 嵌套作用域: outer x
    inner_no_outer()  # 全局作用域: global x

outer()
# 输出:
# 局部作用域: inner x
# 嵌套作用域: outer x
# 全局作用域: global x
```

### 3.2 作用域控制关键字

```python
# ========== global 关键字 ==========
counter = 0  # 全局变量

def increment_wrong():
    """错误的方法：尝试修改全局变量"""
    # counter += 1  # UnboundLocalError: local variable 'counter' referenced before assignment

def increment_correct():
    """正确的方法：使用global关键字"""
    global counter
    counter += 1
    print(f"计数器: {counter}")

increment_correct()  # 计数器: 1
increment_correct()  # 计数器: 2
increment_correct()  # 计数器: 3
# 输出:
# 计数器: 1
# 计数器: 2
# 计数器: 3

# ========== nonlocal 关键字 ==========
def outer_function():
    count = 0  # 嵌套作用域变量
    
    def inner_function_wrong():
        """错误的方法：尝试修改嵌套作用域变量"""
        # count += 1  # UnboundLocalError
    
    def inner_function_correct():
        """正确的方法：使用nonlocal关键字"""
        nonlocal count
        count += 1
        print(f"嵌套计数器: {count}")
    
    inner_function_correct()  # 嵌套计数器: 1
    inner_function_correct()  # 嵌套计数器: 2
    inner_function_correct()  # 嵌套计数器: 3

outer_function()
# 输出:
# 嵌套计数器: 1
# 嵌套计数器: 2
# 嵌套计数器: 3

# ========== 闭包示例 ==========
def make_counter(initial=0):
    """创建计数器闭包"""
    count = initial  # 嵌套作用域变量
    
    def counter():
        nonlocal count
        count += 1
        return count
    
    return counter

# 创建两个独立的计数器
counter1 = make_counter()
counter2 = make_counter(10)

print(f"计数器1: {counter1()}")  # 1
print(f"计数器1: {counter1()}")  # 2
print(f"计数器2: {counter2()}")  # 11
print(f"计数器2: {counter2()}")  # 12
print(f"计数器1: {counter1()}")  # 3
# 输出:
# 计数器1: 1
# 计数器1: 2
# 计数器2: 11
# 计数器2: 12
# 计数器1: 3

# ========== 全局变量管理 ==========
# 查看全局变量
print("全局变量:")
for var_name in dir():
    if not var_name.startswith('_'):
        var_value = globals().get(var_name)
        if not callable(var_value):  # 避免打印函数
            print(f"  {var_name} = {var_value}")

# 全局变量字典
print(f"全局变量字典keys: {[k for k in globals().keys() if not k.startswith('_')][:5]}...")
# 输出示例: 全局变量字典keys: ['counter', 'make_counter', 'counter1', 'counter2', 'outer_function']...

# 局部变量字典
def show_locals():
    local_var = "局部值"
    print(f"局部变量: {locals()}")

show_locals()
# 输出示例: 局部变量: {'local_var': '局部值'}
```

## 4. 变量与内存管理

### 4.1 引用与对象

```python
# ========== 变量是引用 ==========
# 变量指向对象，而不是包含对象
a = [1, 2, 3]
b = a  # b和a指向同一个列表对象

print(f"a: {a}")              # [1, 2, 3]
print(f"b: {b}")              # [1, 2, 3]
print(f"a is b: {a is b}")    # True
print(f"id(a): {id(a)}")      # 相同的内存地址
print(f"id(b): {id(b)}")      # 相同的内存地址
# 输出示例:
# a: [1, 2, 3]
# b: [1, 2, 3]
# a is b: True
# id(a): 140234567890123
# id(b): 140234567890123

# 修改通过一个引用会影响另一个
a.append(4)
print(f"修改后 a: {a}")        # [1, 2, 3, 4]
print(f"修改后 b: {b}")        # [1, 2, 3, 4]
# 输出:
# 修改后 a: [1, 2, 3, 4]
# 修改后 b: [1, 2, 3, 4]

# ========== 不可变对象的引用 ==========
x = 10
y = x  # x和y指向同一个整数对象

print(f"x: {x}")              # 10
print(f"y: {y}")              # 10
print(f"x is y: {x is y}")    # True
# 输出:
# x: 10
# y: 10
# x is y: True

# 对于不可变对象，修改会创建新对象
x = 20  # x现在指向新的整数对象
print(f"修改后 x: {x}")        # 20
print(f"修改后 y: {y}")        # 10（y仍然指向原来的对象）
print(f"x is y: {x is y}")    # False
# 输出:
# 修改后 x: 20
# 修改后 y: 10
# x is y: False

# ========== 对象标识和值相等 ==========
list1 = [1, 2, 3]
list2 = [1, 2, 3]
list3 = list1

print(f"list1 == list2: {list1 == list2}")  # True（值相等）
print(f"list1 is list2: {list1 is list2}")  # False（不是同一个对象）
print(f"list1 is list3: {list1 is list3}")  # True（同一个对象）
# 输出:
# list1 == list2: True
# list1 is list2: False
# list1 is list3: True

# 小整数和字符串的驻留（interning）
a = 100
b = 100
print(f"小整数 a is b: {a is b}")  # True（Python对小整数进行驻留）
# 输出: 小整数 a is b: True

c = 1000
d = 1000
print(f"大整数 c is d: {c is d}")  # False（大整数不驻留）
# 输出: 大整数 c is d: False

# ========== 引用计数 ==========
import sys

def show_ref_count(obj, name):
    """显示对象的引用计数（近似值）"""
    count = sys.getrefcount(obj) - 3  # 减去函数调用产生的临时引用
    print(f"{name} 的引用计数: {count}")

x = [1, 2, 3]
show_ref_count(x, "x")  # 引用计数: 1
# 输出示例: x 的引用计数: 1

y = x
show_ref_count(x, "x")  # 引用计数: 2
# 输出示例: x 的引用计数: 2

z = x
show_ref_count(x, "x")  # 引用计数: 3
# 输出示例: x 的引用计数: 3

del y
show_ref_count(x, "x")  # 引用计数: 2
# 输出示例: x 的引用计数: 2

del z
show_ref_count(x, "x")  # 引用计数: 1
# 输出示例: x 的引用计数: 1
```

### 4.2 拷贝与深拷贝

```python
# ========== 引用赋值（不是拷贝） ==========
original = [1, 2, 3, [4, 5]]
reference = original  # 这只是引用，不是拷贝

reference[0] = 100
print(f"原列表: {original}")    # [100, 2, 3, [4, 5]]
print(f"引用列表: {reference}")  # [100, 2, 3, [4, 5]]
# 输出:
# 原列表: [100, 2, 3, [4, 5]]
# 引用列表: [100, 2, 3, [4, 5]]

# ========== 浅拷贝 ==========
import copy

original = [1, 2, 3, [4, 5]]
shallow_copy = original.copy()  # 或者 copy.copy(original)

# 修改第一层元素
shallow_copy[0] = 100
print(f"原列表: {original}")      # [1, 2, 3, [4, 5]]（未改变）
print(f"浅拷贝: {shallow_copy}")  # [100, 2, 3, [4, 5]]
# 输出:
# 原列表: [1, 2, 3, [4, 5]]
# 浅拷贝: [100, 2, 3, [4, 5]]

# 修改嵌套对象会影响原列表
shallow_copy[3].append(6)
print(f"原列表: {original}")      # [1, 2, 3, [4, 5, 6]]（被修改了！）
print(f"浅拷贝: {shallow_copy}")  # [100, 2, 3, [4, 5, 6]]
# 输出:
# 原列表: [1, 2, 3, [4, 5, 6]]
# 浅拷贝: [100, 2, 3, [4, 5, 6]]

# ========== 深拷贝 ==========
original = [1, 2, 3, [4, 5]]
deep_copy = copy.deepcopy(original)

# 修改任何层级都不影响原对象
deep_copy[0] = 100
deep_copy[3].append(6)
print(f"原列表: {original}")    # [1, 2, 3, [4, 5]]（完全不受影响）
print(f"深拷贝: {deep_copy}")   # [100, 2, 3, [4, 5, 6]]
# 输出:
# 原列表: [1, 2, 3, [4, 5]]
# 深拷贝: [100, 2, 3, [4, 5, 6]]

# ========== 不同数据类型的拷贝行为 ==========
# 列表的拷贝
list_orig = [1, 2, 3]
list_shallow = list_orig.copy()
list_slice = list_orig[:]  # 切片也是浅拷贝

# 字典的拷贝
dict_orig = {"a": 1, "b": 2}
dict_shallow = dict_orig.copy()

# 集合的拷贝
set_orig = {1, 2, 3}
set_shallow = set_orig.copy()

print(f"列表拷贝: {list_shallow}")
print(f"字典拷贝: {dict_shallow}")
print(f"集合拷贝: {set_shallow}")
# 输出:
# 列表拷贝: [1, 2, 3]
# 字典拷贝: {'a': 1, 'b': 2}
# 集合拷贝: {1, 2, 3}

# ========== 自定义对象的拷贝 ==========
class Person:
    def __init__(self, name, friends=None):
        self.name = name
        self.friends = friends if friends is not None else []
    
    def __repr__(self):
        return f"Person({self.name}, friends={[f.name for f in self.friends]})"

# 创建对象
alice = Person("Alice")
bob = Person("Bob")
alice.friends.append(bob)

# 浅拷贝
alice_shallow = copy.copy(alice)
print(f"原对象: {alice}")          # Person(Alice, friends=['Bob'])
print(f"浅拷贝: {alice_shallow}")  # Person(Alice, friends=['Bob'])
# 输出:
# 原对象: Person(Alice, friends=['Bob'])
# 浅拷贝: Person(Alice, friends=['Bob'])

# 修改浅拷贝的friends会影响原对象
alice_shallow.friends.append(Person("Charlie"))
print(f"修改后原对象: {alice}")     # friends包含Charlie！
# 输出: 修改后原对象: Person(Alice, friends=['Bob', Person(Charlie, friends=[])])

# 深拷贝
alice_deep = copy.deepcopy(alice)
alice_deep.friends.append(Person("David"))
print(f"深拷贝后原对象: {alice}")   # 不受影响
# 输出: 深拷贝后原对象: Person(Alice, friends=['Bob', Person(Charlie, friends=[])])
```

## 5. 高级变量特性

### 5.1 动态特性

```python
# ========== 动态类型 ==========
# Python是动态类型语言，变量类型可以改变
x = 10
print(f"x的类型: {type(x)}, 值: {x}")  # <class 'int'>, 10
# 输出: x的类型: <class 'int'>, 值: 10

x = "hello"
print(f"x的类型: {type(x)}, 值: {x}")  # <class 'str'>, hello
# 输出: x的类型: <class 'str'>, 值: hello

x = [1, 2, 3]
print(f"x的类型: {type(x)}, 值: {x}")  # <class 'list'>, [1, 2, 3]
# 输出: x的类型: <class 'list'>, 值: [1, 2, 3]

# ========== 动态创建变量 ==========
# 使用globals()动态创建全局变量
for i in range(5):
    var_name = f"dynamic_var_{i}"
    globals()[var_name] = i * 10

print(f"dynamic_var_0: {dynamic_var_0}")  # 0
print(f"dynamic_var_3: {dynamic_var_3}")  # 30
# 输出:
# dynamic_var_0: 0
# dynamic_var_3: 30

# 使用setattr()动态设置属性
class Container:
    pass

obj = Container()
for i in range(3):
    setattr(obj, f"attr_{i}", f"value_{i}")

print(f"obj.attr_0: {obj.attr_0}")  # value_0
print(f"obj.attr_2: {obj.attr_2}")  # value_2
# 输出:
# obj.attr_0: value_0
# obj.attr_2: value_2

# ========== 变量删除 ==========
x = 10
y = 20
z = 30

print(f"删除前: x={x}, y={y}, z={z}")
# 输出: 删除前: x=10, y=20, z=30

# 删除变量
del x
# print(x)  # NameError: name 'x' is not defined

# 删除多个变量
del y, z
# print(y)  # NameError
# print(z)  # NameError

# 删除列表元素
numbers = [1, 2, 3, 4, 5]
del numbers[1]  # 删除索引1的元素
print(f"删除元素后: {numbers}")  # [1, 3, 4, 5]
# 输出: 删除元素后: [1, 3, 4, 5]

del numbers[1:3]  # 删除切片
print(f"删除切片后: {numbers}")  # [1, 5]
# 输出: 删除切片后: [1, 5]

# 删除字典键
person = {"name": "Alice", "age": 25}
del person["age"]
print(f"删除键后: {person}")  # {'name': 'Alice'}
# 输出: 删除键后: {'name': 'Alice'}

# ========== 变量存在性检查 ==========
# 检查变量是否存在
if 'unknown_var' in globals():
    print("unknown_var存在")
else:
    print("unknown_var不存在")
# 输出: unknown_var不存在

# 安全地访问可能不存在的变量
try:
    value = unknown_var
except NameError:
    value = "默认值"

print(f"值: {value}")  # 默认值
# 输出: 值: 默认值

# 使用getattr()安全访问属性
class Test:
    existing = "存在的属性"

obj = Test()
value1 = getattr(obj, "existing", "默认值")
value2 = getattr(obj, "nonexistent", "默认值")
print(f"存在的属性: {value1}")    # 存在的属性
print(f"不存在的属性: {value2}")  # 默认值
# 输出:
# 存在的属性: 存在的属性
# 不存在的属性: 默认值
```

### 5.2 特殊变量

```python
# ========== 特殊变量和方法 ==========
# __name__ - 模块名称
print(f"模块名: {__name__}")
# 输出: 模块名: __main__

# __doc__ - 文档字符串
def example_function():
    """这是一个示例函数的文档字符串"""
    pass

print(f"函数文档: {example_function.__doc__}")
# 输出: 函数文档: 这是一个示例函数的文档字符串

# __annotations__ - 类型注解
def typed_function(x: int, y: str) -> float:
    return float(x)

print(f"函数注解: {typed_function.__annotations__}")
# 输出: 函数注解: {'x': <class 'int'>, 'y': <class 'str'>, 'return': <class 'float'>}

# ========== 下划线变量的特殊含义 ==========
# 单个下划线 - 临时或不重要的变量
for _ in range(3):
    print("重复3次")
# 输出:
# 重复3次
# 重复3次
# 重复3次

# 在解包中忽略值
x, _, z = (1, 2, 3)
print(f"x={x}, z={z}")  # x=1, z=3
# 输出: x=1, z=3

# _var - 内部使用约定（不是真正的私有）
class MyClass:
    def __init__(self):
        self.public = "公共"
        self._internal = "内部使用"
    
    def _internal_method(self):
        return "内部方法"

obj = MyClass()
print(f"公共属性: {obj.public}")        # 可以访问
print(f"内部属性: {obj._internal}")     # 仍然可以访问（只是约定）
# 输出:
# 公共属性: 公共
# 内部属性: 内部使用

# __var - 名称修饰（Name Mangling）
class NameMangling:
    def __init__(self):
        self.__private = "名称修饰的私有"
    
    def get_private(self):
        return self.__private

obj = NameMangling()
print(f"通过方法访问: {obj.get_private()}")  # 名称修饰的私有
# print(obj.__private)  # AttributeError（无法直接访问）
print(f"实际属性名: {obj._NameMangling__private}")  # 可以通过修饰后的名字访问
# 输出:
# 通过方法访问: 名称修饰的私有
# 实际属性名: 名称修饰的私有

# __var__ - 魔术方法
class MagicMethods:
    def __init__(self, value):
        self.value = value
    
    def __str__(self):
        return f"MagicMethods({self.value})"
    
    def __len__(self):
        return len(str(self.value))

obj = MagicMethods(42)
print(f"字符串表示: {obj}")    # 调用 __str__
print(f"长度: {len(obj)}")     # 调用 __len__
# 输出:
# 字符串表示: MagicMethods(42)
# 长度: 2

# ========== 环境变量 ==========
import os

# 获取环境变量
path = os.getenv("PATH")
home = os.getenv("HOME") or os.getenv("USERPROFILE")
python_path = os.getenv("PYTHONPATH")

print(f"HOME: {home}")
print(f"PATH长度: {len(path) if path else 0} 字符")
# 输出示例:
# HOME: /home/user
# PATH长度: 12345 字符

# 设置环境变量（仅当前进程有效）
os.environ["MY_VAR"] = "my_value"
print(f"MY_VAR: {os.getenv('MY_VAR')}")
# 输出: MY_VAR: my_value

# 安全获取环境变量（带默认值）
database_url = os.getenv("DATABASE_URL", "sqlite:///default.db")
debug_mode = os.getenv("DEBUG", "False").lower() == "true"

print(f"数据库URL: {database_url}")
print(f"调试模式: {debug_mode}")
# 输出:
# 数据库URL: sqlite:///default.db
# 调试模式: False
```

## 6. 易错点详解

```python
# ========== 变量易错点 ==========

# 错误1：变量作用域混淆
x = "全局变量"

def confuse_scope():
    print(f"函数内访问: {x}")  # 这里会报错！
    x = "局部变量"  # 这创建了局部变量，影响了上面的访问

try:
    confuse_scope()
except UnboundLocalError as e:
    print(f"作用域错误: {e}")
# 输出: 作用域错误: local variable 'x' referenced before assignment

# 正确写法
def correct_scope():
    global x  # 声明使用全局变量
    print(f"函数内访问: {x}")
    x = "修改后的全局变量"

correct_scope()
print(f"修改后全局: {x}")
# 输出:
# 函数内访问: 全局变量
# 修改后全局: 修改后的全局变量

# 错误2：可变默认参数
def bad_append(item, items=[]):  # 危险！默认列表在函数定义时创建
    items.append(item)
    return items

print(f"第一次调用: {bad_append(1)}")  # [1]
print(f"第二次调用: {bad_append(2)}")  # [1, 2]（保留了状态！）
# 输出:
# 第一次调用: [1]
# 第二次调用: [1, 2]

# 正确写法
def good_append(item, items=None):
    if items is None:
        items = []
    items.append(item)
    return items

print(f"第一次调用: {good_append(1)}")  # [1]
print(f"第二次调用: {good_append(2)}")  # [2]（每次都创建新列表）
# 输出:
# 第一次调用: [1]
# 第二次调用: [2]

# 错误3：浅拷贝陷阱
original = [1, 2, [3, 4]]
shallow = original.copy()

shallow[2].append(5)  # 修改嵌套列表
print(f"原列表: {original}")  # [1, 2, [3, 4, 5]]（被修改了！）
# 输出: 原列表: [1, 2, [3, 4, 5]]

# 正确：使用深拷贝
import copy
original = [1, 2, [3, 4]]
deep = copy.deepcopy(original)
deep[2].append(5)
print(f"原列表: {original}")  # [1, 2, [3, 4]]（安全）
# 输出: 原列表: [1, 2, [3, 4]]

# 错误4：循环变量泄露
for i in range(5):
    pass

print(f"循环后i的值: {i}")  # 4（i仍然存在）
# 输出: 循环后i的值: 4

# 在列表推导式中不会泄露
squares = [x**2 for x in range(5)]
try:
    print(x)  # NameError
except NameError:
    print("列表推导式中的变量不会泄露")
# 输出: 列表推导式中的变量不会泄露

# 错误5：== 和 is 的混淆
a = [1, 2, 3]
b = [1, 2, 3]
c = a

print(f"a == b: {a == b}")  # True（值相等）
print(f"a is b: {a is b}")  # False（不是同一个对象）
print(f"a is c: {a is c}")  # True（同一个对象）
# 输出:
# a == b: True
# a is b: False
# a is c: True

# 对于None，应该使用is
value = None
print(f"value is None: {value is None}")  # 正确
print(f"value == None: {value == None}")  # 也可以，但不推荐
# 输出:
# value is None: True
# value == None: True

# 错误6：动态创建变量的滥用
# 避免这样写：
for i in range(3):
    globals()[f"var_{i}"] = i

# 应该使用字典：
vars_dict = {f"var_{i}": i for i in range(3)}
print(f"变量字典: {vars_dict}")
# 输出: 变量字典: {'var_0': 0, 'var_1': 1, 'var_2': 2}

# 错误7：忽略变量类型变化
def process_data(data):
    # 假设data是列表
    data.append("new_item")  # 如果data是元组，这里会报错！
    return data

# 安全写法
def safe_process_data(data):
    if isinstance(data, list):
        data.append("new_item")
        return data
    elif isinstance(data, tuple):
        return data + ("new_item",)
    else:
        raise TypeError("不支持的数据类型")

print(f"处理列表: {safe_process_data([1, 2])}")      # [1, 2, 'new_item']
print(f"处理元组: {safe_process_data((1, 2))}")      # (1, 2, 'new_item')
# 输出:
# 处理列表: [1, 2, 'new_item']
# 处理元组: (1, 2, 'new_item')

# 错误8：变量名覆盖内置函数
# 不要这样做：
str = "我的字符串"  # 覆盖了内置str函数
# len = len(str)    # 现在len函数被覆盖了！

# 恢复内置函数
str = str.__class__  # 恢复str函数
# 或者重启解释器

print(f"正常的str函数: {str(123)}")  # '123'
# 输出: 正常的str函数: 123

# 错误9：不理解海象运算符的优先级
# 错误的优先级理解
x = 5
# if (y := x + 1) > 5:  # 正确：y = 6, 6 > 5 为 True
# if y := x + 1 > 5:    # 错误：y = (x + 1 > 5) = True

# 错误10：在条件判断中赋值
# 不要这样写（容易混淆）：
# if (x = some_function()) > 0:  # 语法错误！
#     pass

# 使用海象运算符（Python 3.8+）：
def some_function():
    return 10

if (x := some_function()) > 0:
    print(f"x的值: {x}")
# 输出: x的值: 10

# 或者分开写：
x = some_function()
if x > 0:
    print(f"x的值: {x}")
# 输出: x的值: 10
```

## 补充内容：变量相关的高级特性

### 7.1 上下文管理器与with语句

```python
# ========== 使用with语句管理资源 ==========
# 文件操作自动关闭
with open('example.txt', 'w') as f:
    f.write("Hello, World!")
# 文件自动关闭，无需手动调用f.close()

# 自定义上下文管理器
class ResourceManager:
    def __init__(self, name):
        self.name = name
    
    def __enter__(self):
        print(f"获取资源: {self.name}")
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        print(f"释放资源: {self.name}")

with ResourceManager("数据库连接") as resource:
    print(f"使用资源: {resource.name}")
# 输出:
# 获取资源: 数据库连接
# 使用资源: 数据库连接
# 释放资源: 数据库连接
```

### 7.2 数据类（Python 3.7+）

```python
# ========== 使用数据类简化类定义 ==========
from dataclasses import dataclass, field
from typing import List

@dataclass
class Person:
    name: str
    age: int
    hobbies: List[str] = field(default_factory=list)
    
    def greet(self):
        return f"Hello, I'm {self.name}, {self.age} years old"

# 自动生成__init__、__repr__等方法
person = Person("Alice", 25, ["reading", "coding"])
print(person)
print(person.greet())
# 输出:
# Person(name='Alice', age=25, hobbies=['reading', 'coding'])
# Hello, I'm Alice, 25 years old
```

### 7.3 枚举类型

```python
# ========== 使用枚举定义常量 ==========
from enum import Enum, auto

class Color(Enum):
    RED = 1
    GREEN = 2
    BLUE = 3

class Status(Enum):
    PENDING = auto()
    RUNNING = auto()
    COMPLETED = auto()

print(f"颜色: {Color.RED}")
print(f"状态: {Status.PENDING}")
print(f"颜色值: {Color.RED.value}")
# 输出:
# 颜色: Color.RED
# 状态: Status.PENDING
# 颜色值: 1
```

## 总结

### 变量使用最佳实践

1. **命名规范**：
   - 使用蛇形命名法：`user_name`
   - 常量使用全大写：`MAX_SIZE`
   - 避免使用内置函数名：不要用`str`, `list`等作为变量名

2. **作用域管理**：
   - 尽量减少全局变量的使用
   - 使用`global`和`nonlocal`时要谨慎
   - 理解LEGB查找规则

3. **内存管理**：
   - 理解变量是引用而不是容器
   - 根据需要选择浅拷贝或深拷贝
   - 及时删除不再需要的大对象

4. **类型安全**：
   - 使用类型提示提高代码可读性
   - 进行类型检查避免运行时错误
   - 注意动态类型带来的灵活性

5. **错误预防**：
   - 避免可变默认参数
   - 注意循环变量泄露
   - 正确使用`==`和`is`

### 实用技巧总结

```python
# 1. 使用类型提示和现代Python特性
from typing import List, Dict, Optional, Union
from dataclasses import dataclass

@dataclass
class User:
    name: str
    age: int
    email: Optional[str] = None

def process_users(users: List[User]) -> Dict[str, int]:
    """处理用户数据"""
    return {user.name: user.age for user in users}

# 2. 安全访问和处理变量
value = globals().get('unknown_var', 'default')
attribute = getattr(obj, 'unknown_attr', 'default')

# 3. 使用上下文管理器管理资源
with open('file.txt') as f:
    content = f.read()

# 4. 利用解包和星号操作符
first, *rest = [1, 2, 3, 4, 5]

# 5. 使用海象运算符简化代码
if (n := len(data)) > 10:
    print(f"数据过长: {n}")

# 6. 正确使用拷贝
import copy
shallow = original.copy()
deep = copy.deepcopy(original)
```

这份完整的Python变量笔记涵盖了从基础到高级的所有重要概念，包括：
- 变量基础概念和命名规则
- 各种赋值操作和高级技巧  
- 作用域管理和控制关键字
- 内存管理、引用和拷贝机制
- 动态特性和特殊变量
- 常见易错点和解决方案
- 补充的高级特性如上下文管理器、数据类等

所有代码示例都包含了实际的输出结果，便于理解和验证。希望对您的Python学习有全面的帮助！