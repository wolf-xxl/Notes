# 第四章：JavaScript 的调用方式

## 学习目标
- 掌握 Python 调用 JavaScript 代码
- 熟悉 JavaScript 开放接口
- 了解补环境的基本概念
- 掌握 JavaScript 调试技巧

## 1. PyExecJS 的使用方式

### 1.1 PyExecJS 简介
`PyExecJS` 是一个 Python 库，用于在 Python 环境中执行 JavaScript 代码。它是对 ExecJS 库的 Python 封装，ExecJS 本身是一个通用的 JavaScript 运行环境的抽象层。

**主要特点**：
- 在 Python 中执行 JavaScript 代码，无需启动完整的 JavaScript 解释器
- 提供一种简便的方式在 Python 中嵌入 JavaScript 代码
- 特别适用于需要与 JavaScript 交互的项目

### 1.2 基本使用方式

#### 1.2.1 将 JS 代码作为字符串传递并执行

**Python 代码示例**：
```python
import execjs

# 定义 JavaScript 代码字符串
js_code = """
function add_number(num_1, num_2) {
    return num_1 + num_2;
}
"""

# 检查当前 JavaScript 运行环境
print(execjs.get())

# 编译 JavaScript 代码
run_js = execjs.compile(js_code)

# 方式1：使用 call 方法调用函数
result = run_js.call("add_number", 1, 2)
print(result)

# 方式2：使用 eval 方法调用函数
result = run_js.eval("add_number(3, 4)")
print(result)
```

**输出信息**：
```
ExternalRuntime(Node.js (V8))
3
7
```

**注意**：如果在 PyCharm 中返回的 JS 执行环境是 `JavaScript` 而不是 `Node.js (V8)`，可能需要重新安装 PyCharm 编辑器或配置 Node.js 环境。

#### 1.2.2 读取 JS 文件并执行

**Python 代码**：
```python
import execjs

# 获取 Node.js 运行环境
node = execjs.get()

# 读取 JavaScript 文件
with open('run_js_test.js', encoding='utf-8') as f:
    js_code = f.read()

# 编译 JavaScript 代码
run_js = node.compile(js_code)

# 使用 eval 方法执行（函数调用包含在字符串内）
result = run_js.eval('run_add_func(1, 2)')
print(result)

# 使用 call 方法执行（第一个参数是函数名，后面是参数）
result = run_js.call('run_add_func', 3, 4)
print(result)
```

**JavaScript 文件内容**（run_js_test.js）：
```javascript
function run_add_func(num_1, num_2) {
    return num_1 + num_2;
}
```

## 2. Express 开放接口

### 2.1 Express 简介
- **官方概念**：Express 是基于 Node.js 平台，快速、开放、极简的 Web 开发框架
- **通俗理解**：Express 的作用和 Node.js 内置的 http 模块类似，专门用来创建 Web 服务器
- **本质**：是一个 npm 上的第三方包，提供了快速创建 Web 服务器的便捷方法
- **中文官网**：http://www.expressjs.com.cn/

**类比关系**：
- `http内置模块` 与 `Express` 的关系类似于
- `浏览器Web API` 与 `jQuery` 的关系
后者是基于前者进一步封装出来的。

### 2.2 使用方式

#### 2.2.1 安装与创建 Web 服务器

**安装指令**：
```bash
npm install express -S
```

**创建 Web 服务器**：
```javascript
// 1. 导入 express
const express = require('express');

// 2. 创建 Web 服务器
const app = express();

// 3. 定义 GET 请求接口
// req 是请求对象，res 是响应对象
app.get('/user', function (req, res) {
    // 调用 express 提供的 res.send() 方法，向客户端响应一个 JSON 对象
    res.send('hello world');
});

// 4. 启动 Web 服务器
app.listen(8080, function () {
    console.log('express server running at http://127.0.0.1:8080');
});
```

#### 2.2.2 获取请求参数

```javascript
const express = require('express');
const app = express();

app.listen(8080, function () {
    console.log('express server running at http://127.0.0.1:8080');
});

// 获取请求参数
// 请求地址示例：http://127.0.0.1:8080/?user=admin
app.get('/', function (req, res) {
    // 通过 req.query 可以获取到客户端发送过来的查询参数
    // 注意：默认情况下，req.query 是一个空对象
    console.log(req.query);
    res.send(req.query);
});
```

#### 2.2.3 POST 请求接口

**JavaScript 代码**：
```javascript
const express = require('express');
const app = express();

// 解析 JSON 格式的请求体
app.use(express.json())

// 定义 POST 请求接口
app.post('/api', function (req, res) {
    // 获取传递过来的请求体
    console.log(req.body);
    res.send('Got a post request...')
});

app.listen(8080, function () {
    console.log('express server running at http://127.0.0.1:8080');
});
```

**Python 测试代码**：
```python
import requests

send_data = {'user': 'admin'}
response = requests.post('http://127.0.0.1:8080/api', json=send_data)
print(response.text)
```

## 3. 异步调试方法

### 3.1 问题描述
在 Python 中无法直接获取 JavaScript 中的异步函数返回值，需要使用 `subprocess` 模块来完成异步函数的返回值获取。

### 3.2 使用 subprocess 执行 JavaScript 异步函数

**JavaScript 代码**（run_async_func.js）：
```javascript
function getAsyncData() {
    return new Promise(function (resolve, reject) {
        resolve('异步数据测试...');
    });
}

// 调用异步函数
getAsyncData().then(res => console.log(res));
```

**Python 代码**：
```python
import subprocess

"""
参数说明：
- capture_output: 通过 capture_output 为 True 来捕获控制台输出内容，默认为 False
- text: 指定是否将输出结果以文本形式返回
- encoding: 指定编码格式
"""
result = subprocess.run(['node', 'run_async_func.js'], 
                       capture_output=True, 
                       text=True, 
                       encoding='utf-8')

print(result)  # 返回完整的 subprocess.CompletedProcess 对象
print(result.stdout.strip())  # 返回执行结果
```

**注意**：必须在 JavaScript 代码中调用了异步任务，才能从 subprocess 获取执行结果。

### 3.3 自定义 API 接口

**JavaScript 代码**：
```javascript
var express = require('express');
var app = express();

function getAsyncData() {
    return new Promise(function (resolve, reject) {
        resolve('异步数据测试...');
    });
}

app.get('/get_data', function (req, res) {
    getAsyncData().then(function (result) {
        res.send(result);
    });
});

app.listen(8080, function () {
    console.log('express server running at http://127.0.0.1:8080');
});
```

## 4. JavaScript 调试技巧

### 4.1 常见的定位方法

1. **DOM 和 XHR 断点定位**
   - DOM 断点：监控 DOM 元素的变化
   - XHR 断点：监控特定的网络请求

2. **关键字搜索**
   - 尽量使用可能在 JavaScript 中出现的结构：`sign =`、`"sign"`、`sign: "sign"` 等
   - 当关键字特征不明显时，缩小搜索范围，查找其他相关变量

3. **使用 HOOK 技术进行拦截**
   - 拦截特定的函数或属性操作

4. **根据启动器去找调用关系**
   - 分析启动器调用栈
   - 这种方式运气成分较多，但有时很有效

### 4.2 案例演示

#### 4.2.1 关键字定位

**站点地址**：https://www.91118.com/Passport/Account/Login
**接口地址**：https://www.91118.com/passport/Account/LoginPost

**步骤**：
1. 使用关键字搜索的方式完成定位
2. 如果关键字特征不明显，需要缩小搜索范围，查询其他的赋值变量
3. 结果校验（注意观察断点位置中的函数参数）

#### 4.2.2 启动器定位

**步骤**：
1. 首先通过关键字搜索所有的源码信息
2. 对比启动器的调用堆栈
3. 在源码中搜索关键字，对比启动器调用栈中的函数名
4. 最终定位到目标函数

### 4.3 实战案例

**目标地址**：https://www.qimai.cn/rank/offline
**接口地址**：https://api.qimai.cn/rank/offline

**分析步骤**：

1. **接口载荷数据分析**
   - 捕获两次接口对比 `analysis` 值是否一致
   - 使用 Python 代码测试翻页获取数据

2. **定位加密位置**
   - 尝试使用关键字定位
   - 使用 XHR 断点定位
   - 分析调用堆栈

3. **断点调试**
   - 使用页面滚动的方式触发目标接口
   - 在请求发送成功之后的回调函数处设置断点

4. **加密函数分析**
   - 观察函数作用域（以浏览器显示的蓝色竖线为准）
   - 跟踪参数 `e` 的生成过程
   - 通过分析得出选中的函数中传递了参数 `a`，需要定位 `a` 参数的生成位置

5. **查看加密函数的实现过程**
   - 通过断点得出每个中括号中调用的方法名称

6. **还原代码执行环境**
   - 除了 `a` 参数之外，还需要定位 `d` 参数

**完整 JavaScript 代码示例**：
```javascript
// 七麦数据加密函数示例
function get_analysis(page) {
    // 这里包含加密算法实现
    // 实际代码需要根据逆向分析结果编写
    return "加密后的analysis值";
}
```

**Python 中获取加密参数**：
```python
import execjs
import requests

url = "https://api.qimai.cn/rank/offline"
headers = {
    "Accept": "application/json, text/plain, */*",
    "Accept-Language": "zh-CN,zh;q=0.9",
    "Cache-Control": "no-cache",
    "Connection": "keep-alive",
    "Origin": "https://www.qimai.cn",
    "Pragma": "no-cache",
    "Sec-Fetch-Dest": "empty",
    "Sec-Fetch-Mode": "cors",
    "Sec-Fetch-Site": "same-site",
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36",
    "sec-ch-ua": "\"Google Chrome\";v=\"135\", \"Not-A.Brand\";v=\"8\", \"Chromium\";v=\"135\"",
    "sec-ch-ua-mobile": "?0",
    "sec-ch-ua-platform": "\"Windows\""
}
cookies = {
    "qm_check": "A1sdRUIQChtxen8pI0dAMRcOUFseEHBeQF0JTjVBWDAIXEQaYhAQbF1FIRUJCBETVkQSGAlIBAhVVl4pTEBTFXNbQlxTQAshV1ZIDgolAGgCEElDaw06VktIPEo+BAYbEhUSV1AABQxKQltKGQceABUAGAhHGw%3D%3D",
    "PHPSESSID": "gvoqpsl4f2f2h8qds4oh9veql0",
    "gr_user_id": "24de694d-0131-4493-b025-3c14add422b6",
    # ... 其他 cookie
}

with open('七麦数据.js', 'r', encoding='utf-8') as f:
    js_code = f.read()

    for page in range(1, 11):
        run_js = execjs.compile(js_code)
        result = run_js.call('get_analysis', page)
        params = {
            "analysis": result,
            "status": "3",
            "date": "2025-05-05",
            "sdate": "2025-05-05",
            "edate": "2025-05-05",
            "country": "cn",
            "genre": "36",
            "option": "4",
            "page": str(page)
        }

        response = requests.get(url, headers=headers, cookies=cookies, params=params)
        print(response.json())
```

### 4.4 总结

目前对于 JavaScript 加密定位有以下几种方式：

1. **XHR 断点 / DOM 断点**
   - 直接定位网络请求或 DOM 操作

2. **HOOK 技术**
   - 拦截特定函数或属性的操作

3. **关键字定位**
   - 使用关键字搜索定位加密函数
   - 在 JavaScript 代码被混淆时可能失效

4. **启动器定位**
   - 分析启动器调用栈
   - 单靠启动器不依赖搜索功能会比较吃力

5. **内存漫游**（作为了解即可）
   - 更高级的逆向技术

**实际应用建议**：
- 在之后的代码定位中，关键字搜索定位使用比较频繁
- 注意 JavaScript 代码如果被混淆，则无法使用关键字定位
- 结合多种定位方式提高成功率
- 遵守相关法律法规和网站使用协议