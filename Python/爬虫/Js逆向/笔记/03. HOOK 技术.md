# 第三章：HOOK 技术

## 1. HOOK 技术概述

### 1.1 什么是 HOOK 技术
`HOOK` 是一种钩子技术，在系统没有调用函数之前，钩子程序就先得到控制权，这时钩子函数既可以加工处理（改变）该函数的执行行为，也可以强制结束消息的传递。简单来说，修改原有的 JavaScript 代码就是 `HOOK`。

### 1.2 HOOK 实现机制
- **客户端控制权**：客户端（浏览器）拥有 JavaScript 的最高解释权，可以决定在任何时候注入 JavaScript，而服务器无法阻止或干预。
- **弱类型语言特性**：JavaScript 是一种弱类型语言，同一个变量可以多次定义、根据需要进行不同的赋值，这为我们 hook 代码提供了便利。
- **作用域限制**：JavaScript 变量是有作用域的，只有当被 hook 的函数和 debugger 断点在同一个作用域的时候，才能 hook 成功。

### 1.3 HOOK 功能介绍
当我们找到接口之后，发现有些数据是加密的，我们需要找到数据加密的位置。HOOK 技术可以帮助我们更快地定位加密位置。

**主要优势**：
- 相比 `DOM` 断点和 `XHR` 断点，定位更精确
- 减少调用栈跟踪的复杂度
- 可以直接拦截和修改函数行为

> 无论什么类型的`debugger`，一定要基于堆栈去推到这个`debugger`的创建过程
## 2. HOOK 绕过 Debugger

[js逆向--无限debugger的原理有逆向](https://www.cnblogs.com/liyuanhong/articles/18210072)

### 2.1 问题描述
在爬虫开发中可能会遇到 debugger 暂停的问题，通常是因为目标网站使用了反爬虫技术，故意在代码中插入 `debugger;` 语句或设置断点来干扰自动化工具（如爬虫）。

**常见 debugger 类型**：
- 定时器 debugger
- 控制台检测
- 构造器断点

### 2.2 解决方案

#### 2.2.1 浏览器调试功能
1. **不在此处暂停**：鼠标右击代码行号，选择"一律不在此处暂停"
2. **条件断点**：
   - 鼠标右击行号，添加条件断点
   - 添加一个不成立的条件（如 `1===0`），永远为假，就不会进入断点

#### 2.2.2 方法置空 - 控制台检测
```javascript
// 重写 setInterval 函数
setInterval = function() {};
```
**注意**：一定要在 debugger 进入之前设置。现在`setInterval`处断点，停住时再控制台重写`setInterval`，再放开调试。

#### 2.2.3 替换文件
1. 把 `JavaScript` 文件保存到本地修改
2. 删除或改写 `debugger` 相关代码
3. 使用文件替换方式重新加载
4. 用 `PyCharm` 启动的文件，后缀需要删除掉

#### 2.2.4 代码注入（HOOK） - 构造器
```javascript
// 写法一
// 先备份控制台默认 constructor 
var _constructor = constructor;
// constructor 与 Function.prototype.constructor 的内存地址相同，修改后者会同步修改前者
Function.prototype.constructor = function(attr) {
    if (attr === "debugger") {
        // console.log(attr);
        return null;
    }
    return _constructor(attr); // 内置函数保护
};

// 写法二
// 先备份控制台默认 constructor 
var _constructor = constructor;
// constructor 与 Function.prototype.constructor 的内存地址相同，修改后者会同步修改前者
Function.prototype.constructor = function() {
    if (argument[0].indexOf('debugger') !== -1) {
        return null;
    }
    return _constructor(attr);
};

// 写法三
var _Function = Function;
Function.prototype.constructor = function(){
	if (arguments[0].indexOf('debugger') !== -1){
		return null;
	}
	return _Function(arguments[0])
}

```

**原理**：调用 `constructor` 方法时判断参数是否为 `"debugger"`，如果是则改写方法并返回 `null`，否则使用原方法返回。

> 直接在浏览器控制台输入其中一种即可

注意！！！：这样操作会使全局`constructor`失效。

## 3. HOOK 定位数据加密位置

### 3.1 案例需求
访问指定网站地址并获取响应数据，该网站的响应数据为加密数据，需定位到 JavaScript 脚本解密位置并还原明文数据。

**网站地址**：[行行查 | 行业研究数据库](https://www.hanghangcha.com/)（需注册账号）

**响应数据格式**：
```json
{
  "data": "加密后的字符串"
}
```

### 3.2 实现步骤
1. **编辑 hook 脚本使网站解密脚本 `debugger` 暂停**
2. **将代码放入浏览器控制台执行并向下翻页完成数据加载**
3. **跟踪堆栈信息定位 parse 执行位置**
4. **使用 `XHR` 断点定位数据加密位置**
5. **获取接口地址并输入到 `XHR` 断点**
6. **向下翻页触发 Ajax 的 send 方法**
7. **通过单步跳过查询到 done 方法**
8. **在 done 方法的位置上继续向下单步执行定位解密方法**

```javascript
// 自执行方法定位解密位置
(function(){
    // 备份JSON.parse
    var _parse = JSON.parse;
    // 重新定义JSON.parse，在其中增加一个debugger
    // 这样运行此脚本，就会直接在解密位置debugger，快速定位到解密位置
    JSON.parse = function(params){
        debugger;
        _parse(params);
    }
})();
```
## 4. HOOK Cookie 操作

### 4.1 基本概念
`Hook Cookie` 是指在爬虫开发中，通过拦截和修改浏览器或 HTTP 请求中的 Cookie 操作的技术。

### 4.2 主要用途
1. **绕过反爬机制**：模拟合法用户的 Cookie
2. **会话维护**：维持登录状态
3. **数据分析**：监控和分析 Cookie 的变化
4. **自动化测试**：模拟不同的用户状态

### 4.3 实现方式
1. **浏览器扩展**：开发浏览器插件来拦截和修改 Cookie
2. **代理服务器**：通过中间人代理拦截 HTTP 请求和响应
3. **JavaScript 注入**：重写 `document.cookie` 的 `getter` 和 setter 方法
4. **浏览器自动化工具**：如 Selenium、Puppeteer 等

### 4.4 案例需求
**地址**：[A股市场_同花顺行情中心_同花顺财经网](https://q.10jqka.com.cn/)
**要求**：定位 cookie 中 v 值的加密位置

### 4.5 技术原理：`Object.defineProperty()`
```javascript
// 示例代码
!function(){
	// 备份cookie
    let _cookie = document.cookie;
    Object.defineProperty(document, 'cookie', {
        set: function(val){
            // 当符合条件的cookie被设置（写入）时调用set方法，完成debugger
            if(val.indexOf("v") !== -1){
                debugger;
                console.log($`hook 到 cookie 位置：{val}`);
                _cookie = val;
            };
        },
        get: function(val){
	        // 调用cookie时直接返回cookie
            return _cookie;
        }
    })
}()
```

**特性**：无论是获取值还是修改值都会触发设置的 set 方法或 get 方法。

### 4.6 定位过程
1. **创建检测脚本**：在控制台的代码段中创建新脚本文件，输入检测 cookie 的代码并执行
2. **触发操作**：点击翻页
3. **定位函数**：根据调用堆栈定位操作 Cookie 的函数位置
4. **获取 Cookie**：在控制台执行 `rt.update()` 方法获取 Cookie

## 5. `HOOK` `XHR` 请求

### 5.1 概念介绍
`Hook XHR` 技术是一种前端监控和拦截 `HTTP` 请求的方法，通过重写浏览器原生的 `XMLHttpRequest` 对象来实现请求拦截，可以在发送请求前和收到响应后添加自定义处理逻辑。

### 5.2 JavaScript 语法补充（`JS`调用函数的四种方式）
```javascript
window = global;  
window.name = '李非';  
  
let stu_info = {  
    name: "张三",  
    age: 18,  
    my_func: function () {  
        console.log('this指向:', this);  
        console.log(`姓名：${this.name}`);  
    },  
};  
  
stu_info.my_func();  
(0, stu_info.my_func)(); // this指向window  
stu_info.my_func.call(stu_info); // this指向stu_info  
stu_info.my_func.apply(stu_info); // this指向stu_info  
  
stu_info.my_func.call(null); // this指向window  
stu_info.my_func.call(null, 1, 2, 3); // this指向window, 传递参数按序传入  
stu_info.my_func.apply(null, [1, 2, 3]) // this指向window, 参数以数组形式传入
```

### 5.3 爬虫案例
**地址**：`https://www.qimai.cn/`

**Hook 脚本**：
```javascript
(function () {
    var open = window.XMLHttpRequest.prototype.open;
    window.XMLHttpRequest.prototype.open = function (method, url, async) {
        if (url.indexOf("analysis") != -1) {
            debugger;
        }
        return open.apply(this, arguments);
    };
})();
```

## 6. `XMLHttpRequest` 与拦截器

### 6.1 `XMLHttpRequest` 对象
`XMLHttpRequest` 对象用于与服务器交互，可以在不刷新页面的情况下请求特定的 URL 获取数据。

**主要方法**：
1. **`XMLHttpRequest.open()`**：初始化一个新创建的请求
2. **`XMLHttpRequest.send()`**：发送请求
3. **`XMLHttpRequest.setRequestHeader()`**：设置 HTTP 请求头的值
4. **`XMLHttpRequest.onreadystatechange`**：当 `readyState` 属性发生变化时调用的事件处理器

**注意**：必须在请求的网站中的控制台执行 JavaScript 脚本。

### 6.2 拦截器概念
1. **请求拦截器**：在发送请求之前，对请求的内容和参数做检测，有问题可以直接取消请求
2. **响应拦截器**：当服务器返回响应数据时，在拿到结果前预先处理响应数据

### 6.3 `Axios` 拦截器示例

**安装 `axios`**：
```bash
npm install axios -s
```

**配置国内源**：
```bash
npm config set registry https://registry.npm.taobao.org
```

**拦截器代码示例**：
```javascript
// 因为在Node中无法直接使用XMLHttpRequest，需要自行下载发功工具 axios// npm install axios  
  
let axios = require("axios")  
  
// 添加请求拦截器  
axios.interceptors.request.use(function(config){  
    console.log("请求拦截成功")  
    // 配置  
    config.headers['User-Agent'] = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) " +  
        "AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36";  
    return config;  
})  
  
// 添加响应拦截器  
axios.interceptors.response.use(function (response) {  
    // 将response响应对象中的信息打印出来  
    console.log("响应拦截成功");  
    return response.data  
}, function (error) {  
    console.log('拦截失败...')  
    return Promise.reject(error); // 返回失败原因  
});  
  
// 发送请求（异步,Promise），需要用then获取响应结果  
axios.get("http://httpbin.org/get")  
    .then(response=>{  
            // 输出响应结果  
            console.log(response)  
        })  
  
// 输出结果  
  
/*请求拦截成功  
响应拦截成功  
{  
  args: {},  headers: {    Accept: 'application/json, text/plain, *!/!*',    'Accept-Encoding': 'gzip, compress, deflate, br',    Host: 'httpbin.org',    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36',    'X-Amzn-Trace-Id': 'Root=1-695e63d4-2f3792d0012f4c645bf091be'  },  origin: '27.13.7.30',  url: 'http://httpbin.org/get'}*/
```

```javascript

```
## 7. 总结

HOOK 技术是爬虫开发中的重要技术手段，主要应用于：

1. **绕过反爬机制**：如 debugger 断点
2. **定位加密位置**：快速找到数据加密/解密函数
3. **监控网络请求**：拦截和修改 HTTP 请求
4. **操作 Cookie**：监控和修改 Cookie 的生成和读取

掌握 HOOK 技术可以大大提高爬虫开发的效率和成功率，但需要注意：
- HOOK 代码需要在正确的作用域执行
- 避免影响网站正常功能
- 注意代码执行时机
- 遵守相关法律法规和网站使用协议