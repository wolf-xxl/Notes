
## 1. 模块基础概念

### 1.1 什么是模块

```python
# ========== 模块的基本概念 ==========
"""
模块(Module)是一个包含Python代码的.py文件
模块可以包含函数、类、变量和可执行代码
使用模块可以组织代码，提高可重用性
"""

# ========== 为什么使用模块 ==========
"""
1. 代码组织：将相关功能组织在一起
2. 可重用性：可以在多个程序中使用同一模块
3. 命名空间：避免命名冲突
4. 维护性：便于维护和更新
"""

# ========== Python模块示例 ==========
# 内置模块
import math
import os
import sys

# 标准库模块
import datetime
import json
import re

# 自定义模块
# import mymodule

print(f"math模块: {math}")
print(f"math.pi = {math.pi}")
print(f"当前工作目录: {os.getcwd()}")
print(f"Python路径: {sys.path}")

# ========== 模块的__name__属性 ==========
def demonstrate_name():
    """演示__name__属性的用法"""
    print(f"当前模块的__name__: {__name__}")
    
    if __name__ == "__main__":
        print("这个模块是直接运行的")
    else:
        print("这个模块是被导入的")

# 运行演示
demonstrate_name()
```

### 1.2 模块的创建和使用

```python
# ========== 创建简单模块 ==========
"""
创建一个名为 calculator.py 的模块
文件内容：
# calculator.py
'''一个简单的计算器模块'''

def add(a, b):
    '''返回两个数的和'''
    return a + b

def subtract(a, b):
    '''返回两个数的差'''
    return a - b

def multiply(a, b):
    '''返回两个数的积'''
    return a * b

def divide(a, b):
    '''返回两个数的商'''
    if b == 0:
        raise ValueError("除数不能为零")
    return a / b

if __name__ == "__main__":
    # 测试代码
    print(f"5 + 3 = {add(5, 3)}")
    print(f"5 - 3 = {subtract(5, 3)}")
"""

# ========== 导入整个模块 ==========
# 方法1：导入整个模块
import calculator

result1 = calculator.add(10, 5)
result2 = calculator.multiply(4, 7)
print(f"10 + 5 = {result1}")
print(f"4 × 7 = {result2}")

# ========== 导入特定函数 ==========
# 方法2：导入特定函数
from calculator import add, multiply

result3 = add(8, 2)
result4 = multiply(3, 9)
print(f"8 + 2 = {result3}")
print(f"3 × 9 = {result4}")

# ========== 导入所有函数 ==========
# 方法3：导入所有函数（不推荐）
from calculator import *

result5 = subtract(15, 6)
result6 = divide(20, 4)
print(f"15 - 6 = {result5}")
print(f"20 ÷ 4 = {result6}")

# ========== 使用别名 ==========
# 方法4：使用别名
import calculator as calc
from calculator import add as addition

result7 = calc.add(7, 3)
result8 = addition(9, 1)
print(f"7 + 3 = {result7}")
print(f"9 + 1 = {result8}")

# ========== 模块搜索路径 ==========
import sys

print("Python模块搜索路径:")
for path in sys.path:
    print(f"  {path}")

# 添加自定义路径
custom_path = "/path/to/my/modules"
if custom_path not in sys.path:
    sys.path.append(custom_path)
```

## 2. 包(Package)详解

### 2.1 包的基本概念

```python
# ========== 什么是包 ==========
"""
包(Package)是包含多个模块的目录
包必须包含一个__init__.py文件（Python 3.3+可选）
包可以包含子包，形成层次结构
"""

# ========== 包目录结构示例 ==========
"""
my_package/
├── __init__.py
├── module1.py
├── module2.py
├── subpackage1/
│   ├── __init__.py
│   ├── submodule1.py
│   └── submodule2.py
└── subpackage2/
    ├── __init__.py
    └── submodule3.py
"""

# ========== __init__.py 文件 ==========
"""
__init__.py 文件的作用：
1. 标识目录为Python包
2. 初始化包级别的代码
3. 控制包的导入行为
4. 定义__all__变量控制from package import *
"""

# ========== 创建简单的包 ==========
# 创建 mypackage/__init__.py 文件
"""
# mypackage/__init__.py
'''我的自定义包'''

__version__ = '1.0.0'
__author__ = 'Your Name'

# 导入包级别的功能
from .module1 import function1
from .module2 import function2

# 定义__all__变量
__all__ = ['function1', 'function2', 'subpackage1']
"""

# 创建 mypackage/module1.py 文件
"""
# mypackage/module1.py
def function1():
    '''模块1的功能1'''
    return "这是模块1的功能1"

def helper_function():
    '''内部辅助函数'''
    return "辅助功能"
"""

# 创建 mypackage/module2.py 文件
"""
# mypackage/module2.py
def function2():
    '''模块2的功能2'''
    return "这是模块2的功能2"
"""

# ========== 导入包的方式 ==========
# 方法1：导入整个包
import mypackage

print(mypackage.__version__)
result1 = mypackage.function1()
print(result1)

# 方法2：从包导入特定模块
from mypackage import module1

result2 = module1.function1()
print(result2)

# 方法3：从包导入特定函数
from mypackage.module1 import function1

result3 = function1()
print(result3)

# 方法4：导入子包
from mypackage.subpackage1 import submodule1

result4 = submodule1.sub_function()
print(result4)
```

### 2.2 高级包特性

```python
# ========== 相对导入 ==========
"""
相对导入使用 . 和 .. 来引用当前包和父包
只能在包内部使用，不能在顶层模块使用
"""

# 在 mypackage/subpackage1/submodule1.py 中使用相对导入
"""
# submodule1.py
from . import submodule2  # 导入同级模块
from .. import module1    # 导入父级模块
from ... import module2   # 导入祖父级模块（不推荐）

def sub_function():
    return "子模块1的功能"
"""

# ========== __all__ 变量 ==========
# 在 mypackage/__init__.py 中定义
"""
__all__ = ['function1', 'function2', 'subpackage1']
"""

# 使用 from mypackage import *
from mypackage import *

# 只会导入 __all__ 中定义的名称
print(function1())
print(function2())

# ========== 命名空间包 ==========
"""
命名空间包（Python 3.3+）：
- 不需要 __init__.py 文件
- 多个目录可以共同构成一个包
- 用于大型项目的模块分发
"""

# 示例：分布在多个位置的包
"""
目录结构：
project1/
└── my_namespace/
    └── module_a.py

project2/
└── my_namespace/
    └── module_b.py

两个目录中的 my_namespace 会合并为一个包
"""

# ========== 包内数据文件访问 ==========
import pkgutil
import importlib.resources

# 方法1：使用 pkgutil
data = pkgutil.get_data('mypackage', 'data/datafile.txt')
if data:
    print(f"数据文件内容: {data.decode('utf-8')}")

# 方法2：使用 importlib.resources (Python 3.7+)
try:
    with importlib.resources.open_text('mypackage', 'datafile.txt') as f:
        content = f.read()
        print(f"资源文件内容: {content}")
except FileNotFoundError:
    print("资源文件未找到")

# ========== 动态导入 ==========
# 方法1：使用 importlib
import importlib

# 动态导入模块
module_name = "json"
json_module = importlib.import_module(module_name)
print(f"动态导入的模块: {json_module}")

# 方法2：使用 __import__
os_module = __import__('os')
print(f"使用__import__导入: {os_module}")

# ========== 重新加载模块 ==========
import importlib

# 第一次导入
import mymodule
print(f"第一次导入: {mymodule.value}")

# 修改 mymodule 中的 value
# 然后重新加载
importlib.reload(mymodule)
print(f"重新加载后: {mymodule.value}")
```

## 3. 标准库模块详解

### 3.1 常用标准库模块

```python
# ========== os 模块 - 操作系统接口 ==========
import os

# 文件和目录操作
print(f"当前工作目录: {os.getcwd()}")
print(f"环境变量PATH: {os.getenv('PATH')}")
print(f"操作系统: {os.name}")

# 创建目录
if not os.path.exists('test_dir'):
    os.makedirs('test_dir')
    print("创建目录成功")

# 列出目录内容
print("当前目录内容:")
for item in os.listdir('.'):
    print(f"  {item}")

# 路径操作
file_path = os.path.join('test_dir', 'test_file.txt')
print(f"文件路径: {file_path}")

# ========== sys 模块 - 系统相关参数和函数 ==========
import sys

print(f"Python版本: {sys.version}")
print(f"平台: {sys.platform}")
print(f"命令行参数: {sys.argv}")

# 查看已加载的模块
print("已加载的模块数量:", len(sys.modules))

# 退出程序
# sys.exit(0)  # 正常退出
# sys.exit(1)  # 异常退出

# ========== datetime 模块 - 日期和时间 ==========
import datetime

# 当前时间
now = datetime.datetime.now()
print(f"当前时间: {now}")
print(f"格式化时间: {now.strftime('%Y-%m-%d %H:%M:%S')}")

# 日期计算
tomorrow = now + datetime.timedelta(days=1)
last_week = now - datetime.timedelta(weeks=1)
print(f"明天: {tomorrow.date()}")
print(f"上周: {last_week.date()}")

# 特定日期
birthday = datetime.datetime(1990, 5, 15)
print(f"生日: {birthday.strftime('%Y年%m月%d日')}")

# ========== json 模块 - JSON数据处理 ==========
import json

# Python对象转换为JSON
data = {
    "name": "Alice",
    "age": 25,
    "cities": ["New York", "London", "Tokyo"],
    "is_student": False
}

json_string = json.dumps(data, indent=2, ensure_ascii=False)
print("JSON字符串:")
print(json_string)

# JSON转换为Python对象
parsed_data = json.loads(json_string)
print(f"解析后的姓名: {parsed_data['name']}")

# 文件操作
with open('data.json', 'w', encoding='utf-8') as f:
    json.dump(data, f, ensure_ascii=False, indent=2)

with open('data.json', 'r', encoding='utf-8') as f:
    loaded_data = json.load(f)
    print(f"从文件加载的数据: {loaded_data}")

# ========== collections 模块 - 容器数据类型 ==========
import collections

# 计数器
counter = collections.Counter(['apple', 'banana', 'apple', 'orange', 'banana', 'apple'])
print(f"水果计数: {counter}")
print(f"苹果出现次数: {counter['apple']}")

# 默认字典
default_dict = collections.defaultdict(int)
default_dict['a'] += 1
default_dict['b'] += 2
print(f"默认字典: {dict(default_dict)}")

# 有序字典（Python 3.7+ 普通字典已有序，但OrderedDict有额外方法）
ordered_dict = collections.OrderedDict()
ordered_dict['z'] = 1
ordered_dict['a'] = 2
ordered_dict['c'] = 3
print(f"有序字典: {dict(ordered_dict)}")

# 命名元组
Point = collections.namedtuple('Point', ['x', 'y'])
p = Point(10, 20)
print(f"点坐标: ({p.x}, {p.y})")
```

### 3.2 更多实用标准库模块

```python
# ========== re 模块 - 正则表达式 ==========
import re

text = "我的电话是123-4567-8901，邮箱是example@email.com"

# 查找电话号码
phone_pattern = r'\d{3}-\d{4}-\d{4}'
phone_match = re.search(phone_pattern, text)
if phone_match:
    print(f"找到电话号码: {phone_match.group()}")

# 查找所有邮箱
email_pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
emails = re.findall(email_pattern, text)
print(f"找到邮箱: {emails}")

# 替换文本
new_text = re.sub(phone_pattern, '***-****-****', text)
print(f"替换后文本: {new_text}")

# ========== random 模块 - 随机数生成 ==========
import random

# 随机数
print(f"随机整数(1-100): {random.randint(1, 100)}")
print(f"随机浮点数: {random.random()}")
print(f"高斯分布随机数: {random.gauss(0, 1)}")

# 随机选择
items = ['苹果', '香蕉', '橙子', '葡萄']
print(f"随机选择: {random.choice(items)}")
print(f"随机样本: {random.sample(items, 2)}")

# 打乱顺序
random.shuffle(items)
print(f"打乱后: {items}")

# ========== math 模块 - 数学运算 ==========
import math

print(f"圆周率: {math.pi}")
print(f"自然常数: {math.e}")
print(f"平方根: {math.sqrt(16)}")
print(f"对数: {math.log(100, 10)}")
print(f"正弦值: {math.sin(math.pi/2)}")

# 常数
print(f"π = {math.pi}")
print(f"e = {math.e}")
print(f"τ = {math.tau}")

# ========== itertools 模块 - 迭代器工具 ==========
import itertools

# 无限迭代器
print("前5个自然数:")
for i in itertools.islice(itertools.count(1), 5):
    print(i, end=' ')
print()

# 排列组合
letters = ['A', 'B', 'C']
print("所有排列:")
for perm in itertools.permutations(letters, 2):
    print(perm)

print("所有组合:")
for comb in itertools.combinations(letters, 2):
    print(comb)

# 循环迭代
print("循环迭代:")
cycle_iter = itertools.cycle(['A', 'B', 'C'])
for i, item in enumerate(cycle_iter):
    if i >= 6:
        break
    print(item, end=' ')
print()
```

## 4. 第三方包管理

### 4.1 pip包管理

```python
# ========== pip常用命令 ==========
"""
pip install package_name          # 安装包
pip install package_name==1.0.0   # 安装指定版本
pip install -r requirements.txt   # 从文件安装
pip uninstall package_name        # 卸载包
pip list                         # 列出已安装的包
pip show package_name            # 显示包信息
pip freeze > requirements.txt    # 导出依赖
pip install --upgrade package_name  # 升级包
"""

# ========== 在Python中使用pip ==========
import subprocess
import sys

def install_package(package):
    """使用pip安装包"""
    try:
        subprocess.check_call([sys.executable, "-m", "pip", "install", package])
        print(f"成功安装 {package}")
    except subprocess.CalledProcessError:
        print(f"安装 {package} 失败")

def get_installed_packages():
    """获取已安装的包列表"""
    try:
        result = subprocess.check_output([sys.executable, "-m", "pip", "list"])
        return result.decode('utf-8')
    except subprocess.CalledProcessError:
        return "无法获取包列表"

# 示例：安装请求包
# install_package('requests')

# 查看已安装的包
# packages = get_installed_packages()
# print(packages)

# ========== 虚拟环境 ==========
"""
虚拟环境创建和使用：
python -m venv myenv          # 创建虚拟环境
source myenv/bin/activate     # Linux/Mac激活
myenv\Scripts\activate       # Windows激活
deactivate                   # 退出虚拟环境
"""

# ========== requirements.txt 文件 ==========
"""
requirements.txt 文件示例：
requests==2.25.1
numpy>=1.19.0
pandas
flask
"""

def generate_requirements():
    """生成requirements.txt文件"""
    try:
        with open('requirements.txt', 'w') as f:
            subprocess.call([sys.executable, "-m", "pip", "freeze"], stdout=f)
        print("已生成requirements.txt文件")
    except Exception as e:
        print(f"生成requirements.txt失败: {e}")

# 生成依赖文件
# generate_requirements()
```

### 4.2 常用第三方包

```python
# ========== requests - HTTP请求 ==========
"""
import requests

# GET请求
response = requests.get('https://api.github.com')
print(f"状态码: {response.status_code}")
print(f"响应内容: {response.text}")

# POST请求
data = {'key': 'value'}
response = requests.post('https://httpbin.org/post', data=data)
print(f"POST响应: {response.json()}")

# 带参数的请求
params = {'q': 'python', 'page': 1}
response = requests.get('https://httpbin.org/get', params=params)
print(f"带参数的URL: {response.url}")
"""

# ========== pandas - 数据分析 ==========
"""
import pandas as pd

# 创建DataFrame
data = {
    'Name': ['Alice', 'Bob', 'Charlie'],
    'Age': [25, 30, 35],
    'City': ['New York', 'London', 'Paris']
}
df = pd.DataFrame(data)
print(df)

# 数据操作
print(f"描述统计:\n{df.describe()}")
print(f"前2行:\n{df.head(2)}")

# 读取CSV文件
# df = pd.read_csv('data.csv')
"""

# ========== numpy - 数值计算 ==========
"""
import numpy as np

# 创建数组
arr = np.array([1, 2, 3, 4, 5])
print(f"数组: {arr}")

# 数组运算
print(f"数组平方: {arr ** 2}")
print(f"数组求和: {np.sum(arr)}")

# 矩阵操作
matrix = np.array([[1, 2], [3, 4]])
print(f"矩阵:\n{matrix}")
print(f"矩阵逆:\n{np.linalg.inv(matrix)}")
"""

# ========== 其他常用第三方包 ==========
"""
# Flask - Web框架
from flask import Flask
app = Flask(__name__)

@app.route('/')
def hello():
    return 'Hello, World!'

# if __name__ == '__main__':
#     app.run()

# SQLAlchemy - 数据库ORM
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    name = Column(String)

# OpenCV - 计算机视觉
import cv2
# image = cv2.imread('image.jpg')
# cv2.imshow('Image', image)
# cv2.waitKey(0)

# Matplotlib - 数据可视化
import matplotlib.pyplot as plt
# plt.plot([1, 2, 3, 4])
# plt.ylabel('some numbers')
# plt.show()
"""
```

## 5. 模块和包的高级特性

### 5.1 模块属性和内省

```python
# ========== 模块属性 ==========
import math

# 查看模块的所有属性
print("math模块的属性:")
for attr in dir(math):
    if not attr.startswith('_'):  # 过滤私有属性
        print(f"  {attr}")

# 获取特定属性
print(f"模块文档: {math.__doc__}")
print(f"模块名称: {math.__name__}")
print(f"模块文件: {math.__file__}")

# ========== 内省(Introspection) ==========
def inspect_module(module):
    """检查模块的详细信息"""
    print(f"模块: {module.__name__}")
    print(f"文件: {getattr(module, '__file__', '内置模块')}")
    
    # 获取函数和类
    functions = []
    classes = []
    variables = []
    
    for attr_name in dir(module):
        if attr_name.startswith('_'):
            continue
            
        attr = getattr(module, attr_name)
        attr_type = type(attr).__name__
        
        if callable(attr):
            if isinstance(attr, type):
                classes.append(attr_name)
            else:
                functions.append(attr_name)
        else:
            variables.append(attr_name)
    
    print(f"函数({len(functions)}): {functions}")
    print(f"类({len(classes)}): {classes}")
    print(f"变量({len(variables)}): {variables}")

# 检查math模块
inspect_module(math)

# ========== 模块缓存 ==========
import sys

print(f"已加载模块数量: {len(sys.modules)}")

# 查看特定模块是否已加载
if 'json' in sys.modules:
    print("json模块已加载")
    print(f"json模块对象: {sys.modules['json']}")

# ========== 自定义模块属性 ==========
# 创建自定义模块属性
import types

# 创建模块对象
my_module = types.ModuleType('my_module')
my_module.__doc__ = "这是一个自定义模块"

# 添加属性
my_module.version = '1.0.0'
my_module.author = '开发者'

def hello():
    return "Hello from custom module!"

my_module.hello = hello

# 将模块添加到sys.modules
sys.modules['my_module'] = my_module

# 使用自定义模块
import my_module
print(f"自定义模块: {my_module.hello()}")
print(f"版本: {my_module.version}")
```

### 5.2 模块导入钩子和元路径

```python
# ========== 导入钩子 ==========
import importlib.abc
import importlib.machinery
import sys

class CustomFinder(importlib.abc.MetaPathFinder):
    """自定义模块查找器"""
    
    def find_spec(self, fullname, path, target=None):
        """查找模块规范"""
        print(f"查找模块: {fullname}, 路径: {path}")
        
        # 如果是我们的自定义模块
        if fullname == "my_virtual_module":
            # 创建模块规范
            spec = importlib.machinery.ModuleSpec(fullname, None)
            spec.origin = "virtual"
            spec.loader = self
            return spec
        
        return None  # 让其他查找器处理

class CustomLoader(importlib.abc.Loader):
    """自定义模块加载器"""
    
    def create_module(self, spec):
        """创建模块对象"""
        return None  # 使用默认创建方式
    
    def exec_module(self, module):
        """执行模块代码"""
        if module.__name__ == "my_virtual_module":
            module.data = "这是虚拟模块的数据"
            module.get_info = lambda: f"虚拟模块信息: {module.data}"

# 注册查找器
finder = CustomFinder()
sys.meta_path.insert(0, finder)

# ========== 动态创建模块 ==========
def create_dynamic_module(name, code):
    """动态创建模块"""
    module = types.ModuleType(name)
    exec(code, module.__dict__)
    sys.modules[name] = module
    return module

# 创建动态模块
dynamic_code = """
version = '1.0.0'

def greet(name):
    return f"Hello, {name}!"

class Calculator:
    def add(self, a, b):
        return a + b
"""

dynamic_module = create_dynamic_module('dynamic_math', dynamic_code)

# 使用动态模块
import dynamic_math
print(f"动态模块版本: {dynamic_math.version}")
print(f"问候: {dynamic_math.greet('World')}")

calc = dynamic_math.Calculator()
print(f"计算: {calc.add(5, 3)}")

# ========== 导入重载 ==========
class ReloadableModule:
    """可重载模块管理器"""
    
    def __init__(self, module_name):
        self.module_name = module_name
        self.module = None
        self.load()
    
    def load(self):
        """加载模块"""
        if self.module_name in sys.modules:
            del sys.modules[self.module_name]
        
        self.module = importlib.import_module(self.module_name)
        print(f"已加载模块: {self.module_name}")
    
    def reload(self):
        """重载模块"""
        self.module = importlib.reload(self.module)
        print(f"已重载模块: {self.module_name}")
    
    def get_attribute(self, attr_name):
        """获取模块属性"""
        return getattr(self.module, attr_name)

# 使用可重载模块
# reloader = ReloadableModule('my_module')
# value = reloader.get_attribute('some_value')
# 修改my_module.py后...
# reloader.reload()
# new_value = reloader.get_attribute('some_value')
```

## 6. 模块打包和分发

### 6.1 setup.py和打包配置

```python
# ========== setup.py 基本结构 ==========
"""
setup.py 文件示例：

from setuptools import setup, find_packages

setup(
    name="my_package",
    version="1.0.0",
    author="Your Name",
    author_email="your.email@example.com",
    description="A short description of your package",
    long_description=open("README.md").read(),
    long_description_content_type="text/markdown",
    url="https://github.com/yourusername/my_package",
    packages=find_packages(),
    classifiers=[
        "Development Status :: 3 - Alpha",
        "Intended Audience :: Developers",
        "License :: OSI Approved :: MIT License",
        "Operating System :: OS Independent",
        "Programming Language :: Python :: 3",
        "Programming Language :: Python :: 3.7",
        "Programming Language :: Python :: 3.8",
        "Programming Language :: Python :: 3.9",
    ],
    python_requires=">=3.7",
    install_requires=[
        "requests>=2.25.0",
        "numpy>=1.19.0",
    ],
    extras_require={
        "dev": [
            "pytest>=6.0",
            "black",
            "flake8",
        ],
    },
    entry_points={
        "console_scripts": [
            "my_command=my_package.cli:main",
        ],
    },
)
"""

# ========== pyproject.toml 现代配置 ==========
"""
pyproject.toml 文件示例（Python 3.6+）：

[build-system]
requires = ["setuptools>=45", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "my_package"
version = "1.0.0"
authors = [
    {name = "Your Name", email = "your.email@example.com"}
]
description = "A short description of your package"
readme = "README.md"
requires-python = ">=3.7"
classifiers = [
    "Development Status :: 3 - Alpha",
    "Intended Audience :: Developers",
    "License :: OSI Approved :: MIT License",
    "Operating System :: OS Independent",
    "Programming Language :: Python :: 3",
]

dependencies = [
    "requests>=2.25.0",
    "numpy>=1.19.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=6.0",
    "black",
    "flake8",
]

[project.scripts]
my_command = "my_package.cli:main"
"""

# ========== 包目录结构 ==========
"""
推荐的项目结构：

my_project/
├── my_package/
│   ├── __init__.py
│   ├── module1.py
│   ├── module2.py
│   └── subpackage/
│       ├── __init__.py
│       └── submodule.py
├── tests/
│   ├── __init__.py
│   ├── test_module1.py
│   └── test_module2.py
├── docs/
│   └── ...
├── README.md
├── LICENSE
├── setup.py
├── pyproject.toml
└── requirements.txt
"""
```

### 6.2 构建和发布

```python
# ========== 构建包 ==========
"""
构建命令：
python setup.py sdist bdist_wheel    # 传统方式
python -m build                      # 现代方式（需要安装build）

生成文件：
dist/
├── my_package-1.0.0.tar.gz         # 源码包
└── my_package-1.0.0-py3-none-any.whl  # 二进制包
"""

# ========== 发布到PyPI ==========
"""
发布命令：
python -m twine upload dist/*       # 上传到PyPI

需要先安装twine：
pip install twine

需要PyPI账号和token
"""

# ========== 本地安装 ==========
"""
本地安装方式：
pip install .                       # 当前目录
pip install -e .                    # 可编辑模式安装
pip install /path/to/package        # 从路径安装
"""

# ========== 版本管理 ==========
import importlib.metadata

def get_package_info(package_name):
    """获取包信息"""
    try:
        # Python 3.8+
        metadata = importlib.metadata.metadata(package_name)
        version = importlib.metadata.version(package_name)
        
        print(f"包: {package_name}")
        print(f"版本: {version}")
        print(f"作者: {metadata['Author']}")
        print(f"描述: {metadata['Summary']}")
        print(f"主页: {metadata['Home-page']}")
        
    except importlib.metadata.PackageNotFoundError:
        print(f"包 {package_name} 未安装")

# 获取包信息
# get_package_info('requests')

# ========== 依赖管理 ==========
def check_dependencies():
    """检查项目依赖"""
    try:
        # 读取requirements.txt
        with open('requirements.txt', 'r') as f:
            requirements = [line.strip() for line in f if line.strip()]
        
        missing = []
        for req in requirements:
            package_name = req.split('==')[0].split('>=')[0].split('<=')[0]
            try:
                importlib.import_module(package_name.replace('-', '_'))
            except ImportError:
                missing.append(req)
        
        if missing:
            print("缺少的依赖:")
            for dep in missing:
                print(f"  {dep}")
        else:
            print("所有依赖都已安装")
            
    except FileNotFoundError:
        print("requirements.txt 文件不存在")

# 检查依赖
# check_dependencies()
```

## 7. 最佳实践和设计模式

### 7.1 模块设计最佳实践

```python
# ========== 模块组织原则 ==========
"""
1. 单一职责：每个模块应该只负责一个明确的功能
2. 高内聚：相关功能组织在同一个模块中
3. 低耦合：模块之间尽量减少依赖
4. 明确接口：提供清晰的公共API
"""

# ========== 良好的模块结构示例 ==========
"""
# database/__init__.py
'''数据库操作模块'''

from .connection import connect, disconnect
from .queries import execute_query, fetch_all
from .models import User, Product

__all__ = ['connect', 'disconnect', 'execute_query', 'fetch_all', 'User', 'Product']

# database/connection.py
'''数据库连接管理'''

def connect(database_url):
    """连接到数据库"""
    # 实现细节
    pass

def disconnect():
    """断开数据库连接"""
    # 实现细节
    pass

# database/queries.py
'''数据库查询'''

def execute_query(query, params=None):
    """执行SQL查询"""
    # 实现细节
    pass

def fetch_all(query, params=None):
    """获取所有结果"""
    # 实现细节
    pass

# database/models.py
'''数据模型'''

class User:
    """用户模型"""
    def __init__(self, id, name):
        self.id = id
        self.name = name

class Product:
    """产品模型"""
    def __init__(self, id, name, price):
        self.id = id
        self.name = name
        self.price = price
"""

# ========== 配置管理 ==========
import os
from typing import Dict, Any

class Config:
    """配置管理类"""
    
    _instance = None
    _config: Dict[str, Any] = {}
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        if not self._config:
            self._load_config()
    
    def _load_config(self):
        """加载配置"""
        # 默认配置
        self._config = {
            'database': {
                'host': 'localhost',
                'port': 5432,
                'name': 'myapp'
            },
            'app': {
                'debug': False,
                'secret_key': 'default-secret-key'
            }
        }
        
        # 从环境变量覆盖
        if db_host := os.getenv('DB_HOST'):
            self._config['database']['host'] = db_host
        
        if debug_mode := os.getenv('DEBUG'):
            self._config['app']['debug'] = debug_mode.lower() == 'true'
    
    def get(self, key: str, default=None):
        """获取配置值"""
        keys = key.split('.')
        value = self._config
        
        try:
            for k in keys:
                value = value[k]
            return value
        except (KeyError, TypeError):
            return default
    
    def set(self, key: str, value: Any):
        """设置配置值"""
        keys = key.split('.')
        config_ref = self._config
        
        for k in keys[:-1]:
            if k not in config_ref:
                config_ref[k] = {}
            config_ref = config_ref[k]
        
        config_ref[keys[-1]] = value

# 使用配置
config = Config()
db_host = config.get('database.host')
debug_mode = config.get('app.debug')
print(f"数据库主机: {db_host}")
print(f"调试模式: {debug_mode}")
```

### 7.2 常见模式和反模式

```python
# ========== 单例模式 ==========
class Singleton:
    """单例模式实现"""
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        if not hasattr(self, 'initialized'):
            self.initialized = True
            self.data = {}

# 使用单例
singleton1 = Singleton()
singleton2 = Singleton()
print(f"是同一个实例: {singleton1 is singleton2}")

# ========== 工厂模式 ==========
class ShapeFactory:
    """形状工厂"""
    
    @staticmethod
    def create_shape(shape_type, **kwargs):
        """创建形状"""
        shapes = {
            'circle': Circle,
            'rectangle': Rectangle,
            'triangle': Triangle
        }
        
        shape_class = shapes.get(shape_type.lower())
        if shape_class:
            return shape_class(**kwargs)
        else:
            raise ValueError(f"未知的形状类型: {shape_type}")

class Circle:
    def __init__(self, radius):
        self.radius = radius
    
    def area(self):
        return 3.14159 * self.radius ** 2

class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height

class Triangle:
    def __init__(self, base, height):
        self.base = base
        self.height = height
    
    def area(self):
        return 0.5 * self.base * self.height

# 使用工厂
circle = ShapeFactory.create_shape('circle', radius=5)
rectangle = ShapeFactory.create_shape('rectangle', width=4, height=6)
print(f"圆面积: {circle.area():.2f}")
print(f"矩形面积: {rectangle.area()}")

# ========== 观察者模式 ==========
class EventManager:
    """事件管理器"""
    
    def __init__(self):
        self._subscribers = {}
    
    def subscribe(self, event_type, callback):
        """订阅事件"""
        if event_type not in self._subscribers:
            self._subscribers[event_type] = []
        self._subscribers[event_type].append(callback)
    
    def unsubscribe(self, event_type, callback):
        """取消订阅"""
        if event_type in self._subscribers:
            self._subscribers[event_type].remove(callback)
    
    def publish(self, event_type, data=None):
        """发布事件"""
        if event_type in self._subscribers:
            for callback in self._subscribers[event_type]:
                callback(data)

# 使用观察者模式
event_manager = EventManager()

def log_event(data):
    print(f"日志事件: {data}")

def notify_user(data):
    print(f"用户通知: {data}")

event_manager.subscribe('user_login', log_event)
event_manager.subscribe('user_login', notify_user)

# 发布事件
event_manager.publish('user_login', {'username': 'alice', 'time': '2024-01-01'})

# ========== 常见反模式 ==========
"""
反模式1：循环导入
# module_a.py
import module_b

# module_b.py  
import module_a  # 循环导入！

反模式2：过度使用from module import *
# 不推荐
from math import *

# 推荐
import math
或
from math import sqrt, pi

反模式3：模块级别的复杂逻辑
# 不推荐：在模块级别执行复杂操作
database = connect_to_database()  # 模块导入时立即连接

# 推荐：使用函数或类延迟初始化
def get_database():
    if not hasattr(get_database, '_instance'):
        get_database._instance = connect_to_database()
    return get_database._instance

反模式4：不明确的模块接口
# 不推荐：导出所有内容
# __init__.py 为空或包含所有内容

# 推荐：明确导出公共API
# __init__.py
from .core import public_function1, public_function2
from .utils import helper_function  # 如果确实需要

__all__ = ['public_function1', 'public_function2', 'helper_function']
"""
```

## 8. 调试和测试

### 8.1 模块调试

```python
# ========== 模块导入调试 ==========
def debug_module_import(module_name):
    """调试模块导入过程"""
    print(f"尝试导入模块: {module_name}")
    
    # 检查sys.path
    print("Python搜索路径:")
    for i, path in enumerate(sys.path):
        print(f"  {i}: {path}")
    
    # 尝试导入
    try:
        module = importlib.import_module(module_name)
        print(f"成功导入: {module}")
        print(f"模块文件: {getattr(module, '__file__', '内置模块')}")
        return module
    except ImportError as e:
        print(f"导入失败: {e}")
        return None

# 调试导入
# debug_module_import('requests')

# ========== 模块属性调试 ==========
def inspect_module_deep(module):
    """深度检查模块"""
    print(f"=== 模块检查: {module.__name__} ===")
    
    # 基本信息
    print(f"文件: {getattr(module, '__file__', '内置模块')}")
    print(f"文档: {module.__doc__}")
    
    # 分类属性
    functions = []
    classes = []
    constants = []
    others = []
    
    for attr_name in dir(module):
        if attr_name.startswith('_'):
            continue
            
        attr_value = getattr(module, attr_name)
        attr_type = type(attr_value).__name__
        
        if callable(attr_value):
            if isinstance(attr_value, type):
                classes.append((attr_name, attr_value))
            else:
                functions.append((attr_name, attr_value))
        elif attr_name.isupper():
            constants.append((attr_name, attr_value))
        else:
            others.append((attr_name, attr_value))
    
    # 输出结果
    print(f"\n函数({len(functions)}):")
    for name, func in functions[:5]:  # 只显示前5个
        print(f"  {name} -> {func}")
    
    print(f"\n类({len(classes)}):")
    for name, cls in classes[:5]:
        print(f"  {name} -> {cls}")
    
    print(f"\n常量({len(constants)}):")
    for name, value in constants[:5]:
        print(f"  {name} = {value}")
    
    if len(functions) > 5:
        print(f"  ... 还有 {len(functions) - 5} 个函数")
    if len(classes) > 5:
        print(f"  ... 还有 {len(classes) - 5} 个类")

# 检查模块
# inspect_module_deep(math)

# ========== 导入性能分析 ==========
import time

def profile_import(module_name, iterations=100):
    """分析模块导入性能"""
    print(f"性能分析: {module_name} ({iterations}次迭代)")
    
    # 清除模块缓存
    if module_name in sys.modules:
        del sys.modules[module_name]
    
    # 测试导入时间
    times = []
    for i in range(iterations):
        start_time = time.time()
        
        # 清除缓存并导入
        if module_name in sys.modules:
            del sys.modules[module_name]
        importlib.import_module(module_name)
        
        end_time = time.time()
        times.append(end_time - start_time)
    
    # 统计结果
    avg_time = sum(times) / len(times)
    min_time = min(times)
    max_time = max(times)
    
    print(f"平均时间: {avg_time:.6f}秒")
    print(f"最小时时间: {min_time:.6f}秒")
    print(f"最大时间: {max_time:.6f}秒")
    print(f"总时间: {sum(times):.6f}秒")

# 性能分析示例
# profile_import('json', 10)
```

### 8.2 模块测试

```python
# ========== 单元测试示例 ==========
import unittest
from unittest.mock import patch, MagicMock

# 假设我们有一个要测试的模块
"""
# string_utils.py
def reverse_string(s):
    '''反转字符串'''
    return s[::-1]

def count_vowels(s):
    '''统计元音字母数量'''
    vowels = 'aeiouAEIOU'
    return sum(1 for char in s if char in vowels)
"""

class TestStringUtils(unittest.TestCase):
    """字符串工具测试"""
    
    def test_reverse_string(self):
        """测试字符串反转"""
        from string_utils import reverse_string
        
        self.assertEqual(reverse_string("hello"), "olleh")
        self.assertEqual(reverse_string(""), "")
        self.assertEqual(reverse_string("a"), "a")
        self.assertEqual(reverse_string("123"), "321")
    
    def test_count_vowels(self):
        """测试元音统计"""
        from string_utils import count_vowels
        
        self.assertEqual(count_vowels("hello"), 2)
        self.assertEqual(count_vowels("HELLO"), 2)
        self.assertEqual(count_vowels("bcdfg"), 0)
        self.assertEqual(count_vowels(""), 0)
        self.assertEqual(count_vowels("aeiou"), 5)

# ========== 模拟测试 ==========
class TestWithMocks(unittest.TestCase):
    """使用模拟的测试"""
    
    @patch('string_utils.requests')  # 模拟requests模块
    def test_network_function(self, mock_requests):
        """测试网络相关函数"""
        # 设置模拟响应
        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {'data': 'test'}
        mock_requests.get.return_value = mock_response
        
        # 导入并测试函数
        from string_utils import fetch_data
        result = fetch_data('http://example.com')
        
        # 验证结果
        self.assertEqual(result, {'data': 'test'})
        mock_requests.get.assert_called_once_with('http://example.com')

# ========== 运行测试 ==========
def run_tests():
    """运行测试"""
    # 创建测试套件
    loader = unittest.TestLoader()
    suite = loader.loadTestsFromTestCase(TestStringUtils)
    
    # 运行测试
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(suite)
    
    # 输出结果
    print(f"测试运行: {result.testsRun}")
    print(f"失败: {len(result.failures)}")
    print(f"错误: {len(result.errors)}")
    
    return result.wasSuccessful()

# 运行测试
# if __name__ == '__main__':
#     run_tests()

# ========== 测试发现 ==========
def discover_and_run_tests():
    """自动发现并运行测试"""
    # 发现所有测试
    test_loader = unittest.TestLoader()
    test_suite = test_loader.discover('tests', pattern='test_*.py')
    
    # 运行测试
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(test_suite)
    
    return result

# 自动运行测试
# discover_and_run_tests()
```

## 总结

Python模块和包是组织代码的基础，掌握它们的使用对于编写可维护、可重用的代码至关重要。关键要点包括：

### 模块要点：
1. **创建和使用**：使用`.py`文件创建模块，通过`import`语句使用
2. **导入方式**：`import module`、`from module import name`、`import module as alias`
3. **模块属性**：`__name__`、`__file__`、`__doc__`等
4. **搜索路径**：`sys.path`定义了模块搜索顺序

### 包要点：
1. **包结构**：包含`__init__.py`的目录
2. **相对导入**：使用`.`和`..`在包内进行相对导入
3. **子包**：包可以包含子包，形成层次结构
4. **命名空间包**：Python 3.3+支持无`__init__.py`的包

### 标准库：
1. **常用模块**：`os`、`sys`、`datetime`、`json`、`collections`等
2. **功能模块**：`re`（正则）、`random`（随机）、`math`（数学）等
3. **工具模块**：`itertools`（迭代器）、`functools`（函数工具）等

### 第三方包管理：
1. **pip工具**：安装、卸载、管理第三方包
2. **虚拟环境**：隔离项目依赖
3. **requirements.txt**：记录项目依赖

### 最佳实践：
1. **模块设计**：单一职责、高内聚、低耦合
2. **包组织**：清晰的目录结构和`__init__.py`配置
3. **错误处理**：妥善处理导入错误和依赖问题
4. **测试**：为模块编写单元测试

通过深入理解和应用这些概念，你可以构建出结构清晰、易于维护的Python项目。