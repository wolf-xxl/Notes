# Python函数超详细笔记

## 1. 函数基础概念

### 1.1 什么是函数？
函数是一段可重复使用的代码块，用于执行特定任务。它接受输入参数，执行操作，并返回结果。

```python
# 最简单的函数示例
def greet():
    """一个简单的问候函数"""
    print("Hello, World!")

# 调用函数
greet()  # 输出：Hello, World!

# 带参数的函数
def greet_person(name):
    """向指定的人问候"""
    print(f"Hello, {name}!")

greet_person("Alice")  # 输出：Hello, Alice!
greet_person("Bob")    # 输出：Hello, Bob!
```

### 1.2 为什么使用函数？
```python
# 不使用函数的重复代码
print("=== 学生1 ===")
print("姓名: 张三")
print("年龄: 20")
print("成绩: 85")

print("=== 学生2 ===")
print("姓名: 李四")
print("年龄: 22")
print("成绩: 92")

# 使用函数消除重复
def print_student_info(name, age, score):
    """打印学生信息"""
    print(f"=== {name} ===")
    print(f"姓名: {name}")
    print(f"年龄: {age}")
    print(f"成绩: {score}")

print_student_info("张三", 20, 85)  # 输出：=== 张三 ===\n姓名: 张三\n年龄: 20\n成绩: 85
print_student_info("李四", 22, 92)  # 输出：=== 李四 ===\n姓名: 李四\n年龄: 22\n成绩: 92
```

## 2. 函数定义和调用

### 2.1 基本函数定义
```python
# 无参数无返回值函数
def say_hello():
    print("Hello!")

say_hello()  # 输出：Hello!

# 带参数函数
def add_numbers(a, b):
    """计算两个数的和"""
    result = a + b
    print(f"{a} + {b} = {result}")

add_numbers(5, 3)  # 输出：5 + 3 = 8
add_numbers(10, -2)  # 输出：10 + -2 = 8

# 带返回值函数
def multiply_numbers(a, b):
    """计算两个数的乘积并返回结果"""
    return a * b

product = multiply_numbers(4, 5)
print(f"乘积: {product}")  # 输出：乘积: 20

# 直接使用返回值
print(f"直接使用: {multiply_numbers(3, 7)}")  # 输出：直接使用: 21
```

### 2.2 函数文档字符串
```python
def calculate_circle_area(radius):
    """
    计算圆的面积
    
    Args:
        radius (float): 圆的半径
        
    Returns:
        float: 圆的面积
    """
    import math
    return math.pi * radius ** 2

# 查看函数文档
print(calculate_circle_area.__doc__)
# 输出：
# 计算圆的面积
#    
#    Args:
#        radius (float): 圆的半径
#        
#    Returns:
#        float: 圆的面积

# 使用help函数查看文档
help(calculate_circle_area)
# 输出：
# Help on function calculate_circle_area in module __main__:
#
# calculate_circle_area(radius)
#    计算圆的面积
#    
#    Args:
#        radius (float): 圆的半径
#        
#    Returns:
#        float: 圆的面积

area = calculate_circle_area(5)
print(f"半径为5的圆面积: {area:.2f}")  # 输出：半径为5的圆面积: 78.54
```

## 3. 函数参数详解

### 3.1 位置参数
```python
def describe_pet(animal_type, pet_name):
    """显示宠物的信息"""
    print(f"I have a {animal_type}.")
    print(f"My {animal_type}'s name is {pet_name}.")

# 按位置传递参数
describe_pet("dog", "Buddy")
# 输出：
# I have a dog.
# My dog's name is Buddy.

describe_pet("cat", "Whiskers")
# 输出：
# I have a cat.
# My cat's name is Whiskers.
```

### 3.2 关键字参数
```python
def describe_pet(animal_type, pet_name):
    """显示宠物的信息"""
    print(f"I have a {animal_type}.")
    print(f"My {animal_type}'s name is {pet_name}.")

# 使用关键字参数（顺序不重要）
describe_pet(pet_name="Buddy", animal_type="dog")
# 输出：
# I have a dog.
# My dog's name is Buddy.

# 混合使用位置参数和关键字参数
describe_pet("cat", pet_name="Whiskers")
# 输出：
# I have a cat.
# My cat's name is Whiskers.
```

### 3.3 默认参数
```python
def describe_pet(pet_name, animal_type="dog"):
    """显示宠物的信息，animal_type有默认值"""
    print(f"I have a {animal_type}.")
    print(f"My {animal_type}'s name is {pet_name}.")

# 使用默认参数
describe_pet("Buddy")  # animal_type使用默认值"dog"
# 输出：
# I have a dog.
# My dog's name is Buddy.

# 覆盖默认参数
describe_pet("Whiskers", "cat")
# 输出：
# I have a cat.
# My cat's name is Whiskers.

# 使用关键字参数覆盖默认值
describe_pet(pet_name="Max", animal_type="hamster")
# 输出：
# I have a hamster.
# My hamster's name is Max.
```

### 3.4 可变参数 *args
```python
def print_numbers(*args):
    """打印所有传入的数字"""
    print("传入的参数:", args)
    for number in args:
        print(f"数字: {number}")

print_numbers(1)        
# 输出：
# 传入的参数: (1,)
# 数字: 1

print_numbers(1, 2, 3, 4, 5)
# 输出：
# 传入的参数: (1, 2, 3, 4, 5)
# 数字: 1
# 数字: 2
# 数字: 3
# 数字: 4
# 数字: 5

# 计算任意数量数字的和
def calculate_sum(*numbers):
    """计算任意数量数字的和"""
    total = 0
    for num in numbers:
        total += num
    return total

result1 = calculate_sum(1, 2, 3)
print(f"1+2+3 = {result1}")  # 输出：1+2+3 = 6

result2 = calculate_sum(10, 20, 30, 40, 50)
print(f"10+20+30+40+50 = {result2}")  # 输出：10+20+30+40+50 = 150
```

### 3.5 关键字可变参数 **kwargs
```python
def build_profile(**kwargs):
    """构建用户资料"""
    print("用户资料:")
    for key, value in kwargs.items():
        print(f"  {key}: {value}")

build_profile(name="Alice", age=25, city="New York")
# 输出：
# 用户资料:
#   name: Alice
#   age: 25
#   city: New York

build_profile(first_name="Bob", last_name="Smith", age=30, occupation="Engineer")
# 输出：
# 用户资料:
#   first_name: Bob
#   last_name: Smith
#   age: 30
#   occupation: Engineer

# 结合使用 *args 和 **kwargs
def comprehensive_function(*args, **kwargs):
    """综合使用各种参数"""
    print("位置参数:", args)
    print("关键字参数:", kwargs)

comprehensive_function(1, 2, 3, name="Alice", age=25)
# 输出：
# 位置参数: (1, 2, 3)
# 关键字参数: {'name': 'Alice', 'age': 25}
```

## 4. 返回值详解

### 4.1 返回单个值
```python
def get_formatted_name(first_name, last_name):
    """返回格式化的姓名"""
    full_name = f"{first_name} {last_name}"
    return full_name.title()

musician = get_formatted_name('jimi', 'hendrix')
print(musician)  # 输出：Jimi Hendrix

# 返回计算结果
def calculate_rectangle_area(length, width):
    """计算矩形面积"""
    return length * width

area = calculate_rectangle_area(5, 3)
print(f"矩形面积: {area}")  # 输出：矩形面积: 15
```

### 4.2 返回多个值
```python
def get_user_info():
    """返回用户信息"""
    name = "Alice"
    age = 25
    city = "New York"
    return name, age, city  # 实际上返回一个元组

user_info = get_user_info()
print(f"用户信息: {user_info}")  # 输出：用户信息: ('Alice', 25, 'New York')
print(f"类型: {type(user_info)}")  # 输出：类型: <class 'tuple'>

# 解包返回值
name, age, city = get_user_info()
print(f"姓名: {name}")  # 输出：姓名: Alice
print(f"年龄: {age}")   # 输出：年龄: 25
print(f"城市: {city}")  # 输出：城市: New York

# 返回字典
def build_person(first_name, last_name, age=None):
    """返回一个字典，包含一个人的信息"""
    person = {'first': first_name, 'last': last_name}
    if age:
        person['age'] = age
    return person

musician = build_person('jimi', 'hendrix', age=27)
print(musician)  # 输出：{'first': 'jimi', 'last': 'hendrix', 'age': 27}
```

### 4.3 返回None的情况
```python
# 没有return语句的函数返回None
def say_hello(name):
    print(f"Hello, {name}!")

result = say_hello("Alice")
print(f"函数返回值: {result}")  # 输出：Hello, Alice!\n函数返回值: None

# 只有return没有值的函数返回None
def do_nothing():
    return

result = do_nothing()
print(f"do_nothing返回值: {result}")  # 输出：do_nothing返回值: None

# 检查返回值是否为None
def process_data(data):
    if not data:
        return None
    return data.upper()

result1 = process_data("hello")
print(f"有数据时: {result1}")  # 输出：有数据时: HELLO

result2 = process_data("")
print(f"无数据时: {result2}")  # 输出：无数据时: None

if result2 is None:
    print("没有处理任何数据")  # 输出：没有处理任何数据
```

## 5. 变量作用域

### 5.1 局部变量和全局变量
```python
# 全局变量
global_var = "我是全局变量"

def test_function():
    # 局部变量
    local_var = "我是局部变量"
    print("函数内访问局部变量:", local_var)  # 输出：函数内访问局部变量: 我是局部变量
    print("函数内访问全局变量:", global_var)  # 输出：函数内访问全局变量: 我是全局变量

test_function()
print("函数外访问全局变量:", global_var)  # 输出：函数外访问全局变量: 我是全局变量
# print("函数外访问局部变量:", local_var)  # 这会报错：NameError
```

### 5.2 global关键字
```python
# 修改全局变量
counter = 0

def increment():
    global counter  # 声明使用全局变量
    counter += 1
    print(f"函数内counter: {counter}")  # 输出：函数内counter: 1

print(f"调用前counter: {counter}")  # 输出：调用前counter: 0
increment()
print(f"调用后counter: {counter}")  # 输出：调用后counter: 1

# 如果不使用global会怎样
def increment_wrong():
    # 这里创建了一个新的局部变量，而不是修改全局变量
    counter = counter + 1  # 这会报错：UnboundLocalError

# increment_wrong()  # 取消注释会报错
```

### 5.3 nonlocal关键字
```python
def outer_function():
    # 外部函数的变量
    outer_var = "外部变量"
    
    def inner_function():
        # 使用nonlocal修改外部函数的变量
        nonlocal outer_var
        outer_var = "内部修改后的变量"
        print(f"内部函数: {outer_var}")  # 输出：内部函数: 内部修改后的变量
    
    print(f"调用前: {outer_var}")  # 输出：调用前: 外部变量
    inner_function()
    print(f"调用后: {outer_var}")  # 输出：调用后: 内部修改后的变量

outer_function()

# 对比不使用nonlocal
def outer_function2():
    count = 0
    
    def inner_function2():
        # 这里创建了一个新的局部变量count
        count = 100
        print(f"内部count: {count}")  # 输出：内部count: 100
    
    print(f"调用前count: {count}")  # 输出：调用前count: 0
    inner_function2()
    print(f"调用后count: {count}")  # 输出：调用后count: 0

outer_function2()
```

## 6. 函数高级特性

### 6.1 函数作为参数
```python
def apply_operation(numbers, operation):
    """对数字列表应用操作"""
    results = []
    for num in numbers:
        results.append(operation(num))
    return results

# 定义一些操作函数
def square(x):
    return x ** 2

def double(x):
    return x * 2

def increment(x):
    return x + 1

numbers = [1, 2, 3, 4, 5]

# 传递函数作为参数
squared = apply_operation(numbers, square)
print(f"平方: {squared}")  # 输出：平方: [1, 4, 9, 16, 25]

doubled = apply_operation(numbers, double)
print(f"加倍: {doubled}")  # 输出：加倍: [2, 4, 6, 8, 10]

incremented = apply_operation(numbers, increment)
print(f"加一: {incremented}")  # 输出：加一: [2, 3, 4, 5, 6]

# 使用lambda函数
cubed = apply_operation(numbers, lambda x: x ** 3)
print(f"立方: {cubed}")  # 输出：立方: [1, 8, 27, 64, 125]
```

### 6.2 嵌套函数
```python
def outer_function(x):
    """外部函数"""
    def inner_function(y):
        """内部函数"""
        return y * 2
    
    def another_inner(z):
        """另一个内部函数"""
        return z + 10
    
    result1 = inner_function(x)
    result2 = another_inner(x)
    return result1 + result2

print(f"嵌套函数结果: {outer_function(5)}")  # 输出：嵌套函数结果: 25

# 计算器函数
def calculator(operation):
    """根据操作返回相应的计算函数"""
    
    def add(a, b):
        return a + b
    
    def subtract(a, b):
        return a - b
    
    def multiply(a, b):
        return a * b
    
    def divide(a, b):
        if b == 0:
            return "错误：除数不能为零"
        return a / b
    
    if operation == "add":
        return add
    elif operation == "subtract":
        return subtract
    elif operation == "multiply":
        return multiply
    elif operation == "divide":
        return divide
    else:
        return None

# 使用计算器
add_func = calculator("add")
result = add_func(10, 5)
print(f"加法结果: {result}")  # 输出：加法结果: 15

multiply_func = calculator("multiply")
result = multiply_func(10, 5)
print(f"乘法结果: {result}")  # 输出：乘法结果: 50
```

### 6.3 闭包
```python
def make_multiplier(factor):
    """创建乘法器函数"""
    def multiplier(x):
        return x * factor
    return multiplier

# 创建特定的乘法器
double = make_multiplier(2)
triple = make_multiplier(3)

print(f"double(5): {double(5)}")  # 输出：double(5): 10
print(f"triple(5): {triple(5)}")  # 输出：triple(5): 15

# 计数器闭包
def make_counter():
    """创建计数器"""
    count = 0
    
    def counter():
        nonlocal count
        count += 1
        return count
    
    return counter

# 创建两个独立的计数器
counter1 = make_counter()
counter2 = make_counter()

print(f"计数器1: {counter1()}")  # 输出：计数器1: 1
print(f"计数器1: {counter1()}")  # 输出：计数器1: 2
print(f"计数器2: {counter2()}")  # 输出：计数器2: 1
print(f"计数器1: {counter1()}")  # 输出：计数器1: 3
```

### 6.4 装饰器
```python
# 基本装饰器
def my_decorator(func):
    """一个简单的装饰器"""
    def wrapper():
        print("函数执行前...")
        func()
        print("函数执行后...")
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")

say_hello()
# 输出：
# 函数执行前...
# Hello!
# 函数执行后...

# 带参数的装饰器
def timer(func):
    """计时装饰器"""
    import time
    
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"函数 {func.__name__} 执行时间: {end_time - start_time:.4f}秒")
        return result
    
    return wrapper

@timer
def slow_function():
    """模拟耗时操作"""
    import time
    time.sleep(1)
    return "完成"

result = slow_function()  # 输出：函数 slow_function 执行时间: 1.0001秒
print(f"结果: {result}")  # 输出：结果: 完成

# 带参数的装饰器
def repeat(times):
    """重复执行装饰器"""
    def decorator(func):
        def wrapper(*args, **kwargs):
            for i in range(times):
                print(f"第 {i+1} 次执行:")
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator

@repeat(3)
def greet(name):
    print(f"Hello, {name}!")

greet("Alice")
# 输出：
# 第 1 次执行:
# Hello, Alice!
# 第 2 次执行:
# Hello, Alice!
# 第 3 次执行:
# Hello, Alice!
```

## 7. Lambda函数

### 7.1 基本Lambda函数
```python
# 普通函数
def square(x):
    return x ** 2

# 等效的lambda函数
square_lambda = lambda x: x ** 2

print(f"普通函数: {square(5)}")        # 输出：普通函数: 25
print(f"Lambda函数: {square_lambda(5)}")  # 输出：Lambda函数: 25

# 多参数lambda
add = lambda a, b: a + b
multiply = lambda a, b: a * b

print(f"加法: {add(3, 4)}")        # 输出：加法: 7
print(f"乘法: {multiply(3, 4)}")   # 输出：乘法: 12
```

### 7.2 Lambda函数的应用
```python
# 在列表排序中使用
students = [
    {'name': 'Alice', 'score': 85},
    {'name': 'Bob', 'score': 92},
    {'name': 'Charlie', 'score': 78}
]

# 按分数排序
sorted_by_score = sorted(students, key=lambda x: x['score'])
print("按分数排序:", sorted_by_score)
# 输出：按分数排序: [{'name': 'Charlie', 'score': 78}, {'name': 'Alice', 'score': 85}, {'name': 'Bob', 'score': 92}]

# 按姓名排序
sorted_by_name = sorted(students, key=lambda x: x['name'])
print("按姓名排序:", sorted_by_name)
# 输出：按姓名排序: [{'name': 'Alice', 'score': 85}, {'name': 'Bob', 'score': 92}, {'name': 'Charlie', 'score': 78}]

# 在map函数中使用
numbers = [1, 2, 3, 4, 5]
squared = list(map(lambda x: x ** 2, numbers))
print(f"平方: {squared}")  # 输出：平方: [1, 4, 9, 16, 25]

# 在filter函数中使用
even_numbers = list(filter(lambda x: x % 2 == 0, numbers))
print(f"偶数: {even_numbers}")  # 输出：偶数: [2, 4]
```

## 8. 生成器函数

### 8.1 基本生成器
```python
def simple_generator():
    """一个简单的生成器"""
    yield 1
    yield 2
    yield 3

# 使用生成器
gen = simple_generator()
print(f"第一次next: {next(gen)}")  # 输出：第一次next: 1
print(f"第二次next: {next(gen)}")  # 输出：第二次next: 2
print(f"第三次next: {next(gen)}")  # 输出：第三次next: 3
# print(f"第四次next: {next(gen)}")  # 这会抛出StopIteration异常

# 使用for循环遍历生成器
for value in simple_generator():
    print(f"值: {value}")
# 输出：
# 值: 1
# 值: 2
# 值: 3
```

### 8.2 生成器表达式
```python
# 列表推导式（立即计算）
squares_list = [x**2 for x in range(5)]
print(f"列表: {squares_list}")  # 输出：列表: [0, 1, 4, 9, 16]

# 生成器表达式（惰性计算）
squares_gen = (x**2 for x in range(5))
print(f"生成器: {squares_gen}")  # 输出：生成器: <generator object <genexpr> at 0x...>

# 使用生成器表达式
print("生成器值:")
for square in squares_gen:
    print(square)
# 输出：
# 生成器值:
# 0
# 1
# 4
# 9
# 16
```

### 8.3 实用的生成器函数
```python
def fibonacci(limit):
    """生成斐波那契数列"""
    a, b = 0, 1
    count = 0
    while count < limit:
        yield a
        a, b = b, a + b
        count += 1

print("前10个斐波那契数:")
for num in fibonacci(10):
    print(num, end=" ")
# 输出：前10个斐波那契数: 0 1 1 2 3 5 8 13 21 34 

def read_large_file(file_path):
    """逐行读取大文件"""
    try:
        with open(file_path, 'r', encoding='utf-8') as file:
            for line in file:
                yield line.strip()
    except FileNotFoundError:
        print(f"文件 {file_path} 不存在")

# 模拟文件读取
lines = ["第一行", "第二行", "第三行", "第四行", "第五行"]
for line in lines:
    print(line)
# 输出：
# 第一行
# 第二行
# 第三行
# 第四行
# 第五行
```

## 9. 递归函数

### 9.1 基本递归
```python
def factorial(n):
    """计算阶乘的递归函数"""
    if n == 0 or n == 1:
        return 1
    else:
        return n * factorial(n - 1)

print(f"5的阶乘: {factorial(5)}")  # 输出：5的阶乘: 120
print(f"0的阶乘: {factorial(0)}")  # 输出：0的阶乘: 1

# 递归过程演示
def factorial_debug(n, depth=0):
    """带调试信息的阶乘函数"""
    indent = "  " * depth
    print(f"{indent}计算 factorial({n})")
    
    if n == 0 or n == 1:
        print(f"{indent}返回 1")
        return 1
    else:
        result = n * factorial_debug(n - 1, depth + 1)
        print(f"{indent}返回 {n} * factorial({n-1}) = {result}")
        return result

factorial_debug(4)
# 输出：
# 计算 factorial(4)
#   计算 factorial(3)
#     计算 factorial(2)
#       计算 factorial(1)
#       返回 1
#     返回 2 * factorial(1) = 2
#   返回 3 * factorial(2) = 6
# 返回 4 * factorial(3) = 24
```

### 9.2 递归应用
```python
def fibonacci_recursive(n):
    """递归计算斐波那契数"""
    if n <= 1:
        return n
    else:
        return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)

print("斐波那契数列:")
for i in range(10):
    print(fibonacci_recursive(i), end=" ")
# 输出：斐波那契数列: 0 1 1 2 3 5 8 13 21 34 

def binary_search(arr, target, low=0, high=None):
    """二分查找的递归实现"""
    if high is None:
        high = len(arr) - 1
    
    if low > high:
        return -1  # 未找到
    
    mid = (low + high) // 2
    
    if arr[mid] == target:
        return mid
    elif arr[mid] > target:
        return binary_search(arr, target, low, mid - 1)
    else:
        return binary_search(arr, target, mid + 1, high)

numbers = [1, 3, 5, 7, 9, 11, 13, 15]
target = 7
result = binary_search(numbers, target)
print(f"\n在 {numbers} 中查找 {target}: 索引 {result}")  # 输出：在 [1, 3, 5, 7, 9, 11, 13, 15] 中查找 7: 索引 3
```

## 10. 函数式编程工具

### 10.1 map函数
```python
# 使用map应用函数到序列
numbers = [1, 2, 3, 4, 5]

# 使用lambda函数
squared = list(map(lambda x: x ** 2, numbers))
print(f"平方: {squared}")  # 输出：平方: [1, 4, 9, 16, 25]

# 使用普通函数
def double(x):
    return x * 2

doubled = list(map(double, numbers))
print(f"加倍: {doubled}")  # 输出：加倍: [2, 4, 6, 8, 10]

# 多个序列
list1 = [1, 2, 3]
list2 = [10, 20, 30]
result = list(map(lambda x, y: x + y, list1, list2))
print(f"相加: {result}")  # 输出：相加: [11, 22, 33]
```

### 10.2 filter函数
```python
# 使用filter过滤序列
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# 过滤偶数
even_numbers = list(filter(lambda x: x % 2 == 0, numbers))
print(f"偶数: {even_numbers}")  # 输出：偶数: [2, 4, 6, 8, 10]

# 过滤大于5的数
large_numbers = list(filter(lambda x: x > 5, numbers))
print(f"大于5的数: {large_numbers}")  # 输出：大于5的数: [6, 7, 8, 9, 10]

# 使用普通函数过滤
def is_prime(n):
    """判断是否为质数"""
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

primes = list(filter(is_prime, range(2, 20)))
print(f"质数: {primes}")  # 输出：质数: [2, 3, 5, 7, 11, 13, 17, 19]
```

### 10.3 reduce函数
```python
from functools import reduce

numbers = [1, 2, 3, 4, 5]

# 计算乘积
product = reduce(lambda x, y: x * y, numbers)
print(f"乘积: {product}")  # 输出：乘积: 120

# 计算最大值
maximum = reduce(lambda x, y: x if x > y else y, numbers)
print(f"最大值: {maximum}")  # 输出：最大值: 5

# 连接字符串
words = ["Hello", "World", "Python"]
sentence = reduce(lambda x, y: x + " " + y, words)
print(f"句子: {sentence}")  # 输出：句子: Hello World Python

# 带初始值的reduce
sum_with_initial = reduce(lambda x, y: x + y, numbers, 10)
print(f"带初始值的和: {sum_with_initial}")  # 输出：带初始值的和: 25
```

## 11. 易错点和难点

### 11.1 可变默认参数陷阱
```python
# 错误示例：使用可变对象作为默认参数
def wrong_append(item, items=[]):
    items.append(item)
    return items

print("第一次调用:", wrong_append(1))  # 输出：第一次调用: [1]
print("第二次调用:", wrong_append(2))  # 输出：第二次调用: [1, 2]（意外结果！）
print("第三次调用:", wrong_append(3))  # 输出：第三次调用: [1, 2, 3]（继续累积！）

# 正确做法：使用None作为默认值
def correct_append(item, items=None):
    if items is None:
        items = []
    items.append(item)
    return items

print("第一次调用:", correct_append(1))  # 输出：第一次调用: [1]
print("第二次调用:", correct_append(2))  # 输出：第二次调用: [2]（正常结果）
print("第三次调用:", correct_append(3))  # 输出：第三次调用: [3]（正常结果）
```

### 11.2 变量作用域问题
```python
# 常见的变量作用域错误
x = 10

def modify_x():
    # 这里会报错，因为尝试修改全局变量但没有声明
    # x += 1  # UnboundLocalError
    
    # 正确做法：
    global x
    x += 1

modify_x()
print(f"修改后的x: {x}")  # 输出：修改后的x: 11

# 另一个常见错误
def confusing_scope():
    print(f"访问x: {x}")  # 这里可以读取全局x
    # x = 20  # 如果取消注释，上面一行会报错

confusing_scope()
```

### 11.3 递归深度限制
```python
import sys

def deep_recursion(n):
    """深度递归函数"""
    if n <= 0:
        return 0
    return deep_recursion(n - 1) + 1

# 查看递归深度限制
print(f"递归深度限制: {sys.getrecursionlimit()}")  # 输出：递归深度限制: 1000

# 尝试深度递归（可能会达到限制）
try:
    result = deep_recursion(1000)
    print(f"深度递归结果: {result}")
except RecursionError as e:
    print(f"递归错误: {e}")  # 可能会输出：递归错误: maximum recursion depth exceeded

# 修改递归深度限制（谨慎使用）
sys.setrecursionlimit(2000)
print(f"新的递归深度限制: {sys.getrecursionlimit()}")  # 输出：新的递归深度限制: 2000
```

## 12. 调试和测试技巧

### 12.1 使用断言调试
```python
def calculate_discount(price, discount_rate):
    """计算折扣价格"""
    # 使用断言检查前提条件
    assert price >= 0, "价格不能为负"
    assert 0 <= discount_rate <= 1, "折扣率必须在0-1之间"
    
    discounted_price = price * (1 - discount_rate)
    
    # 使用断言检查后置条件
    assert discounted_price >= 0, "折扣后价格不能为负"
    assert discounted_price <= price, "折扣后价格不能高于原价"
    
    return discounted_price

# 正常情况
result = calculate_discount(100, 0.2)
print(f"折扣价格: {result}")  # 输出：折扣价格: 80.0

# 异常情况
try:
    calculate_discount(-50, 0.1)
except AssertionError as e:
    print(f"断言错误: {e}")  # 输出：断言错误: 价格不能为负
```

### 12.2 使用日志调试
```python
import logging

# 配置日志
logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

def complex_calculation(a, b):
    """复杂的计算函数"""
    logging.debug(f"开始计算: a={a}, b={b}")
    
    if a == 0 or b == 0:
        logging.warning("参数包含零")
    
    result = (a ** 2 + b ** 2) ** 0.5
    logging.debug(f"计算结果: {result}")
    
    return result

# 使用函数
result = complex_calculation(3, 4)
print(f"结果: {result}")  # 输出：结果: 5.0
# 同时会输出日志信息
```

### 12.3 单元测试示例
```python
import unittest

def add(a, b):
    """简单的加法函数"""
    return a + b

def divide(a, b):
    """除法函数"""
    if b == 0:
        raise ValueError("除数不能为零")
    return a / b

# 单元测试
class TestMathFunctions(unittest.TestCase):
    
    def test_add(self):
        self.assertEqual(add(2, 3), 5)
        self.assertEqual(add(-1, 1), 0)
        self.assertEqual(add(0, 0), 0)
    
    def test_divide(self):
        self.assertEqual(divide(6, 2), 3)
        self.assertEqual(divide(5, 2), 2.5)
        
        with self.assertRaises(ValueError):
            divide(10, 0)

# 运行测试
if __name__ == '__main__':
    unittest.main()
```

## 13. 性能优化技巧

### 13.1 使用局部变量
```python
import time

def slow_function():
    """慢速函数：频繁访问全局变量"""
    result = 0
    for i in range(1000000):
        result += i  # 频繁访问局部变量i
    return result

def fast_function():
    """快速函数：使用局部变量"""
    result = 0
    local_range = range  # 将全局变量转为局部变量
    for i in local_range(1000000):
        result += i
    return result

# 测试性能
start = time.time()
slow_function()
slow_time = time.time() - start

start = time.time()
fast_function()
fast_time = time.time() - start

print(f"慢速函数时间: {slow_time:.4f}秒")  # 输出：慢速函数时间: 0.0352秒
print(f"快速函数时间: {fast_time:.4f}秒")  # 输出：快速函数时间: 0.0281秒
print(f"性能提升: {(slow_time - fast_time) / slow_time * 100:.1f}%")  # 输出：性能提升: 20.2%
```

### 13.2 使用缓存
```python
from functools import lru_cache

# 没有缓存的递归斐波那契
def fibonacci_slow(n):
    if n <= 1:
        return n
    return fibonacci_slow(n - 1) + fibonacci_slow(n - 2)

# 使用缓存的斐波那契
@lru_cache(maxsize=None)
def fibonacci_fast(n):
    if n <= 1:
        return n
    return fibonacci_fast(n - 1) + fibonacci_fast(n - 2)

# 测试性能
import time

print("计算fibonacci(30):")
start = time.time()
result_slow = fibonacci_slow(30)
slow_time = time.time() - start

start = time.time()
result_fast = fibonacci_fast(30)
fast_time = time.time() - start

print(f"慢速版本: {result_slow}, 时间: {slow_time:.4f}秒")  # 输出：慢速版本: 832040, 时间: 0.3785秒
print(f"快速版本: {result_fast}, 时间: {fast_time:.4f}秒")  # 输出：快速版本: 832040, 时间: 0.0001秒
print(f"性能提升: {slow_time / fast_time:.0f}倍")  # 输出：性能提升: 3785倍
```

## 14. 总结

### 14.1 函数核心概念总结
1. **函数定义**：使用def关键字，包含函数名、参数和函数体
2. **参数传递**：位置参数、关键字参数、默认参数、可变参数
3. **返回值**：使用return语句，可以返回多个值（实际上是元组）
4. **作用域**：局部变量、全局变量、nonlocal关键字
5. **高级特性**：嵌套函数、闭包、装饰器、生成器

### 14.2 最佳实践
1. 编写清晰的文档字符串
2. 使用类型提示提高代码可读性
3. 避免可变默认参数陷阱
4. 合理使用lambda函数
5. 适当使用装饰器增强函数功能
6. 使用生成器处理大数据集

### 14.3 调试和优化
1. 使用断言检查前提和后置条件
2. 使用日志记录函数执行过程
3. 编写单元测试确保函数正确性
4. 使用缓存优化重复计算
5. 使用局部变量提高性能

掌握这些函数相关的概念和技巧，能够帮助您编写出更加模块化、可重用和高效的Python代码！