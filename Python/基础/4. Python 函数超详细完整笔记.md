
## 1. 函数基础概念

### 1.1 什么是函数

```python
# ========== 函数的基本概念 ==========
"""
函数是一段可重用的代码块，用于执行特定任务。
在Python中，函数使用def关键字定义。
"""

# 最简单的函数
def greet():
    """简单的问候函数"""
    print("Hello, World!")

# 调用函数
greet()  # 输出: Hello, World!

# ========== 函数的优势 ==========
"""
1. 代码重用 - 避免重复代码
2. 模块化 - 将复杂问题分解为小问题
3. 可维护性 - 修改只需在一处进行
4. 可测试性 - 可以单独测试每个函数
"""

# 示例：没有函数的情况
print("=== 没有函数的情况 ===")
# 计算5的平方
result1 = 5 * 5
print(f"5的平方是: {result1}")

# 计算8的平方
result2 = 8 * 8
print(f"8的平方是: {result2}")

# 计算12的平方
result3 = 12 * 12
print(f"12的平方是: {result3}")

# 示例：使用函数的情况
print("\n=== 使用函数的情况 ===")
def square(number):
    """计算平方的函数"""
    return number * number

print(f"5的平方是: {square(5)}")
print(f"8的平方是: {square(8)}")
print(f"12的平方是: {square(12)}")
```

### 1.2 函数定义和调用

```python
# ========== 函数定义语法 ==========
"""
def function_name(parameters):
    '''文档字符串（可选）'''
    # 函数体
    return value  # 返回值（可选）
"""

# 无参数无返回值函数
def say_hello():
    """打印问候语"""
    print("Hello!")

# 带参数无返回值函数
def greet_person(name):
    """向指定的人问候"""
    print(f"Hello, {name}!")

# 带参数有返回值函数
def add_numbers(a, b):
    """返回两个数的和"""
    return a + b

# 多个返回值的函数
def get_min_max(numbers):
    """返回列表中的最小值和最大值"""
    return min(numbers), max(numbers)

# ========== 函数调用 ==========
# 调用无参数函数
say_hello()  # 输出: Hello!

# 调用带参数函数
greet_person("Alice")  # 输出: Hello, Alice!
greet_person("Bob")    # 输出: Hello, Bob!

# 调用有返回值函数
result = add_numbers(5, 3)
print(f"5 + 3 = {result}")  # 输出: 5 + 3 = 8

# 直接使用返回值
print(f"10 + 20 = {add_numbers(10, 20)}")  # 输出: 10 + 20 = 30

# 调用多个返回值的函数
numbers = [3, 1, 4, 1, 5, 9, 2, 6]
min_val, max_val = get_min_max(numbers)
print(f"最小值: {min_val}, 最大值: {max_val}")  # 输出: 最小值: 1, 最大值: 9

# ========== 函数的文档字符串 ==========
def calculate_area(radius):
    """
    计算圆的面积
    
    参数:
        radius (float): 圆的半径
        
    返回:
        float: 圆的面积
    """
    return 3.14159 * radius ** 2

# 查看文档字符串
print(calculate_area.__doc__)

# 使用help函数查看文档
help(calculate_area)

# ========== 空函数 ==========
def todo_function():
    """待实现的函数"""
    pass  # 占位符，什么都不做

def future_function():
    """将来要实现的函数"""
    ...  # 另一种占位符写法（Python 3+）

# 调用空函数
todo_function()  # 没有输出，也没有错误
```

## 2. 函数参数详解

### 2.1 位置参数和关键字参数

```python
# ========== 位置参数 ==========
def describe_pet(animal_type, pet_name):
    """显示宠物的信息"""
    print(f"\nI have a {animal_type}.")
    print(f"My {animal_type}'s name is {pet_name}.")

# 必须按照定义顺序传递参数
describe_pet('hamster', 'Harry')    # 正确
describe_pet('Harry', 'hamster')    # 逻辑错误！

# ========== 关键字参数 ==========
# 使用参数名指定值，可以不按顺序
describe_pet(animal_type='hamster', pet_name='Harry')  # 正确
describe_pet(pet_name='Harry', animal_type='hamster')  # 也正确

# ========== 默认参数 ==========
def describe_pet_with_default(pet_name, animal_type='dog'):
    """显示宠物的信息，animal_type有默认值"""
    print(f"\nI have a {animal_type}.")
    print(f"My {animal_type}'s name is {pet_name}.")

# 使用默认值
describe_pet_with_default('Willie')                    # animal_type使用默认值'dog'
describe_pet_with_default('Harry', 'hamster')          # 提供animal_type值
describe_pet_with_default(pet_name='Harry', animal_type='hamster')  # 关键字参数

# ========== 默认参数的注意事项 ==========
# 错误示例：可变对象作为默认参数
def bad_append(item, items=[]):  # 危险！默认列表在函数定义时创建
    items.append(item)
    return items

print(bad_append(1))  # [1]
print(bad_append(2))  # [1, 2] - 保留了之前的状态！

# 正确做法：使用None作为默认值
def good_append(item, items=None):
    if items is None:
        items = []  # 每次调用都创建新列表
    items.append(item)
    return items

print(good_append(1))  # [1]
print(good_append(2))  # [2] - 每次都创建新列表

# ========== 参数组合规则 ==========
"""
参数定义的顺序必须是：
1. 位置参数
2. 默认参数
3. 可变位置参数 (*args)
4. 关键字参数
5. 可变关键字参数 (**kwargs)
"""

def complex_function(a, b=10, *args, c=20, **kwargs):
    """演示各种参数类型的组合"""
    print(f"a: {a}, b: {b}, c: {c}")
    print(f"args: {args}")
    print(f"kwargs: {kwargs}")

complex_function(1)                           # a:1, b:10, c:20
complex_function(1, 2)                        # a:1, b:2, c:20  
complex_function(1, 2, 3, 4, 5)              # a:1, b:2, args:(3,4,5), c:20
complex_function(1, 2, 3, 4, c=30)           # a:1, b:2, args:(3,4), c:30
complex_function(1, 2, 3, 4, c=30, d=40)     # a:1, b:2, args:(3,4), c:30, kwargs:{'d':40}
```

### 2.2 可变参数

```python
# ========== 可变位置参数 (*args) ==========
def print_numbers(*args):
    """打印所有传入的数字"""
    print(f"参数类型: {type(args)}")  # tuple
    print("数字:", end=" ")
    for number in args:
        print(number, end=" ")
    print()

print_numbers(1)              # 数字: 1
print_numbers(1, 2, 3)        # 数字: 1 2 3
print_numbers(1, 2, 3, 4, 5)  # 数字: 1 2 3 4 5

# 与其他参数结合使用
def make_pizza(size, *toppings):
    """制作披萨"""
    print(f"\nMaking a {size}-inch pizza with the following toppings:")
    for topping in toppings:
        print(f"- {topping}")

make_pizza(12, 'pepperoni')
make_pizza(16, 'mushrooms', 'green peppers', 'extra cheese')

# ========== 可变关键字参数 (**kwargs) ==========
def build_profile(**kwargs):
    """构建用户档案"""
    print(f"参数类型: {type(kwargs)}")  # dict
    profile = {}
    for key, value in kwargs.items():
        profile[key] = value
        print(f"{key}: {value}")
    return profile

user_profile = build_profile(
    first_name='Alice',
    last_name='Smith', 
    age=25,
    occupation='Engineer'
)

# 与其他参数结合使用
def create_car(brand, model, **car_info):
    """创建汽车信息"""
    car_info['brand'] = brand
    car_info['model'] = model
    return car_info

car = create_car('Toyota', 'Camry', color='blue', year=2022, fuel_efficient=True)
print(f"汽车信息: {car}")

# ========== 解包参数 ==========
# 使用 * 解包序列作为位置参数
def greet_multiple(greeting, *names):
    """向多个人问候"""
    for name in names:
        print(f"{greeting}, {name}!")

names_list = ['Alice', 'Bob', 'Charlie']
greet_multiple('Hello', *names_list)  # 解包列表

# 使用 ** 解包字典作为关键字参数
def introduce_person(name, age, city):
    """介绍一个人"""
    print(f"{name} is {age} years old and lives in {city}.")

person_info = {'name': 'Alice', 'age': 25, 'city': 'New York'}
introduce_person(**person_info)  # 解包字典

# ========== 综合示例 ==========
def flexible_function(a, b, *args, c=10, **kwargs):
    """演示所有参数类型的函数"""
    print(f"a: {a}, b: {b}")
    print(f"args: {args}")
    print(f"c: {c}")
    print(f"kwargs: {kwargs}")

# 各种调用方式
flexible_function(1, 2)
flexible_function(1, 2, 3, 4, 5)
flexible_function(1, 2, 3, 4, c=20)
flexible_function(1, 2, 3, 4, c=20, d=30, e=40)

# 使用解包
positional_args = (1, 2, 3, 4)
keyword_args = {'c': 50, 'd': 60, 'e': 70}
flexible_function(*positional_args, **keyword_args)
```

### 2.3 参数注解 (Type Hints)

```python
# ========== 类型提示 (Python 3.5+) ==========
from typing import List, Dict, Tuple, Optional, Union

# 基本类型注解
def greet(name: str) -> str:
    """返回问候语"""
    return f"Hello, {name}!"

# 复杂类型注解
def process_data(
    numbers: List[int],
    config: Dict[str, str],
    threshold: Optional[float] = None
) -> Tuple[bool, int]:
    """处理数据
    
    参数:
        numbers: 整数列表
        config: 配置字典
        threshold: 可选阈值
        
    返回:
        元组(成功标志, 处理的数量)
    """
    if threshold is not None:
        numbers = [n for n in numbers if n > threshold]
    
    success = len(numbers) > 0
    return success, len(numbers)

# 联合类型
def handle_input(value: Union[int, str, List]) -> str:
    """处理不同类型的输入"""
    if isinstance(value, int):
        return f"整数: {value}"
    elif isinstance(value, str):
        return f"字符串: {value}"
    elif isinstance(value, list):
        return f"列表长度: {len(value)}"
    else:
        return "未知类型"

# 调用带类型提示的函数
result = greet("Alice")
print(result)  # Hello, Alice!

numbers = [1, 5, 3, 8, 2]
config = {"mode": "fast", "debug": "true"}
success, count = process_data(numbers, config, threshold=3)
print(f"成功: {success}, 数量: {count}")

# ========== 类型检查 ==========
# 虽然Python是动态类型，但可以使用工具进行静态类型检查
# 安装: pip install mypy
# 运行: mypy your_script.py

# ========== 更复杂的类型注解 ==========
from typing import Callable, Any, Generator

# 函数类型
def apply_operation(
    numbers: List[int],
    operation: Callable[[int], int]
) -> List[int]:
    """对列表中的每个元素应用操作"""
    return [operation(n) for n in numbers]

# 使用lambda函数
result = apply_operation([1, 2, 3], lambda x: x * 2)
print(f"加倍后: {result}")  # [2, 4, 6]

# 生成器类型
def number_generator(n: int) -> Generator[int, None, None]:
    """生成数字"""
    for i in range(n):
        yield i

# 任意类型
def log_message(message: Any) -> None:
    """记录任意类型的消息"""
    print(f"日志: {message}")

# ========== 类型别名 ==========
from typing import List, Tuple

# 创建类型别名
Vector = List[float]
Matrix = List[Vector]
Point = Tuple[float, float]

def add_vectors(v1: Vector, v2: Vector) -> Vector:
    """向量加法"""
    return [a + b for a, b in zip(v1, v2)]

def distance(p1: Point, p2: Point) -> float:
    """计算两点之间的距离"""
    return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5

# 使用类型别名
v1: Vector = [1.0, 2.0, 3.0]
v2: Vector = [4.0, 5.0, 6.0]
result_vector = add_vectors(v1, v2)
print(f"向量和: {result_vector}")

p1: Point = (0, 0)
p2: Point = (3, 4)
print(f"两点距离: {distance(p1, p2)}")  # 5.0
```

## 3. 返回值详解

### 3.1 返回值的各种形式

```python
# ========== 无返回值函数 ==========
def print_hello():
    """没有return语句，隐式返回None"""
    print("Hello!")

result = print_hello()  # 输出: Hello!
print(f"返回值: {result}")  # 返回值: None

# ========== 单个返回值 ==========
def square(number):
    """返回单个值"""
    return number * number

result = square(5)
print(f"5的平方: {result}")  # 25

# ========== 多个返回值（实际上是元组） ==========
def get_stats(numbers):
    """返回多个值（实际上是返回元组）"""
    return min(numbers), max(numbers), sum(numbers) / len(numbers)

# 接收多个返回值
min_val, max_val, avg_val = get_stats([1, 2, 3, 4, 5])
print(f"最小值: {min_val}, 最大值: {max_val}, 平均值: {avg_val}")

# 实际上返回的是元组
result = get_stats([1, 2, 3, 4, 5])
print(f"返回类型: {type(result)}")  # <class 'tuple'>
print(f"返回值: {result}")  # (1, 5, 3.0)

# ========== 返回None ==========
def do_nothing():
    """显式返回None"""
    return None

def do_nothing_implicit():
    """隐式返回None"""
    pass

print(f"显式返回None: {do_nothing()}")        # None
print(f"隐式返回None: {do_nothing_implicit()}") # None

# ========== 条件返回 ==========
def get_grade(score):
    """根据分数返回等级"""
    if score >= 90:
        return "A"
    elif score >= 80:
        return "B"
    elif score >= 70:
        return "C"
    elif score >= 60:
        return "D"
    else:
        return "F"

print(f"85分的等级: {get_grade(85)}")  # B
print(f"55分的等级: {get_grade(55)}")  # F

# ========== 提前返回 ==========
def find_first_even(numbers):
    """找到第一个偶数并返回"""
    for number in numbers:
        if number % 2 == 0:
            return number  # 找到就立即返回
    return None  # 没找到返回None

numbers = [1, 3, 5, 8, 9, 10]
result = find_first_even(numbers)
print(f"第一个偶数: {result}")  # 8

# ========== 返回函数 ==========
def create_multiplier(factor):
    """返回一个乘法函数"""
    def multiplier(x):
        return x * factor
    return multiplier

# 创建特定的乘法器
double = create_multiplier(2)
triple = create_multiplier(3)

print(f"double(5): {double(5)}")  # 10
print(f"triple(5): {triple(5)}")  # 15

# ========== 返回复杂数据结构 ==========
def analyze_text(text):
    """分析文本并返回统计信息"""
    words = text.split()
    characters = len(text)
    word_count = len(words)
    unique_words = len(set(words))
    
    return {
        'text': text,
        'character_count': characters,
        'word_count': word_count,
        'unique_words': unique_words,
        'words': words
    }

analysis = analyze_text("Hello world hello python world")
print("文本分析结果:")
for key, value in analysis.items():
    print(f"  {key}: {value}")
```

### 3.2 返回值的特殊用法

```python
# ========== 链式调用 ==========
class Calculator:
    def __init__(self, value=0):
        self.value = value
    
    def add(self, n):
        self.value += n
        return self  # 返回self以支持链式调用
    
    def subtract(self, n):
        self.value -= n
        return self
    
    def multiply(self, n):
        self.value *= n
        return self
    
    def get_value(self):
        return self.value

# 链式调用
result = Calculator(10).add(5).multiply(2).subtract(3).get_value()
print(f"链式计算结果: {result}")  # (10 + 5) * 2 - 3 = 27

# ========== 返回生成器 ==========
def fibonacci_sequence(n):
    """生成斐波那契数列的前n项"""
    a, b = 0, 1
    for _ in range(n):
        yield a
        a, b = b, a + b

# 使用生成器
print("斐波那契数列:")
for num in fibonacci_sequence(10):
    print(num, end=" ")
print()

# ========== 返回装饰器 ==========
def repeat(times):
    """返回一个装饰器，重复执行函数多次"""
    def decorator(func):
        def wrapper(*args, **kwargs):
            results = []
            for _ in range(times):
                results.append(func(*args, **kwargs))
            return results
        return wrapper
    return decorator

@repeat(3)
def say_hello(name):
    return f"Hello, {name}!"

result = say_hello("Alice")
print(f"重复调用结果: {result}")  # ['Hello, Alice!', 'Hello, Alice!', 'Hello, Alice!']

# ========== 返回类 ==========
def create_person_class(class_name):
    """动态创建Person类"""
    class Person:
        def __init__(self, name, age):
            self.name = name
            self.age = age
        
        def introduce(self):
            return f"我是{self.name}，今年{self.age}岁"
    
    # 修改类名
    Person.__name__ = class_name
    return Person

# 使用动态创建的类
Student = create_person_class("Student")
teacher = create_person_class("Teacher")("张老师", 35)

student = Student("小明", 18)
print(student.introduce())  # 我是小明，今年18岁
print(teacher.introduce())  # 我是张老师，今年35岁

# ========== 返回异常 ==========
def safe_divide(a, b):
    """安全除法，返回结果或异常"""
    try:
        return a / b
    except ZeroDivisionError as e:
        return e

result1 = safe_divide(10, 2)
result2 = safe_divide(10, 0)

print(f"10 / 2 = {result1}")      # 5.0
print(f"10 / 0 = {result2}")      # division by zero
print(f"异常类型: {type(result2)}")  # <class 'ZeroDivisionError'>
```

## 4. 函数作用域和闭包

### 4.1 作用域详解

```python
# ========== 局部作用域 ==========
def local_scope_demo():
    """演示局部作用域"""
    local_var = "我是局部变量"
    print(f"函数内部: {local_var}")

local_scope_demo()
# print(local_var)  # 错误！NameError: name 'local_var' is not defined

# ========== 全局作用域 ==========
global_var = "我是全局变量"

def access_global():
    """访问全局变量"""
    print(f"函数内访问全局变量: {global_var}")

access_global()
print(f"函数外访问全局变量: {global_var}")

# ========== 修改全局变量 ==========
counter = 0

def increment_counter():
    """修改全局变量需要使用global关键字"""
    global counter
    counter += 1
    print(f"计数器: {counter}")

increment_counter()  # 计数器: 1
increment_counter()  # 计数器: 2
increment_counter()  # 计数器: 3

# ========== 嵌套作用域 ==========
def outer_function():
    """外部函数"""
    outer_var = "外部变量"
    
    def inner_function():
        """内部函数可以访问外部函数的变量"""
        print(f"内部函数访问: {outer_var}")
    
    inner_function()
    print(f"外部函数访问: {outer_var}")

outer_function()

# ========== nonlocal关键字 ==========
def outer_function():
    """演示nonlocal关键字"""
    count = 0
    
    def inner_function():
        nonlocal count  # 声明使用外部函数的变量
        count += 1
        print(f"计数: {count}")
    
    return inner_function

counter = outer_function()
counter()  # 计数: 1
counter()  # 计数: 2
counter()  # 计数: 3

# ========== 作用域查找规则 (LEGB) ==========
"""
L - Local: 局部作用域
E - Enclosing: 嵌套作用域
G - Global: 全局作用域  
B - Built-in: 内置作用域
"""

x = "global x"

def test_scope():
    x = "enclosing x"
    
    def inner():
        x = "local x"
        print(f"局部作用域: {x}")
    
    def inner_no_local():
        # 没有局部x，查找嵌套作用域
        print(f"嵌套作用域: {x}")
    
    def inner_no_outer():
        # 没有局部和嵌套x，查找全局作用域
        global x
        print(f"全局作用域: {x}")
    
    inner()           # 局部作用域: local x
    inner_no_local()  # 嵌套作用域: enclosing x  
    inner_no_outer()  # 全局作用域: global x

test_scope()
```

### 4.2 闭包详解

```python
# ========== 基本闭包 ==========
def outer_function(msg):
    """外部函数"""
    message = msg
    
    def inner_function():
        """内部函数（闭包）"""
        print(message)
    
    return inner_function

# 创建闭包
hello_func = outer_function("Hello")
goodbye_func = outer_function("Goodbye")

hello_func()    # 输出: Hello
goodbye_func()  # 输出: Goodbye

# ========== 闭包的实际应用 - 计数器 ==========
def create_counter():
    """创建计数器闭包"""
    count = 0
    
    def counter():
        nonlocal count
        count += 1
        return count
    
    return counter

# 创建两个独立的计数器
counter1 = create_counter()
counter2 = create_counter()

print(f"计数器1: {counter1()}")  # 1
print(f"计数器1: {counter1()}")  # 2
print(f"计数器2: {counter2()}")  # 1
print(f"计数器2: {counter2()}")  # 2
print(f"计数器1: {counter1()}")  # 3

# ========== 闭包的实际应用 - 配置函数 ==========
def configure_multiplier(factor):
    """配置乘法器"""
    def multiplier(x):
        return x * factor
    return multiplier

# 创建不同的乘法器
double = configure_multiplier(2)
triple = configure_multiplier(3)
quadruple = configure_multiplier(4)

print(f"double(5): {double(5)}")        # 10
print(f"triple(5): {triple(5)}")        # 15  
print(f"quadruple(5): {quadruple(5)}")  # 20

# ========== 闭包的实际应用 - 记忆化 ==========
def memoize(func):
    """记忆化装饰器"""
    cache = {}
    
    def wrapper(*args):
        if args not in cache:
            cache[args] = func(*args)
        return cache[args]
    
    return wrapper

@memoize
def fibonacci(n):
    """计算斐波那契数"""
    if n < 2:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

# 使用记忆化后的函数
print(f"fibonacci(10): {fibonacci(10)}")  # 55
print(f"fibonacci(20): {fibonacci(20)}")  # 6765

# ========== 闭包的高级用法 - 函数工厂 ==========
def function_factory(operation):
    """函数工厂，根据操作创建不同的函数"""
    if operation == "add":
        def adder(a, b):
            return a + b
        return adder
    
    elif operation == "multiply":
        def multiplier(a, b):
            return a * b
        return multiplier
    
    elif operation == "power":
        def power_func(a, b):
            return a ** b
        return power_func
    
    else:
        def default_func(a, b):
            return f"未知操作: {operation}"
        return default_func

# 使用函数工厂
add_func = function_factory("add")
multiply_func = function_factory("multiply")
power_func = function_factory("power")

print(f"加法: {add_func(5, 3)}")          # 8
print(f"乘法: {multiply_func(5, 3)}")     # 15
print(f"幂运算: {power_func(5, 3)}")      # 125

# ========== 查看闭包的变量 ==========
def make_closure(x):
    def closure():
        return x
    return closure

closure_func = make_closure(10)
print(f"闭包函数: {closure_func()}")  # 10

# 查看闭包捕获的变量
print(f"闭包变量: {closure_func.__closure__}")
if closure_func.__closure__:
    for cell in closure_func.__closure__:
        print(f"单元格内容: {cell.cell_contents}")
```

## 5. 装饰器详解

### 5.1 基础装饰器

```python
# ========== 简单装饰器 ==========
def my_decorator(func):
    """简单的装饰器"""
    def wrapper():
        print("函数执行前...")
        func()
        print("函数执行后...")
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")

# 使用装饰器
say_hello()
# 输出:
# 函数执行前...
# Hello!
# 函数执行后...

# ========== 装饰器的本质 ==========
def say_hi():
    print("Hi!")

# 手动应用装饰器（等同于 @my_decorator）
decorated_say_hi = my_decorator(say_hi)
decorated_say_hi()

# ========== 带参数的函数装饰器 ==========
def decorator_with_args(func):
    """处理带参数的函数"""
    def wrapper(*args, **kwargs):
        print("函数执行前...")
        result = func(*args, **kwargs)
        print("函数执行后...")
        return result
    return wrapper

@decorator_with_args
def greet(name):
    print(f"Hello, {name}!")
    return f"Greeted {name}"

result = greet("Alice")
print(f"返回值: {result}")

# ========== 带参数的装饰器 ==========
def repeat(times):
    """带参数的装饰器"""
    def decorator(func):
        def wrapper(*args, **kwargs):
            results = []
            for i in range(times):
                print(f"第 {i+1} 次执行:")
                result = func(*args, **kwargs)
                results.append(result)
            return results
        return wrapper
    return decorator

@repeat(3)
def say_hello(name):
    print(f"Hello, {name}!")
    return f"said hello to {name}"

results = say_hello("Bob")
print(f"所有结果: {results}")

# ========== 类装饰器 ==========
class CountCalls:
    """统计函数调用次数的类装饰器"""
    def __init__(self, func):
        self.func = func
        self.call_count = 0
    
    def __call__(self, *args, **kwargs):
        self.call_count += 1
        print(f"函数 {self.func.__name__} 被调用了第 {self.call_count} 次")
        return self.func(*args, **kwargs)

@CountCalls
def example_function():
    print("执行示例函数")

example_function()
example_function()
example_function()
```

### 5.2 高级装饰器

```python
# ========== 保留函数元信息 ==========
import functools

def preserve_metadata(func):
    """保留被装饰函数的元信息"""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        """包装函数的文档"""
        print(f"调用函数: {func.__name__}")
        return func(*args, **kwargs)
    return wrapper

@preserve_metadata
def example_function():
    """这是示例函数的文档"""
    print("函数执行中...")

print(f"函数名: {example_function.__name__}")      # example_function
print(f"函数文档: {example_function.__doc__}")     # 这是示例函数的文档

# ========== 多个装饰器 ==========
def decorator1(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print("装饰器1 - 前")
        result = func(*args, **kwargs)
        print("装饰器1 - 后")
        return result
    return wrapper

def decorator2(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print("装饰器2 - 前")
        result = func(*args, **kwargs)
        print("装饰器2 - 后")
        return result
    return wrapper

@decorator1
@decorator2
def say_hello():
    print("Hello!")

print("=== 多个装饰器执行顺序 ===")
say_hello()
# 输出:
# 装饰器1 - 前
# 装饰器2 - 前
# Hello!
# 装饰器2 - 后  
# 装饰器1 - 后

# ========== 带状态的装饰器 ==========
def stateful_decorator(func):
    """带状态的装饰器"""
    state = {"count": 0}
    
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        state["count"] += 1
        print(f"第 {state['count']} 次调用 {func.__name__}")
        return func(*args, **kwargs)
    
    # 添加获取状态的方法
    wrapper.get_count = lambda: state["count"]
    wrapper.reset_count = lambda: state.update({"count": 0})
    
    return wrapper

@stateful_decorator
def test_function():
    print("测试函数执行")

test_function()
test_function()
test_function()
print(f"调用次数: {test_function.get_count()}")  # 3
test_function.reset_count()
print(f"重置后次数: {test_function.get_count()}")  # 0

# ========== 可选参数的装饰器 ==========
def flexible_decorator(func=None, *, prefix="DEBUG"):
    """可选参数的装饰器"""
    def decorator(f):
        @functools.wraps(f)
        def wrapper(*args, **kwargs):
            print(f"[{prefix}] 调用函数: {f.__name__}")
            return f(*args, **kwargs)
        return wrapper
    
    if func is None:
        # 带参数调用: @flexible_decorator(prefix="INFO")
        return decorator
    else:
        # 不带参数调用: @flexible_decorator
        return decorator(func)

# 使用方式1: 不带参数
@flexible_decorator
def function1():
    print("函数1执行")

# 使用方式2: 带参数  
@flexible_decorator(prefix="INFO")
def function2():
    print("函数2执行")

function1()
function2()
```

## 6. 高级函数特性

### 6.1 函数式编程特性

```python
# ========== 高阶函数 ==========
# 函数作为参数
def apply_operation(numbers, operation):
    """对列表中的每个元素应用操作"""
    return [operation(x) for x in numbers]

def square(x):
    return x * x

def double(x):
    return x * 2

numbers = [1, 2, 3, 4, 5]
squares = apply_operation(numbers, square)
doubles = apply_operation(numbers, double)

print(f"平方: {squares}")  # [1, 4, 9, 16, 25]
print(f"加倍: {doubles}")  # [2, 4, 6, 8, 10]

# 使用lambda表达式
cubes = apply_operation(numbers, lambda x: x ** 3)
print(f"立方: {cubes}")    # [1, 8, 27, 64, 125]

# ========== map, filter, reduce ==========
from functools import reduce

numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# map: 对每个元素应用函数
squares = list(map(lambda x: x ** 2, numbers))
print(f"map平方: {squares}")

# filter: 过滤元素
evens = list(filter(lambda x: x % 2 == 0, numbers))
print(f"filter偶数: {evens}")

# reduce: 累积计算
sum_result = reduce(lambda x, y: x + y, numbers)
product_result = reduce(lambda x, y: x * y, numbers)
print(f"reduce求和: {sum_result}")      # 55
print(f"reduce求积: {product_result}")  # 3628800

# ========== 偏函数 ==========
from functools import partial

def power(base, exponent):
    """计算幂"""
    return base ** exponent

# 创建偏函数
square = partial(power, exponent=2)
cube = partial(power, exponent=3)

print(f"5的平方: {square(5)}")  # 25
print(f"5的立方: {cube(5)}")    # 125

# 偏函数实际应用
def send_email(to, subject, body, cc=None, bcc=None):
    """发送邮件（示例）"""
    print(f"发送邮件给: {to}")
    print(f"主题: {subject}")
    print(f"正文: {body}")
    if cc:
        print(f"抄送: {cc}")
    if bcc:
        print(f"密送: {bcc}")

# 创建特定用途的偏函数
send_welcome = partial(send_email, subject="欢迎!", body="欢迎加入我们!")
send_notification = partial(send_email, subject="系统通知")

send_welcome("alice@example.com")
send_notification("bob@example.com", body="您的账户已创建")

# ========== 函数柯里化 ==========
def curry(func):
    """柯里化装饰器"""
    @functools.wraps(func)
    def curried(*args, **kwargs):
        if len(args) + len(kwargs) >= func.__code__.co_argcount:
            return func(*args, **kwargs)
        
        def partial_application(*more_args, **more_kwargs):
            new_args = args + more_args
            new_kwargs = {**kwargs, **more_kwargs}
            return curried(*new_args, **new_kwargs)
        
        return partial_application
    return curried

@curry
def add_three_numbers(a, b, c):
    return a + b + c

# 柯里化调用
result1 = add_three_numbers(1)(2)(3)
result2 = add_three_numbers(1, 2)(3)
result3 = add_three_numbers(1)(2, 3)
result4 = add_three_numbers(1, 2, 3)

print(f"柯里化结果: {result1}, {result2}, {result3}, {result4}")  # 都是6
```

### 6.2 生成器和协程

```python
# ========== 生成器函数 ==========
def simple_generator():
    """简单的生成器函数"""
    yield 1
    yield 2
    yield 3

# 使用生成器
gen = simple_generator()
print(next(gen))  # 1
print(next(gen))  # 2
print(next(gen))  # 3
# print(next(gen))  # StopIteration

# 使用for循环
for value in simple_generator():
    print(value, end=" ")  # 1 2 3
print()

# ========== 无限生成器 ==========
def infinite_counter():
    """无限计数器"""
    count = 0
    while True:
        yield count
        count += 1

counter = infinite_counter()
for i in range(5):
    print(next(counter), end=" ")  # 0 1 2 3 4
print()

# ========== 生成器表达式 ==========
# 类似于列表推导式，但返回生成器
numbers = [1, 2, 3, 4, 5]
squares_gen = (x ** 2 for x in numbers)
print(f"生成器: {squares_gen}")  # <generator object <genexpr> at ...>

# 转换为列表
squares_list = list(squares_gen)
print(f"平方列表: {squares_list}")  # [1, 4, 9, 16, 25]

# ========== 协程 ==========
def simple_coroutine():
    """简单的协程"""
    print("协程启动")
    try:
        while True:
            received = yield
            print(f"接收到: {received}")
    except GeneratorExit:
        print("协程结束")

# 使用协程
coro = simple_coroutine()
next(coro)  # 启动协程
coro.send("Hello")  # 接收到: Hello
coro.send("World")  # 接收到: World
coro.close()        # 协程结束

# ========== 生成器作为协程 ==========
def running_average():
    """计算运行平均值"""
    total = 0
    count = 0
    average = None
    
    while True:
        value = yield average
        total += value
        count += 1
        average = total / count

# 使用运行平均值生成器
avg_gen = running_average()
next(avg_gen)  # 启动生成器

print(f"平均值: {avg_gen.send(10)}")  # 10.0
print(f"平均值: {avg_gen.send(20)}")  # 15.0
print(f"平均值: {avg_gen.send(30)}")  # 20.0
```

## 7. 函数易错点和最佳实践

### 7.1 常见错误

```python
# ========== 函数易错点 ==========

# 错误1：可变默认参数
def bad_append(item, items=[]):  # 危险！
    items.append(item)
    return items

print(bad_append(1))  # [1]
print(bad_append(2))  # [1, 2] - 保留了状态！

# 正确做法
def good_append(item, items=None):
    if items is None:
        items = []
    items.append(item)
    return items

# 错误2：在函数内修改外部变量（没有使用global）
count = 0

def increment_wrong():
    # count += 1  # UnboundLocalError
    pass

def increment_correct():
    global count
    count += 1

# 错误3：不理解返回值
def no_return():
    print("没有return语句")

result = no_return()
print(f"返回值: {result}")  # None

# 错误4：混淆打印和返回
def bad_calculator(a, b):
    print(a + b)  # 这不会返回任何值！

def good_calculator(a, b):
    return a + b

# 错误5：过度使用全局变量
# 不推荐：过多全局变量
global_data = []

def process_data_bad():
    global global_data
    # 操作global_data

# 推荐：传递参数和返回值
def process_data_good(data):
    # 处理数据
    return processed_data

# 错误6：函数过于复杂
def overly_complex_function(data):
    """过于复杂的函数，做了太多事情"""
    # 验证输入
    if not isinstance(data, list):
        raise TypeError("需要列表")
    
    # 处理数据
    processed = []
    for item in data:
        if isinstance(item, int):
            processed.append(item * 2)
        elif isinstance(item, str):
            processed.append(item.upper())
    
    # 过滤数据
    filtered = [x for x in processed if x is not None]
    
    # 排序数据
    sorted_data = sorted(filtered)
    
    # 格式化输出
    result = ", ".join(str(x) for x in sorted_data)
    
    return result

# 改进：分解为多个函数
def validate_data(data):
    if not isinstance(data, list):
        raise TypeError("需要列表")
    return data

def process_items(items):
    processed = []
    for item in items:
        if isinstance(item, int):
            processed.append(item * 2)
        elif isinstance(item, str):
            processed.append(item.upper())
    return processed

def format_output(data):
    return ", ".join(str(x) for x in sorted(data))

def good_complex_function(data):
    """分解后的函数"""
    validated = validate_data(data)
    processed = process_items(validated)
    filtered = [x for x in processed if x is not None]
    return format_output(filtered)

# 错误7：忽略错误处理
def divide_unsafe(a, b):
    return a / b  # 可能除零错误

def divide_safe(a, b):
    try:
        return a / b
    except ZeroDivisionError:
        return float('inf')  # 或者抛出异常，或者返回默认值
    except TypeError:
        raise ValueError("参数必须是数字")

# 错误8：不合理的参数设计
def confusing_function(a, b, c, d, e, f):
    """参数太多，难以理解"""
    pass

# 改进：使用字典或数据类
from dataclasses import dataclass

@dataclass
class Config:
    a: int
    b: int
    c: str
    d: bool
    e: float
    f: list

def better_function(config: Config):
    """使用配置对象"""
    pass
```

### 7.2 最佳实践

```python
# ========== 函数设计最佳实践 ==========

# 1. 单一职责原则
def calculate_area(radius):
    """计算圆的面积 - 只做一件事"""
    return 3.14159 * radius ** 2

def calculate_circumference(radius):
    """计算圆的周长 - 只做一件事"""
    return 2 * 3.14159 * radius

# 2. 使用有意义的函数名和变量名
def get_customer_orders(customer_id):  # 好的命名
    pass

def get_orders(c_id):  # 不好的命名
    pass

# 3. 保持函数短小
def process_user_data(user_data):
    """处理用户数据，分解为小函数"""
    validated_data = validate_user_data(user_data)
    normalized_data = normalize_user_data(validated_data)
    return save_user_data(normalized_data)

def validate_user_data(data):
    """验证用户数据"""
    # 验证逻辑
    return data

def normalize_user_data(data):
    """标准化用户数据"""
    # 标准化逻辑
    return data

def save_user_data(data):
    """保存用户数据"""
    # 保存逻辑
    return True

# 4. 使用类型提示
from typing import List, Optional

def process_numbers(
    numbers: List[int], 
    multiplier: Optional[int] = None
) -> List[int]:
    """处理数字列表"""
    if multiplier is None:
        return numbers
    return [n * multiplier for n in numbers]

# 5. 提供清晰的文档字符串
def calculate_compound_interest(principal, rate, time, compound_frequency=1):
    """
    计算复利
    
    参数:
        principal: 本金
        rate: 年利率（小数形式，如0.05表示5%）
        time: 时间（年）
        compound_frequency: 年复利次数（默认为1）
        
    返回:
        最终金额
    """
    return principal * (1 + rate / compound_frequency) ** (compound_frequency * time)

# 6. 使用装饰器增强函数功能
import time
from functools import wraps

def timer(func):
    """计时装饰器"""
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"函数 {func.__name__} 执行时间: {end_time - start_time:.4f}秒")
        return result
    return wrapper

@timer
def slow_function():
    """模拟慢函数"""
    time.sleep(1)
    return "完成"

result = slow_function()

# 7. 合理使用默认参数和关键字参数
def create_user(
    username: str,
    email: str,
    *,  # 强制使用关键字参数
    is_active: bool = True,
    is_admin: bool = False,
    metadata: dict = None
):
    """创建用户，使用关键字参数提高可读性"""
    if metadata is None:
        metadata = {}
    
    user = {
        'username': username,
        'email': email,
        'is_active': is_active,
        'is_admin': is_admin,
        'metadata': metadata
    }
    return user

# 清晰的调用方式
user = create_user(
    "alice",
    "alice@example.com",
    is_active=True,
    is_admin=False,
    metadata={"department": "Engineering"}
)

# 8. 错误处理策略
from typing import Union

def safe_divide(
    a: Union[int, float], 
    b: Union[int, float]
) -> Union[float, str]:
    """
    安全除法运算
    
    返回:
        除法结果或错误消息
    """
    try:
        return a / b
    except ZeroDivisionError:
        return "错误：除数不能为零"
    except TypeError:
        return "错误：参数必须是数字"

# 9. 使用数据类简化参数传递
from dataclasses import dataclass
from typing import List

@dataclass
class SearchCriteria:
    query: str
    filters: List[str]
    limit: int = 10
    offset: int = 0

def search_documents(criteria: SearchCriteria) -> List[dict]:
    """根据搜索条件查找文档"""
    # 搜索逻辑
    return [{"id": 1, "title": "文档1"}]

# 清晰的调用方式
criteria = SearchCriteria(
    query="Python教程",
    filters=["技术", "编程"],
    limit=20
)
results = search_documents(criteria)
```

## 总结

Python函数是编程的核心构建块，掌握函数的使用对于编写高质量的Python代码至关重要。关键要点包括：

1. **函数定义**：使用`def`关键字，遵循命名规范，编写清晰的文档字符串。

2. **参数处理**：
   - 位置参数、关键字参数、默认参数
   - 可变参数`*args`和`**kwargs`
   - 参数解包和类型提示

3. **返回值**：理解返回值的各种形式，包括多个返回值、返回函数等。

4. **作用域**：掌握LEGB规则，合理使用`global`和`nonlocal`。

5. **高级特性**：
   - 装饰器：增强函数功能而不修改原函数
   - 闭包：捕获和保持状态
   - 生成器：惰性求值，节省内存
   - 函数式编程：`map`、`filter`、`reduce`、偏函数等

6. **最佳实践**：
   - 单一职责原则
   - 合理的错误处理
   - 使用类型提示提高可读性
   - 避免可变默认参数陷阱

通过深入理解和熟练运用这些函数特性，你可以编写出更加Pythonic、可维护和高效的代码。