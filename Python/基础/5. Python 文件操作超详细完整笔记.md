# Python文件操作超详细笔记

## 1. 文件操作基础概念

### 1.1 什么是文件操作？
文件操作是指程序与计算机文件系统进行交互的过程，包括创建、读取、写入、修改和删除文件等操作。

```python
# 文件操作的基本流程
print("文件操作基本流程:")
print("1. 打开文件")      # 输出：1. 打开文件
print("2. 读取/写入文件") # 输出：2. 读取/写入文件
print("3. 关闭文件")      # 输出：3. 关闭文件
```

### 1.2 文件路径表示
```python
import os

# 当前工作目录
current_dir = os.getcwd()
print(f"当前工作目录: {current_dir}")  # 输出：当前工作目录: /home/user (具体路径取决于运行环境)

# 路径拼接
file_path = os.path.join("documents", "python", "test.txt")
print(f"文件路径: {file_path}")  # 输出：文件路径: documents/python/test.txt

# 绝对路径和相对路径
absolute_path = os.path.abspath("test.txt")
print(f"绝对路径: {absolute_path}")  # 输出：绝对路径: /home/user/test.txt (具体路径取决于运行环境)

# 路径分解
dirname, filename = os.path.split(absolute_path)
print(f"目录名: {dirname}")    # 输出：目录名: /home/user
print(f"文件名: {filename}")   # 输出：文件名: test.txt

name, ext = os.path.splitext(filename)
print(f"文件名(无扩展名): {name}")  # 输出：文件名(无扩展名): test
print(f"扩展名: {ext}")            # 输出：扩展名: .txt
```

## 2. 文件打开和关闭

### 2.1 基本文件打开操作
```python
# 传统方式打开文件（不推荐）
file = None
try:
    file = open('example.txt', 'w')  # 以写入模式打开文件
    file.write("Hello, World!")
finally:
    if file:
        file.close()  # 必须手动关闭文件

print("传统方式文件操作完成")  # 输出：传统方式文件操作完成

# 使用with语句（推荐）
with open('example.txt', 'w') as file:
    file.write("Hello, World!")

print("with语句文件操作完成")  # 输出：with语句文件操作完成
```

### 2.2 文件打开模式详解
```python
# 各种文件打开模式示例

# 'r' - 只读模式（默认）
try:
    with open('example.txt', 'r') as file:
        content = file.read()
        print(f"读取内容: {content}")  # 输出：读取内容: Hello, World!
except FileNotFoundError:
    print("文件不存在")

# 'w' - 写入模式（覆盖）
with open('example.txt', 'w') as file:
    file.write("这是新内容\n")
    file.write("第二行内容\n")

# 'a' - 追加模式
with open('example.txt', 'a') as file:
    file.write("这是追加的内容\n")

# 'r+' - 读写模式
with open('example.txt', 'r+') as file:
    content = file.read()
    print(f"读写模式读取: {content}")  # 输出：读写模式读取: 这是新内容\n第二行内容\n这是追加的内容\n
    file.write("读写模式添加的内容\n")

# 'x' - 创建模式（文件必须不存在）
try:
    with open('new_file.txt', 'x') as file:
        file.write("这是新创建的文件\n")
    print("文件创建成功")  # 输出：文件创建成功
except FileExistsError:
    print("文件已存在")

# 二进制模式 'b'
with open('example.txt', 'rb') as file:
    binary_content = file.read()
    print(f"二进制内容: {binary_content}")  # 输出：二进制内容: b'\xe8\xbf\x99\xe6\x98\xaf...'

# 文本模式 't'（默认）
with open('example.txt', 'rt') as file:
    text_content = file.read()
    print(f"文本内容: {text_content}")  # 输出：文本内容: 这是新内容\n第二行内容\n这是追加的内容\n读写模式添加的内容\n
```

## 3. 文件读取操作

### 3.1 基本读取方法
```python
# 创建测试文件
with open('test_read.txt', 'w') as f:
    f.write("第一行内容\n")
    f.write("第二行内容\n")
    f.write("第三行内容\n")
    f.write("第四行内容\n")
    f.write("第五行内容\n")

# read() - 读取整个文件
with open('test_read.txt', 'r') as file:
    content = file.read()
    print("read()方法:")
    print(content)
    # 输出：
    # read()方法:
    # 第一行内容
    # 第二行内容
    # 第三行内容
    # 第四行内容
    # 第五行内容

# readline() - 逐行读取
print("\nreadline()方法:")
with open('test_read.txt', 'r') as file:
    line1 = file.readline()
    line2 = file.readline()
    print(f"第一行: {line1.strip()}")  # 输出：第一行: 第一行内容
    print(f"第二行: {line2.strip()}")  # 输出：第二行: 第二行内容

# readlines() - 读取所有行到列表
print("\nreadlines()方法:")
with open('test_read.txt', 'r') as file:
    lines = file.readlines()
    print(f"所有行: {lines}")  # 输出：所有行: ['第一行内容\n', '第二行内容\n', '第三行内容\n', '第四行内容\n', '第五行内容\n']
```

### 3.2 逐行读取的优雅方式
```python
# 使用for循环逐行读取（推荐）
print("使用for循环逐行读取:")
with open('test_read.txt', 'r') as file:
    for line_num, line in enumerate(file, 1):
        print(f"第{line_num}行: {line.strip()}")
    # 输出：
    # 使用for循环逐行读取:
    # 第1行: 第一行内容
    # 第2行: 第二行内容
    # 第3行: 第三行内容
    # 第4行: 第四行内容
    # 第5行: 第五行内容

# 使用列表推导式处理行
with open('test_read.txt', 'r') as file:
    lines = [line.strip() for line in file]
    print(f"处理后的行列表: {lines}")  # 输出：处理后的行列表: ['第一行内容', '第二行内容', '第三行内容', '第四行内容', '第五行内容']
```

### 3.3 读取大文件的技巧
```python
# 分块读取大文件
def read_in_chunks(file_path, chunk_size=1024):
    """分块读取大文件"""
    with open(file_path, 'r') as file:
        while True:
            chunk = file.read(chunk_size)
            if not chunk:
                break
            yield chunk

# 创建一个大文件进行测试
with open('large_file.txt', 'w') as f:
    for i in range(1000):
        f.write(f"这是第{i}行内容，包含一些测试数据用于演示分块读取功能\n")

print("分块读取演示:")
total_chars = 0
for i, chunk in enumerate(read_in_chunks('large_file.txt', 500)):
    print(f"块 {i+1}: {len(chunk)} 字符")
    total_chars += len(chunk)
print(f"总字符数: {total_chars}")  # 输出：总字符数: 78300 (具体数值可能不同)

# 使用readline()的while循环
print("\n使用while循环逐行读取:")
with open('large_file.txt', 'r') as file:
    line_count = 0
    while True:
        line = file.readline()
        if not line:  # 读到文件末尾
            break
        line_count += 1
    print(f"总行数: {line_count}")  # 输出：总行数: 1000
```

## 4. 文件写入操作

### 4.1 基本写入方法
```python
# write() - 写入字符串
with open('write_example.txt', 'w') as file:
    file.write("这是第一行\n")
    file.write("这是第二行\n")
    file.write("这是第三行\n")

print("write()方法写入完成")  # 输出：write()方法写入完成

# writelines() - 写入字符串列表
lines = ["第四行\n", "第五行\n", "第六行\n"]
with open('write_example.txt', 'a') as file:  # 追加模式
    file.writelines(lines)

print("writelines()方法写入完成")  # 输出：writelines()方法写入完成

# 验证写入内容
with open('write_example.txt', 'r') as file:
    content = file.read()
    print("写入的内容:")
    print(content)
    # 输出：
    # 写入的内容:
    # 这是第一行
    # 这是第二行
    # 这是第三行
    # 第四行
    # 第五行
    # 第六行
```

### 4.2 格式化写入
```python
# 使用字符串格式化写入
data = [
    {"name": "张三", "age": 25, "city": "北京"},
    {"name": "李四", "age": 30, "city": "上海"},
    {"name": "王五", "age": 28, "city": "广州"}
]

with open('formatted_data.txt', 'w', encoding='utf-8') as file:
    file.write("姓名\t年龄\t城市\n")  # 写入表头
    file.write("-" * 20 + "\n")
    
    for person in data:
        # 多种格式化方式
        line = f"{person['name']}\t{person['age']}\t{person['city']}\n"
        file.write(line)

print("格式化数据写入完成")  # 输出：格式化数据写入完成

# 验证格式化写入
with open('formatted_data.txt', 'r', encoding='utf-8') as file:
    content = file.read()
    print("格式化内容:")
    print(content)
    # 输出：
    # 格式化内容:
    # 姓名	年龄	城市
    # --------------------
    # 张三	25	北京
    # 李四	30	上海
    # 王五	28	广州
```

### 4.3 批量写入和性能优化
```python
import time

# 创建大量数据
large_data = [f"这是第{i}行数据\n" for i in range(10000)]

# 方法1：逐行写入（慢）
start_time = time.time()
with open('slow_write.txt', 'w') as file:
    for line in large_data:
        file.write(line)
slow_time = time.time() - start_time

# 方法2：批量写入（快）
start_time = time.time()
with open('fast_write.txt', 'w') as file:
    file.writelines(large_data)
fast_time = time.time() - start_time

# 方法3：使用join后一次性写入（最快）
start_time = time.time()
with open('fastest_write.txt', 'w') as file:
    file.write(''.join(large_data))
fastest_time = time.time() - start_time

print(f"逐行写入时间: {slow_time:.4f}秒")    # 输出：逐行写入时间: 0.0050秒
print(f"批量写入时间: {fast_time:.4f}秒")    # 输出：批量写入时间: 0.0010秒
print(f"一次性写入时间: {fastest_time:.4f}秒") # 输出：一次性写入时间: 0.0005秒
print(f"性能提升: {slow_time/fastest_time:.1f}倍") # 输出：性能提升: 10.0倍
```

## 5. 文件定位和随机访问

### 5.1 文件指针操作
```python
# 创建测试文件
with open('seek_test.txt', 'w') as f:
    for i in range(1, 11):
        f.write(f"第{i}行: 0123456789\n")

# tell() - 获取当前位置
with open('seek_test.txt', 'r') as file:
    print(f"初始位置: {file.tell()}")  # 输出：初始位置: 0
    
    # 读取前10个字符
    content = file.read(10)
    print(f"读取10字符后位置: {file.tell()}")  # 输出：读取10字符后位置: 10
    print(f"读取的内容: {content}")  # 输出：读取的内容: 第1行: 012

# seek() - 移动文件指针
with open('seek_test.txt', 'r') as file:
    # 移动到文件开头
    file.seek(0)
    print(f"移动到开头: {file.tell()}")  # 输出：移动到开头: 0
    
    # 移动到第50个字节
    file.seek(50)
    print(f"移动到50字节: {file.tell()}")  # 输出：移动到50字节: 50
    content = file.read(10)
    print(f"50字节处的内容: {content}")  # 输出：50字节处的内容: 第5行: 01
    
    # 相对当前位置移动
    file.seek(10, 1)  # 从当前位置向前移动10字节
    print(f"相对移动后: {file.tell()}")  # 输出：相对移动后: 70
    
    # 从文件末尾移动
    file.seek(-20, 2)  # 从文件末尾向前移动20字节
    print(f"从末尾移动后: {file.tell()}")  # 输出：从末尾移动后: 130
    content = file.read()
    print(f"文件末尾内容: {content}")  # 输出：文件末尾内容: 第10行: 0123456789
```

### 5.2 随机访问应用
```python
# 创建索引文件示例
def create_indexed_file():
    """创建带索引的文件"""
    data = [
        "苹果: 一种常见的水果，富含维生素",
        "香蕉: 热带水果，富含钾元素", 
        "橙子: 柑橘类水果，富含维生素C",
        "葡萄: 浆果类水果，可用于酿酒",
        "西瓜: 夏季水果，水分充足"
    ]
    
    with open('indexed_data.txt', 'w') as file:
        positions = {}
        for item in data:
            position = file.tell()  # 记录当前位置
            key = item.split(':')[0]  # 使用冒号前的部分作为键
            positions[key] = position
            file.write(item + '\n')
    
    return positions

# 创建索引文件
index = create_indexed_file()
print("文件索引:", index)  # 输出：文件索引: {'苹果': 0, '香蕉': 22, '橙子': 44, '葡萄': 66, '西瓜': 88}

# 随机读取特定条目
def read_by_index(key, index):
    """根据索引读取特定条目"""
    with open('indexed_data.txt', 'r') as file:
        if key in index:
            file.seek(index[key])
            return file.readline().strip()
        else:
            return None

# 测试随机访问
print("随机访问测试:")
print(f"苹果: {read_by_index('苹果', index)}")  # 输出：苹果: 苹果: 一种常见的水果，富含维生素
print(f"橙子: {read_by_index('橙子', index)}")  # 输出：橙子: 橙子: 柑橘类水果，富含维生素C
print(f"西瓜: {read_by_index('西瓜', index)}")  # 输出：西瓜: 西瓜: 夏季水果，水分充足
```

## 6. 二进制文件操作

### 6.1 基本二进制操作
```python
# 写入二进制文件
binary_data = bytes(range(256))  # 0-255的字节序列

with open('binary_data.bin', 'wb') as file:
    file.write(binary_data)

print("二进制文件写入完成")  # 输出：二进制文件写入完成

# 读取二进制文件
with open('binary_data.bin', 'rb') as file:
    read_data = file.read()
    print(f"读取的字节数: {len(read_data)}")  # 输出：读取的字节数: 256
    print(f"前10个字节: {list(read_data[:10])}")  # 输出：前10个字节: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# 修改二进制文件特定位置
with open('binary_data.bin', 'r+b') as file:  # 读写二进制模式
    file.seek(100)
    file.write(b'\xFF')  # 修改第100个字节为255
    
    # 验证修改
    file.seek(100)
    modified_byte = file.read(1)
    print(f"修改后的第100字节: {list(modified_byte)}")  # 输出：修改后的第100字节: [255]
```

### 6.2 结构体数据读写
```python
import struct

# 使用struct打包数据
def write_struct_data():
    """写入结构体数据"""
    data = [
        (1, 3.14, b'hello'),
        (2, 2.71, b'world'),
        (3, 1.41, b'test')
    ]
    
    with open('struct_data.bin', 'wb') as file:
        for item in data:
            # 打包数据：i表示整数，f表示浮点数，5s表示5字节字符串
            packed_data = struct.pack('if5s', item[0], item[1], item[2])
            file.write(packed_data)

write_struct_data()
print("结构体数据写入完成")  # 输出：结构体数据写入完成

# 读取结构体数据
def read_struct_data():
    """读取结构体数据"""
    with open('struct_data.bin', 'rb') as file:
        data = []
        while True:
            chunk = file.read(13)  # i(4字节) + f(4字节) + 5s(5字节) = 13字节
            if not chunk:
                break
            unpacked_data = struct.unpack('if5s', chunk)
            # 将字节串转换为字符串
            data.append((
                unpacked_data[0],
                unpacked_data[1],
                unpacked_data[2].decode('utf-8').strip('\x00')
            ))
        return data

read_data = read_struct_data()
print("读取的结构体数据:")
for item in read_data:
    print(f"  整数: {item[0]}, 浮点数: {item[1]:.2f}, 字符串: '{item[2]}'")
# 输出：
# 读取的结构体数据:
#   整数: 1, 浮点数: 3.14, 字符串: 'hello'
#   整数: 2, 浮点数: 2.71, 字符串: 'world'
#   整数: 3, 浮点数: 1.41, 字符串: 'test'
```

## 7. 文件编码处理

### 7.1 文本编码基础
```python
# 不同编码的写入和读取
text = "你好，世界！Hello, World! こんにちは"

# UTF-8编码（推荐）
with open('utf8_file.txt', 'w', encoding='utf-8') as file:
    file.write(text)

# GBK编码（中文Windows常用）
with open('gbk_file.txt', 'w', encoding='gbk') as file:
    file.write(text)

print("不同编码文件写入完成")  # 输出：不同编码文件写入完成

# 读取不同编码文件
try:
    with open('utf8_file.txt', 'r', encoding='utf-8') as file:
        utf8_content = file.read()
        print(f"UTF-8读取: {utf8_content}")  # 输出：UTF-8读取: 你好，世界！Hello, World! こんにちは
except UnicodeDecodeError as e:
    print(f"UTF-8解码错误: {e}")

try:
    with open('gbk_file.txt', 'r', encoding='gbk') as file:
        gbk_content = file.read()
        print(f"GBK读取: {gbk_content}")  # 输出：GBK读取: 你好，世界！Hello, World! こんにちは
except UnicodeDecodeError as e:
    print(f"GBK解码错误: {e}")

# 错误的编码读取
try:
    with open('gbk_file.txt', 'r', encoding='utf-8') as file:
        content = file.read()
except UnicodeDecodeError as e:
    print(f"编码不匹配错误: {e}")  # 输出：编码不匹配错误: 'utf-8' codec can't decode byte 0xc4 in position 0: invalid continuation byte
```

### 7.2 编码检测和自动处理
```python
import chardet

def detect_encoding(file_path):
    """检测文件编码"""
    with open(file_path, 'rb') as file:
        raw_data = file.read()
        result = chardet.detect(raw_data)
        return result['encoding'], result['confidence']

# 测试编码检测
encodings = ['utf8_file.txt', 'gbk_file.txt']
for file_path in encodings:
    encoding, confidence = detect_encoding(file_path)
    print(f"{file_path} - 检测编码: {encoding}, 置信度: {confidence:.2f}")
    # 输出：
    # utf8_file.txt - 检测编码: utf-8, 置信度: 0.99
    # gbk_file.txt - 检测编码: GB2312, 置信度: 0.99

# 自动编码读取函数
def read_file_auto_encoding(file_path):
    """自动检测编码并读取文件"""
    # 检测编码
    with open(file_path, 'rb') as file:
        raw_data = file.read(1000)  # 读取前1000字节用于检测
        detected = chardet.detect(raw_data)
        encoding = detected['encoding']
        confidence = detected['confidence']
    
    print(f"检测到编码: {encoding} (置信度: {confidence:.2f})")
    
    # 尝试用检测到的编码读取
    try:
        with open(file_path, 'r', encoding=encoding) as file:
            return file.read()
    except UnicodeDecodeError:
        # 如果检测失败，尝试常见编码
        encodings_to_try = ['utf-8', 'gbk', 'latin-1', 'cp1252']
        for enc in encodings_to_try:
            try:
                with open(file_path, 'r', encoding=enc) as file:
                    return file.read()
            except UnicodeDecodeError:
                continue
        raise ValueError("无法确定文件编码")

# 测试自动编码读取
content = read_file_auto_encoding('utf8_file.txt')
print(f"自动读取的内容: {content}")  # 输出：自动读取的内容: 你好，世界！Hello, World! こんにちは
```

## 8. 文件和目录管理

### 8.1 文件信息获取
```python
import os
import time

# 创建测试文件
with open('test_info.txt', 'w') as f:
    f.write("这是一个测试文件")

# 获取文件信息
file_path = 'test_info.txt'

if os.path.exists(file_path):
    # 文件大小
    size = os.path.getsize(file_path)
    print(f"文件大小: {size} 字节")  # 输出：文件大小: 21 字节
    
    # 修改时间
    mtime = os.path.getmtime(file_path)
    print(f"修改时间: {time.ctime(mtime)}")  # 输出：修改时间: Thu Oct  5 12:34:56 2023 (具体时间)
    
    # 创建时间（Windows）
    try:
        ctime = os.path.getctime(file_path)
        print(f"创建时间: {time.ctime(ctime)}")  # 输出：创建时间: Thu Oct  5 12:34:56 2023
    except AttributeError:
        print("创建时间不可用")
    
    # 访问时间
    atime = os.path.getatime(file_path)
    print(f"访问时间: {time.ctime(atime)}")  # 输出：访问时间: Thu Oct  5 12:34:56 2023
    
    # 文件权限
    mode = os.stat(file_path).st_mode
    print(f"文件权限: {oct(mode)}")  # 输出：文件权限: 0o100644
else:
    print("文件不存在")
```

### 8.2 文件和目录操作
```python
import os
import shutil

# 创建测试目录和文件
os.makedirs('test_dir', exist_ok=True)
with open('test_dir/file1.txt', 'w') as f:
    f.write("文件1内容")
with open('test_dir/file2.txt', 'w') as f:
    f.write("文件2内容")

# 列出目录内容
print("目录内容:")
for item in os.listdir('test_dir'):
    print(f"  {item}")
# 输出：
# 目录内容:
#   file1.txt
#   file2.txt

# 递归列出所有文件
print("\n递归目录内容:")
for root, dirs, files in os.walk('test_dir'):
    for file in files:
        full_path = os.path.join(root, file)
        print(f"  {full_path}")
# 输出：
# 递归目录内容:
#   test_dir/file1.txt
#   test_dir/file2.txt

# 文件重命名
os.rename('test_dir/file1.txt', 'test_dir/renamed_file.txt')
print("文件重命名完成")  # 输出：文件重命名完成

# 复制文件
shutil.copy2('test_dir/renamed_file.txt', 'test_dir/copied_file.txt')
print("文件复制完成")  # 输出：文件复制完成

# 删除文件
os.remove('test_dir/copied_file.txt')
print("文件删除完成")  # 输出：文件删除完成

# 删除目录
shutil.rmtree('test_dir')
print("目录删除完成")  # 输出：目录删除完成
```

## 9. 上下文管理器和with语句

### 9.1 自定义上下文管理器
```python
class FileManager:
    """自定义文件管理器"""
    
    def __init__(self, filename, mode):
        self.filename = filename
        self.mode = mode
        self.file = None
    
    def __enter__(self):
        print(f"打开文件: {self.filename}")
        self.file = open(self.filename, self.mode)
        return self.file
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        print(f"关闭文件: {self.filename}")
        if self.file:
            self.file.close()
        # 如果返回True，异常会被抑制
        return False

# 使用自定义上下文管理器
with FileManager('custom_context.txt', 'w') as file:
    file.write("使用自定义上下文管理器\n")
    file.write("文件会自动关闭\n")
# 输出：
# 打开文件: custom_context.txt
# 关闭文件: custom_context.txt

print("自定义上下文管理器使用完成")  # 输出：自定义上下文管理器使用完成
```

### 9.2 上下文管理器的高级用法
```python
from contextlib import contextmanager

@contextmanager
def temporary_file_change(filename, temp_content):
    """临时修改文件内容的上下文管理器"""
    # 备份原内容
    if os.path.exists(filename):
        with open(filename, 'r') as f:
            original_content = f.read()
    else:
        original_content = None
    
    try:
        # 写入临时内容
        with open(filename, 'w') as f:
            f.write(temp_content)
        print(f"临时修改文件: {filename}")
        yield  # 在这里执行用户代码
    finally:
        # 恢复原内容
        if original_content is not None:
            with open(filename, 'w') as f:
                f.write(original_content)
            print(f"恢复文件: {filename}")
        else:
            os.remove(filename)
            print(f"删除临时文件: {filename}")

# 使用上下文管理器
with temporary_file_change('temp_test.txt', '临时内容'):
    # 在这里文件内容是'临时内容'
    with open('temp_test.txt', 'r') as f:
        content = f.read()
        print(f"临时文件内容: {content}")  # 输出：临时文件内容: 临时内容
# 输出：
# 临时修改文件: temp_test.txt
# 临时文件内容: 临时内容
# 恢复文件: temp_test.txt
```

## 10. 常见文件格式处理

### 10.1 CSV文件处理
```python
import csv

# 写入CSV文件
data = [
    ['姓名', '年龄', '城市'],
    ['张三', '25', '北京'],
    ['李四', '30', '上海'],
    ['王五', '28', '广州']
]

with open('data.csv', 'w', newline='', encoding='utf-8') as file:
    writer = csv.writer(file)
    writer.writerows(data)

print("CSV文件写入完成")  # 输出：CSV文件写入完成

# 读取CSV文件
print("读取CSV文件:")
with open('data.csv', 'r', encoding='utf-8') as file:
    reader = csv.reader(file)
    for row in reader:
        print(f"  {row}")
# 输出：
# 读取CSV文件:
#   ['姓名', '年龄', '城市']
#   ['张三', '25', '北京']
#   ['李四', '30', '上海']
#   ['王五', '28', '广州']

# 使用字典方式读写CSV
data_dict = [
    {'name': '张三', 'age': 25, 'city': '北京'},
    {'name': '李四', 'age': 30, 'city': '上海'},
    {'name': '王五', 'age': 28, 'city': '广州'}
]

with open('data_dict.csv', 'w', newline='', encoding='utf-8') as file:
    fieldnames = ['name', 'age', 'city']
    writer = csv.DictWriter(file, fieldnames=fieldnames)
    writer.writeheader()
    writer.writerows(data_dict)

print("字典CSV写入完成")  # 输出：字典CSV写入完成
```

### 10.2 JSON文件处理
```python
import json

# 写入JSON文件
data = {
    "users": [
        {"id": 1, "name": "张三", "email": "zhangsan@example.com", "active": True},
        {"id": 2, "name": "李四", "email": "lisi@example.com", "active": False},
        {"id": 3, "name": "王五", "email": "wangwu@example.com", "active": True}
    ],
    "total": 3,
    "timestamp": "2023-10-05T12:00:00Z"
}

with open('data.json', 'w', encoding='utf-8') as file:
    json.dump(data, file, ensure_ascii=False, indent=2)

print("JSON文件写入完成")  # 输出：JSON文件写入完成

# 读取JSON文件
with open('data.json', 'r', encoding='utf-8') as file:
    loaded_data = json.load(file)

print("读取的JSON数据:")
print(f"用户数量: {loaded_data['total']}")  # 输出：用户数量: 3
for user in loaded_data['users']:
    print(f"  用户: {user['name']}, 邮箱: {user['email']}, 活跃: {user['active']}")
# 输出：
#   用户: 张三, 邮箱: zhangsan@example.com, 活跃: True
#   用户: 李四, 邮箱: lisi@example.com, 活跃: False
#   用户: 王五, 邮箱: wangwu@example.com, 活跃: True
```

## 11. 易错点和难点

### 11.1 文件编码问题
```python
# 编码问题的常见错误
try:
    # 尝试用错误编码读取文件
    with open('utf8_file.txt', 'r', encoding='ascii') as file:
        content = file.read()
except UnicodeDecodeError as e:
    print(f"编码错误: {e}")  # 输出：编码错误: 'ascii' codec can't decode byte 0xe4 in position 0: ordinal not in range(128)

# 解决方案：指定正确编码或使用错误处理
try:
    with open('utf8_file.txt', 'r', encoding='utf-8') as file:
        content = file.read()
        print("正确编码读取成功")  # 输出：正确编码读取成功
except UnicodeDecodeError as e:
    print(f"仍然出错: {e}")

# 使用错误处理策略
with open('utf8_file.txt', 'r', encoding='utf-8', errors='ignore') as file:
    content = file.read()
    print("使用ignore错误处理读取完成")  # 输出：使用ignore错误处理读取完成

with open('utf8_file.txt', 'r', encoding='utf-8', errors='replace') as file:
    content = file.read()
    print("使用replace错误处理读取完成")  # 输出：使用replace错误处理读取完成
```

### 11.2 文件权限问题
```python
import os
import stat

# 创建只读文件
with open('readonly.txt', 'w') as f:
    f.write("只读文件内容")

# 设置文件为只读
os.chmod('readonly.txt', stat.S_IREAD)

try:
    # 尝试写入只读文件
    with open('readonly.txt', 'w') as f:
        f.write("新内容")
except PermissionError as e:
    print(f"权限错误: {e}")  # 输出：权限错误: [Errno 13] Permission denied: 'readonly.txt'

# 恢复写入权限
os.chmod('readonly.txt', stat.S_IWRITE)

# 现在可以正常写入
with open('readonly.txt', 'w') as f:
    f.write("新内容")
print("文件写入成功")  # 输出：文件写入成功

# 清理
os.remove('readonly.txt')
```

### 11.3 大文件处理内存问题
```python
# 错误做法：一次性读取大文件
def read_big_file_wrong(filename):
    """错误的大文件读取方法"""
    with open(filename, 'r') as file:
        return file.read()  # 可能耗尽内存

# 正确做法：分块或逐行处理
def process_big_file_correct(filename, chunk_size=8192):
    """正确的大文件处理方法"""
    processed_lines = 0
    with open(filename, 'r') as file:
        while True:
            chunk = file.read(chunk_size)
            if not chunk:
                break
            # 处理chunk
            processed_lines += chunk.count('\n')
    return processed_lines

# 创建大文件测试
with open('big_file.txt', 'w') as f:
    for i in range(10000):
        f.write(f"这是第{i}行，包含一些测试数据用于演示大文件处理\n")

# 测试处理
line_count = process_big_file_correct('big_file.txt')
print(f"处理的行数: {line_count}")  # 输出：处理的行数: 10000

# 使用生成器处理大文件
def read_big_file_generator(filename):
    """使用生成器逐行读取大文件"""
    with open(filename, 'r') as file:
        for line in file:
            yield line.strip()

print("使用生成器处理:")
for i, line in enumerate(read_big_file_generator('big_file.txt')):
    if i < 3:  # 只显示前3行
        print(f"  第{i+1}行: {line[:20]}...")
    if i >= 2:
        break
# 输出：
# 使用生成器处理:
#   第1行: 这是第0行，包含一些测...
#   第2行: 这是第1行，包含一些测...
#   第3行: 这是第2行，包含一些测...
```

## 12. 高级技巧和最佳实践

### 12.1 文件操作的最佳实践
```python
import tempfile
import os

# 使用临时文件
with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.txt') as temp_file:
    temp_filename = temp_file.name
    temp_file.write("临时文件内容\n")
    temp_file.write("第二行内容\n")
    print(f"创建临时文件: {temp_filename}")  # 输出：创建临时文件: /tmp/tmpabc123.txt

# 临时文件仍然存在（delete=False）
if os.path.exists(temp_filename):
    with open(temp_filename, 'r') as f:
        content = f.read()
        print(f"临时文件内容: {content}")  # 输出：临时文件内容: 临时文件内容\n第二行内容\n
    
    # 手动删除
    os.unlink(temp_filename)
    print("临时文件已删除")  # 输出：临时文件已删除

# 安全的文件写入（先写入临时文件，再重命名）
def safe_write(filename, content):
    """安全写入文件，避免写入过程中出错导致文件损坏"""
    temp_name = filename + '.tmp'
    
    try:
        # 先写入临时文件
        with open(temp_name, 'w', encoding='utf-8') as file:
            file.write(content)
        
        # 原子操作：重命名替换原文件
        os.replace(temp_name, filename)
        print(f"文件安全写入完成: {filename}")  # 输出：文件安全写入完成: safe_file.txt
    except Exception as e:
        # 如果出错，清理临时文件
        if os.path.exists(temp_name):
            os.unlink(temp_name)
        raise e

# 测试安全写入
safe_write('safe_file.txt', '这是安全写入的内容\n第二行内容')
```

### 12.2 文件监控和变化检测
```python
import time
import hashlib

def get_file_hash(filename):
    """计算文件哈希值"""
    hasher = hashlib.md5()
    with open(filename, 'rb') as file:
        for chunk in iter(lambda: file.read(4096), b""):
            hasher.update(chunk)
    return hasher.hexdigest()

# 创建监控文件
with open('monitored_file.txt', 'w') as f:
    f.write("初始内容")

print("开始监控文件变化...")
original_hash = get_file_hash('monitored_file.txt')
print(f"初始文件哈希: {original_hash}")  # 输出：初始文件哈希: d41d8cd98f00b204e9800998ecf8427e

# 模拟文件变化
time.sleep(1)
with open('monitored_file.txt', 'a') as f:
    f.write("新增内容\n")

# 检测变化
new_hash = get_file_hash('monitored_file.txt')
print(f"新文件哈希: {new_hash}")  # 输出：新文件哈希: 7e6d5a7a3a31c9a8a7c4c5b4c3d2e1f0a

if original_hash != new_hash:
    print("文件已发生变化!")  # 输出：文件已发生变化!
else:
    print("文件未发生变化")
```

### 12.3 高性能文件处理
```python
import mmap
import os

def process_large_file_with_mmap(filename):
    """使用内存映射处理大文件"""
    file_size = os.path.getsize(filename)
    
    with open(filename, 'r+b') as file:
        # 创建内存映射
        with mmap.mmap(file.fileno(), file_size, access=mmap.ACCESS_READ) as mm:
            # 可以直接在内存中操作文件数据
            print(f"文件大小: {len(mm)} 字节")  # 输出：文件大小: 78300 字节
            
            # 查找特定内容
            position = mm.find(b'第500行')
            if position != -1:
                # 读取找到的内容
                mm.seek(position)
                line = mm.readline().decode('utf-8')
                print(f"找到的内容: {line.strip()}")  # 输出：找到的内容: 第500行内容，包含一些测试数据用于演示分块读取功能

# 使用内存映射处理文件
process_large_file_with_mmap('large_file.txt')

# 对比性能
import time

def traditional_read(filename):
    """传统文件读取"""
    start = time.time()
    with open(filename, 'r') as file:
        content = file.read()
    return time.time() - start

def mmap_read(filename):
    """内存映射读取"""
    start = time.time()
    file_size = os.path.getsize(filename)
    with open(filename, 'r+b') as file:
        with mmap.mmap(file.fileno(), file_size, access=mmap.ACCESS_READ) as mm:
            content = mm.read()
    return time.time() - start

# 性能测试
traditional_time = traditional_read('large_file.txt')
mmap_time = mmap_read('large_file.txt')

print(f"传统读取时间: {traditional_time:.4f}秒")  # 输出：传统读取时间: 0.0010秒
print(f"内存映射时间: {mmap_time:.4f}秒")      # 输出：内存映射时间: 0.0005秒
print(f"性能提升: {traditional_time/mmap_time:.1f}倍")  # 输出：性能提升: 2.0倍
```

## 13. 总结

### 13.1 文件操作核心要点
1. **文件打开模式**：理解r、w、a、x、b等模式的区别
2. **编码处理**：正确处理文本文件的编码问题
3. **上下文管理**：使用with语句确保文件正确关闭
4. **大文件处理**：使用分块读取或生成器避免内存问题
5. **错误处理**：正确处理文件不存在、权限不足等异常情况

### 13.2 最佳实践总结
1. 始终使用with语句进行文件操作
2. 为文本文件明确指定编码
3. 处理大文件时使用迭代或分块方式
4. 使用安全的文件写入方法
5. 合理使用临时文件
6. 定期备份重要文件

### 13.3 性能优化技巧
1. 批量写入优于逐行写入
2. 对于大文件，内存映射可以提高性能
3. 使用缓冲区减少I/O操作次数
4. 合理选择文件格式（二进制 vs 文本）

掌握这些文件操作的知识和技巧，能够帮助你编写出更加健壮、高效的Python程序！