---
date: 2025-11-04
tags:
  - python
  - base
  - 控制结构
---
## 1. 条件语句 (`if`, `elif`, `else`)

### 1.1 基础条件语句

```python
# ========== 基本if语句 ==========
# 语法：if condition:
#          statement

age = 18

if age >= 18:
    print("你已经成年了！")
    print("可以参加投票。")

# ========== if-else语句 ==========
# 语法：if condition:
#          statement1
#      else:
#          statement2

temperature = 25

if temperature > 30:
    print("天气很热！")
else:
    print("天气还不错。")

# ========== if-elif-else语句 ==========
# 语法：if condition1:
#          statement1
#      elif condition2:
#          statement2
#      else:
#          statement3

score = 85

if score >= 90:
    grade = "A"
    print("优秀！")
elif score >= 80:
    grade = "B"
    print("良好！")
elif score >= 70:
    grade = "C"
    print("中等！")
elif score >= 60:
    grade = "D"
    print("及格！")
else:
    grade = "F"
    print("不及格！")

print(f"你的成绩等级是: {grade}")

# ========== 嵌套if语句 ==========
age = 20
has_id = True
has_ticket = True

if age >= 18:
    if has_id:
        if has_ticket:
            print("可以进入音乐会！")
        else:
            print("需要购买门票。")
    else:
        print("需要身份证。")
else:
    print("年龄不够，不能进入。")

# 更清晰的写法（使用and连接条件）
if age >= 18 and has_id and has_ticket:
    print("可以进入音乐会！")
elif age >= 18 and has_id and not has_ticket:
    print("需要购买门票。")
elif age >= 18 and not has_id:
    print("需要身份证。")
else:
    print("年龄不够，不能进入。")
```

### 1.2 条件表达式详解

```python
# ========== 比较运算符 ==========
a, b = 10, 20

print(f"{a} == {b}: {a == b}")  # 等于
print(f"{a} != {b}: {a != b}")  # 不等于
print(f"{a} > {b}: {a > b}")    # 大于
print(f"{a} < {b}: {a < b}")    # 小于
print(f"{a} >= {b}: {a >= b}")  # 大于等于
print(f"{a} <= {b}: {a <= b}")  # 小于等于

# ========== 逻辑运算符 ==========
x, y = True, False

print(f"x and y: {x and y}")  # 与运算
print(f"x or y: {x or y}")    # 或运算
print(f"not x: {not x}")      # 非运算

# 实际应用
age = 25
is_student = True
has_license = True

if age >= 18 and has_license:
    print("可以开车")

if age < 18 or not has_license:
    print("不能开车")

if is_student and (age < 26 or age > 60):
    print("符合学生优惠条件")

# ========== 链式比较 ==========
# Python支持数学中的链式比较
x = 15

# 传统写法
if x > 10 and x < 20:
    print("x在10到20之间")

# 链式比较写法
if 10 < x < 20:
    print("x在10到20之间")

# 多个链式比较
if 5 < x < 15 < 20:
    print("多个条件满足")

# 复杂链式比较
a, b, c = 5, 10, 15
if a < b < c:
    print("a < b < c")

# ========== 成员测试运算符 ==========
fruits = ["apple", "banana", "orange"]

# in 运算符
if "apple" in fruits:
    print("苹果在水果列表中")

if "grape" not in fruits:
    print("葡萄不在水果列表中")

# 字符串中的成员测试
sentence = "The quick brown fox"
if "quick" in sentence:
    print("句子中包含'quick'")

# 字典中的成员测试（检查键）
person = {"name": "Alice", "age": 25}
if "name" in person:
    print("字典中包含name键")

# ========== 身份运算符 ==========
# is 和 is not 用于检查两个变量是否指向同一个对象

list1 = [1, 2, 3]
list2 = [1, 2, 3]
list3 = list1

print(f"list1 is list2: {list1 is list2}")  # False（不同对象）
print(f"list1 is list3: {list1 is list3}")  # True（同一个对象）
print(f"list1 == list2: {list1 == list2}")  # True（值相等）

# 对于None，推荐使用is进行判断
value = None
if value is None:
    print("值为None")

if value is not None:
    print("值不为None")
```

### 1.3 高级条件用法

```python
# ========== 条件表达式（三元运算符） ==========
# 语法：value_if_true if condition else value_if_false

age = 20
status = "成年" if age >= 18 else "未成年"
print(f"状态: {status}")

# 嵌套条件表达式
score = 85
result = "优秀" if score >= 90 else "良好" if score >= 80 else "及格" if score >= 60 else "不及格"
print(f"结果: {result}")

# 在赋值中使用
x = 10
y = 20
max_value = x if x > y else y
print(f"最大值: {max_value}")

# ========== 短路求值 ==========
# and 和 or 运算符的短路特性

def expensive_operation():
    print("执行昂贵操作...")
    return True

# and 短路：如果第一个条件为False，第二个条件不会执行
if False and expensive_operation():
    print("这不会执行")

# or 短路：如果第一个条件为True，第二个条件不会执行
if True or expensive_operation():
    print("这不会执行昂贵操作")

# 实际应用：提供默认值
name = None
display_name = name or "匿名用户"
print(f"显示名称: {display_name}")

config = {}
timeout = config.get('timeout') or 30  # 如果timeout为None或False，使用30
print(f"超时时间: {timeout}")

# ========== 布尔值的隐式转换 ==========
# Python中以下值在条件判断中为False：
# False, None, 0, 0.0, 0j, '', [], (), {}, set(), range(0)

values_to_test = [False, None, 0, 0.0, '', [], (), {}, set(), range(0), "hello", [1], 42]

print("布尔值测试:")
for value in values_to_test:
    if value:
        print(f"  {value!r} -> True")
    else:
        print(f"  {value!r} -> False")

# 实际应用
name = ""
if name:  # 如果name非空则为True
    print(f"你好, {name}")
else:
    print("请输入姓名")

items = []
if items:  # 如果列表不为空则为True
    print(f"有 {len(items)} 个物品")
else:
    print("列表为空")

# ========== 海象运算符 (Python 3.8+) ==========
# 在表达式中进行赋值

# 传统写法
data = "Hello, World!"
n = len(data)
if n > 10:
    print(f"数据太长: {n} 字符")

# 使用海象运算符
if (n := len(data)) > 10:
    print(f"数据太长: {n} 字符")

# 在循环中使用
while (command := input("请输入命令: ")) != "quit":
    print(f"执行命令: {command}")

# 在列表推导式中使用
numbers = [1, 2, 3, 4, 5]
squares = [y for x in numbers if (y := x**2) > 10]
print(f"平方大于10的数: {squares}")
```

### 1.4 条件语句易错点

```python
# ========== 条件语句易错点 ==========

# 错误1：使用赋值运算符=而不是比较运算符==
x = 10
# if x = 5:  # 语法错误！
#     print("x等于5")

# 正确
if x == 5:
    print("x等于5")

# 错误2：忽略运算符优先级
a, b, c = True, False, True

# 错误的理解
if a or b and c:
    print("这个条件如何理解？")

# 实际上等同于
if a or (b and c):
    print("and优先级高于or")

# 明确使用括号
if (a or b) and c:
    print("这样更清晰")

# 错误3：混淆is和==
list1 = [1, 2, 3]
list2 = [1, 2, 3]

print(f"list1 == list2: {list1 == list2}")  # True（值相等）
print(f"list1 is list2: {list1 is list2}")  # False（不是同一个对象）

# 对于小整数和短字符串，Python会缓存（驻留）
a = 100
b = 100
print(f"小整数 a is b: {a is b}")  # True

c = 1000
d = 1000
print(f"大整数 c is d: {c is d}")  # False

# 错误4：在条件判断中修改列表
fruits = ["apple", "banana", "orange"]

# 危险的做法：在迭代过程中修改列表
# for fruit in fruits:
#     if fruit == "banana":
#         fruits.remove(fruit)  # 这会改变列表大小，可能导致错误

# 正确的做法
fruits = [fruit for fruit in fruits if fruit != "banana"]
print(f"删除后: {fruits}")

# 或者创建副本
fruits = ["apple", "banana", "orange"]
for fruit in fruits[:]:  # 使用切片创建副本
    if fruit == "banana":
        fruits.remove(fruit)

# 错误5：复杂的嵌套条件
# 难以阅读的嵌套
def bad_nesting(age, has_id, has_ticket, is_vip):
    if age >= 18:
        if has_id:
            if has_ticket:
                if is_vip:
                    return "VIP通道"
                else:
                    return "普通通道"
            else:
                return "需要门票"
        else:
            return "需要身份证"
    else:
        return "年龄不足"

# 改进：使用卫语句（guard clauses）
def good_nesting(age, has_id, has_ticket, is_vip):
    if age < 18:
        return "年龄不足"
    if not has_id:
        return "需要身份证"
    if not has_ticket:
        return "需要门票"
    return "VIP通道" if is_vip else "普通通道"

# 错误6：忽略浮点数精度问题
a = 0.1 + 0.2
b = 0.3

print(f"0.1 + 0.2 = {a}")
print(f"0.3 = {b}")
print(f"a == b: {a == b}")  # False！

# 正确比较浮点数的方法
tolerance = 1e-10
if abs(a - b) < tolerance:
    print("a和b在容差范围内相等")

# 或者使用math.isclose()
import math
if math.isclose(a, b):
    print("a和b近似相等")
```

## 2. 循环结构

### 2.1 for循环

```python
# ========== 基本for循环 ==========
# 语法：for variable in sequence:
#          statements

# 遍历列表
fruits = ["apple", "banana", "orange"]
for fruit in fruits:
    print(fruit)

# 遍历字符串
for char in "Python":
    print(char)

# 遍历字典
person = {"name": "Alice", "age": 25, "city": "New York"}
for key in person:
    print(f"{key}: {person[key]}")

# 直接遍历键值对
for key, value in person.items():
    print(f"{key}: {value}")

# ========== range()函数 ==========
# range(stop)
for i in range(5):  # 0, 1, 2, 3, 4
    print(i)

# range(start, stop)
for i in range(2, 6):  # 2, 3, 4, 5
    print(i)

# range(start, stop, step)
for i in range(0, 10, 2):  # 0, 2, 4, 6, 8
    print(i)

# 递减
for i in range(5, 0, -1):  # 5, 4, 3, 2, 1
    print(i)

# ========== enumerate()函数 ==========
# 同时获取索引和值
fruits = ["apple", "banana", "orange"]

for index, fruit in enumerate(fruits):
    print(f"索引 {index}: {fruit}")

# 指定起始索引
for index, fruit in enumerate(fruits, start=1):
    print(f"#{index}: {fruit}")

# ========== zip()函数 ==========
# 同时遍历多个序列
names = ["Alice", "Bob", "Charlie"]
ages = [25, 30, 35]
cities = ["New York", "London", "Paris"]

for name, age, city in zip(names, ages, cities):
    print(f"{name} is {age} years old and lives in {city}")

# 处理不同长度的序列
list1 = [1, 2, 3]
list2 = ['a', 'b']
for item1, item2 in zip(list1, list2):
    print(f"{item1} - {item2}")  # 只会输出2对

# 使用itertools.zip_longest处理不同长度
from itertools import zip_longest
for item1, item2 in zip_longest(list1, list2, fillvalue='N/A'):
    print(f"{item1} - {item2}")  # 输出3对，短的用N/A填充

# ========== 嵌套for循环 ==========
# 打印乘法表
for i in range(1, 4):
    for j in range(1, 4):
        print(f"{i} × {j} = {i * j}", end='  ')
    print()  # 换行

# 遍历二维列表
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

for row in matrix:
    for element in row:
        print(element, end=' ')
    print()
```

### 2.2 while循环

```python
# ========== 基本while循环 ==========
# 语法：while condition:
#          statements

count = 0
while count < 5:
    print(f"计数: {count}")
    count += 1

# ========== 无限循环与break ==========
# 无限循环（通常需要break退出）
while True:
    user_input = input("请输入内容（输入quit退出）: ")
    if user_input.lower() == 'quit':
        break
    print(f"你输入了: {user_input}")

# ========== continue语句 ==========
# 跳过当前迭代，继续下一次
count = 0
while count < 10:
    count += 1
    if count % 2 == 0:  # 跳过偶数
        continue
    print(f"奇数: {count}")

# ========== while-else结构 ==========
# 当while循环正常结束（不是通过break）时，执行else块
count = 0
while count < 5:
    print(count)
    count += 1
else:
    print("循环正常结束")

# 如果使用break退出，则不执行else块
count = 0
while count < 5:
    if count == 3:
        break
    print(count)
    count += 1
else:
    print("这不会执行")

# ========== 复杂条件的while循环 ==========
# 多个条件
import random

target = random.randint(1, 100)
guess = 0
attempts = 0

while guess != target and attempts < 10:
    guess = int(input("猜一个1-100的数字: "))
    attempts += 1
    
    if guess < target:
        print("太小了！")
    elif guess > target:
        print("太大了！")
    else:
        print(f"恭喜！你在第{attempts}次猜对了！")

if guess != target:
    print(f"游戏结束！正确答案是: {target}")
```

### 2.3 循环控制语句

```python
# ========== break语句 ==========
# 完全终止循环
for i in range(10):
    if i == 5:
        break
    print(i)  # 只打印0,1,2,3,4

# 在嵌套循环中，break只终止最内层循环
for i in range(3):
    for j in range(3):
        if j == 1:
            break  # 只终止内层循环
        print(f"i={i}, j={j}")

# ========== continue语句 ==========
# 跳过当前迭代，继续下一次
for i in range(10):
    if i % 2 == 0:
        continue  # 跳过偶数
    print(i)  # 只打印奇数

# ========== pass语句 ==========
# 占位符，什么都不做
for i in range(5):
    if i == 3:
        pass  # 什么都不做，但语法上需要一条语句
    print(i)

# 在函数或类中暂时不实现
def future_function():
    pass  # 以后实现

class FutureClass:
    pass  # 以后实现

# ========== for-else结构 ==========
# 当for循环正常结束（不是通过break）时，执行else块
numbers = [1, 3, 5, 7, 9]

for num in numbers:
    if num % 2 == 0:
        print(f"找到偶数: {num}")
        break
else:
    print("没有找到偶数")

# 实际应用：搜索算法
def find_element(seq, target):
    for index, element in enumerate(seq):
        if element == target:
            print(f"找到目标 {target} 在位置 {index}")
            break
    else:
        print(f"没有找到目标 {target}")
```

### 2.4 循环高级用法

```python
# ========== 列表推导式 ==========
# 基本列表推导式
squares = [x**2 for x in range(10)]
print(f"平方数: {squares}")

# 带条件的列表推导式
even_squares = [x**2 for x in range(10) if x % 2 == 0]
print(f"偶数平方: {even_squares}")

# 嵌套列表推导式
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
flattened = [num for row in matrix for num in row]
print(f"扁平化: {flattened}")

# ========== 字典推导式 ==========
squares_dict = {x: x**2 for x in range(5)}
print(f"平方字典: {squares_dict}")

# 交换键值对
inverted = {v: k for k, v in squares_dict.items()}
print(f"反转字典: {inverted}")

# ========== 集合推导式 ==========
unique_chars = {char for char in "hello world"}
print(f"唯一字符: {unique_chars}")

# ========== 生成器表达式 ==========
# 惰性求值，节省内存
large_range = range(1000000)
squares_gen = (x**2 for x in large_range)

# 只在需要时计算
for i, square in enumerate(squares_gen):
    if i >= 5:
        break
    print(square)

# ========== itertools模块 ==========
import itertools

# 无限迭代器
counter = itertools.count(start=10, step=2)
for i in range(5):
    print(next(counter))

# 循环迭代
cycler = itertools.cycle("ABC")
for i in range(6):
    print(next(cycler))

# 排列组合
letters = ['A', 'B', 'C']

# 排列
permutations = list(itertools.permutations(letters, 2))
print(f"排列: {permutations}")

# 组合
combinations = list(itertools.combinations(letters, 2))
print(f"组合: {combinations}")
```

### 2.5 循环易错点

```python
# ========== 循环易错点 ==========

# 错误1：在循环中修改正在迭代的序列
fruits = ["apple", "banana", "orange", "grape"]

# 危险的做法
# for fruit in fruits:
#     if fruit == "banana":
#         fruits.remove(fruit)  # 这会改变列表大小，可能导致错误

# 正确的做法1：创建副本
for fruit in fruits[:]:  # 使用切片创建副本
    if fruit == "banana":
        fruits.remove(fruit)

# 正确的做法2：使用列表推导式创建新列表
fruits = [fruit for fruit in fruits if fruit != "banana"]

# 正确的做法3：倒序遍历
fruits = ["apple", "banana", "orange", "grape"]
for i in range(len(fruits)-1, -1, -1):
    if fruits[i] == "banana":
        del fruits[i]

# 错误2：无限循环
# count = 0
# while count < 5:  # 忘记增加count
#     print(count)
# 这将导致无限循环

# 错误3：混淆break和continue
for i in range(10):
    if i == 5:
        break  # 完全终止循环
    print(i)  # 0,1,2,3,4

for i in range(10):
    if i == 5:
        continue  # 跳过当前迭代
    print(i)  # 0,1,2,3,4,6,7,8,9

# 错误4：在循环外部使用循环变量
for i in range(5):
    last_value = i

print(f"循环结束后i的值: {last_value}")  # 4

# 在Python中，循环变量在循环结束后仍然存在
# 这可能不是预期的行为

# 错误5：忽略else子句的行为
# for-else和while-else中的else只在循环正常完成时执行
for i in range(5):
    if i == 10:  # 这个条件永远不会满足
        break
else:
    print("循环正常完成")  # 会执行

for i in range(5):
    if i == 3:
        break
else:
    print("这不会执行")  # 因为循环被break中断

# 错误6：性能问题 - 在循环中重复计算
# 不好的做法
data = [1, 2, 3, 4, 5]
for i in range(len(data)):
    result = expensive_operation()  # 每次循环都计算
    print(result)

# 好的做法
data = [1, 2, 3, 4, 5]
result = expensive_operation()  # 在循环外计算一次
for i in range(len(data)):
    print(result)

# 错误7：使用range(len())而不是enumerate()
fruits = ["apple", "banana", "orange"]

# 不好的做法
for i in range(len(fruits)):
    print(f"{i}: {fruits[i]}")

# 好的做法
for i, fruit in enumerate(fruits):
    print(f"{i}: {fruit}")
```

## 3. 异常处理

### 3.1 基本异常处理

```python
# ========== try-except基本结构 ==========
# 语法：
# try:
#     可能出错的代码
# except ExceptionType:
#     异常处理代码

try:
    number = int("123")
    result = 10 / number
    print(f"结果: {result}")
except ValueError:
    print("无法转换为整数")
except ZeroDivisionError:
    print("不能除以零")

# ========== 捕获多个异常 ==========
try:
    # 可能引发多种异常的代码
    number = int("abc")
    result = 10 / number
except (ValueError, TypeError) as e:
    print(f"值错误或类型错误: {e}")
except ZeroDivisionError as e:
    print(f"除零错误: {e}")

# ========== 捕获所有异常 ==========
try:
    # 可能出错的代码
    result = 10 / 0
except Exception as e:  # 捕获所有异常
    print(f"发生错误: {e}")

# 但不推荐这样做，应该具体指定要捕获的异常类型

# ========== else子句 ==========
# 当没有异常发生时执行
try:
    number = int("123")
except ValueError:
    print("转换失败")
else:
    print(f"转换成功: {number}")

# ========== finally子句 ==========
# 无论是否发生异常都会执行
try:
    file = open("example.txt", "r")
    content = file.read()
except FileNotFoundError:
    print("文件不存在")
finally:
    print("执行清理操作")
    # 通常用于释放资源，如关闭文件
    if 'file' in locals():
        file.close()
```

### 3.2 高级异常处理

```python
# ========== 自定义异常 ==========
class MyCustomError(Exception):
    """自定义异常类"""
    def __init__(self, message, code=None):
        super().__init__(message)
        self.code = code
    
    def __str__(self):
        if self.code:
            return f"[错误代码 {self.code}] {super().__str__()}"
        return super().__str__()

def validate_age(age):
    if age < 0:
        raise MyCustomError("年龄不能为负数", code="AGE_NEGATIVE")
    if age > 150:
        raise MyCustomError("年龄不能超过150岁", code="AGE_TOO_HIGH")
    return age

try:
    validate_age(200)
except MyCustomError as e:
    print(f"自定义错误: {e}")
    print(f"错误代码: {e.code}")

# ========== 异常链 ==========
# 在捕获异常后抛出另一个异常，保留原始异常信息
try:
    try:
        number = int("abc")
    except ValueError as e:
        raise RuntimeError("转换失败") from e
except RuntimeError as e:
    print(f"捕获到运行时错误: {e}")
    print(f"原始错误: {e.__cause__}")

# ========== 警告 ==========
import warnings

def deprecated_function():
    warnings.warn(
        "此函数已过时，请使用new_function",
        DeprecationWarning,
        stacklevel=2
    )
    return "旧功能"

# 调用过时函数
deprecated_function()

# ========== 上下文管理器与with语句 ==========
# 自动资源管理
try:
    with open("example.txt", "r") as file:
        content = file.read()
        print(content)
except FileNotFoundError:
    print("文件不存在")

# 自定义上下文管理器
class DatabaseConnection:
    def __enter__(self):
        print("连接数据库")
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        print("关闭数据库连接")
        if exc_type:
            print(f"发生错误: {exc_val}")
        return False  # 不抑制异常
    
    def query(self, sql):
        print(f"执行查询: {sql}")
        return "查询结果"

with DatabaseConnection() as db:
    result = db.query("SELECT * FROM users")
    print(result)
```

### 3.3 异常处理易错点

```python
# ========== 异常处理易错点 ==========

# 错误1：过于宽泛的异常捕获
# 不推荐：捕获所有异常
try:
    # 代码
    pass
except:  # 不指定异常类型，会捕获所有异常，包括KeyboardInterrupt等
    print("发生错误")

# 推荐：具体指定要捕获的异常
try:
    # 代码
    pass
except ValueError:
    print("值错误")
except FileNotFoundError:
    print("文件未找到")

# 错误2：静默忽略异常
try:
    number = int("abc")
except ValueError:
    pass  # 静默忽略，不推荐

# 如果确实需要忽略，至少记录日志
import logging

try:
    number = int("abc")
except ValueError:
    logging.info("忽略转换错误")  # 记录信息

# 错误3：在异常处理中引入新错误
try:
    # 一些操作
    data = {"key": "value"}
    value = data["nonexistent_key"]  # KeyError
except KeyError:
    # 处理KeyError，但这里又可能引发新的异常
    value = data["key"]  # 这行可能安全，但如果在获取data时出错，则可能没有data

# 错误4：不清理资源
file = None
try:
    file = open("example.txt", "r")
    # 一些操作
except FileNotFoundError:
    print("文件不存在")
finally:
    if file is not None:
        file.close()  # 确保文件被关闭

# 更好的方法是使用with语句

# 错误5：异常信息泄露
try:
    # 一些敏感操作
    password = "123456"  # 假设从某处获取
    result = 10 / 0
except Exception as e:
    print(f"错误: {e}")  # 可能泄露敏感信息
    # 在生产环境中，应该记录日志而不是直接打印，并且不要泄露内部细节

# 安全做法
try:
    # 敏感操作
    pass
except Exception as e:
    logging.error("操作失败")  # 记录简化的错误信息
    # 给用户友好的消息
    print("操作失败，请重试")

# 错误6：错误的异常处理顺序
try:
    # 代码
    pass
except Exception as e:  # 太宽泛，应该放在最后
    print("通用错误")
except ValueError as e:  # 这永远不会执行，因为Exception已经捕获了所有
    print("值错误")

# 正确顺序：从具体到一般
try:
    # 代码
    pass
except ValueError as e:
    print("值错误")
except Exception as e:
    print("通用错误")
```

## 4. 上下文管理器

### 4.1 基本使用

```python
# ========== 文件操作中的with语句 ==========
# 传统方式
file = open("example.txt", "r")
try:
    content = file.read()
finally:
    file.close()

# 使用with语句
with open("example.txt", "r") as file:
    content = file.read()
# 文件会自动关闭，即使发生异常

# ========== 多个上下文管理器 ==========
with open("input.txt", "r") as input_file, open("output.txt", "w") as output_file:
    content = input_file.read()
    output_file.write(content.upper())

# ========== 自定义上下文管理器 ==========
# 使用类实现
class Timer:
    def __enter__(self):
        import time
        self.start = time.time()
        print("开始计时...")
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        import time
        self.end = time.time()
        self.duration = self.end - self.start
        print(f"耗时: {self.duration:.2f} 秒")
        return False  # 不抑制异常

with Timer() as timer:
    import time
    time.sleep(1)  # 模拟耗时操作

print(f"实际耗时: {timer.duration:.2f} 秒")

# 使用contextlib模块
from contextlib import contextmanager

@contextmanager
def temporary_change(obj, attr, new_value):
    """临时修改对象属性"""
    original_value = getattr(obj, attr)
    setattr(obj, attr, new_value)
    try:
        yield  # 在这里执行代码
    finally:
        setattr(obj, attr, original_value)  # 恢复原值

class Config:
    debug = False

config = Config()
print(f"原debug值: {config.debug}")

with temporary_change(config, 'debug', True):
    print(f"临时debug值: {config.debug}")

print(f"恢复后debug值: {config.debug}")
```

## 5. 控制结构最佳实践

### 5.1 代码可读性

```python
# ========== 保持条件简单 ==========
# 不推荐：复杂的条件
if (user.is_authenticated and user.has_permission('edit') and 
    not user.is_banned and post.is_published):
    # 操作

# 推荐：使用变量分解复杂条件
can_edit = (user.is_authenticated and 
            user.has_permission('edit') and 
            not user.is_banned and 
            post.is_published)
if can_edit:
    # 操作

# ========== 使用卫语句减少嵌套 ==========
# 不推荐：深层嵌套
def process_data(data):
    if data is not None:
        if len(data) > 0:
            if all(isinstance(x, int) for x in data):
                # 实际处理
                return sum(data)
            else:
                return None
        else:
            return None
    else:
        return None

# 推荐：使用卫语句提前返回
def process_data(data):
    if data is None:
        return None
    if len(data) == 0:
        return None
    if not all(isinstance(x, int) for x in data):
        return None
    
    # 实际处理
    return sum(data)

# ========== 循环中的优化 ==========
# 使用列表推导式简化代码
numbers = [1, 2, 3, 4, 5]
squares = []
for x in numbers:
    squares.append(x**2)

# 简化
squares = [x**2 for x in numbers]

# 使用生成器表达式处理大数据
large_data = range(1000000)
squares_gen = (x**2 for x in large_data)  # 不立即计算，惰性求值

# ========== 使用enumerate和zip ==========
# 需要索引时使用enumerate
fruits = ['apple', 'banana', 'orange']
for i, fruit in enumerate(fruits):
    print(f"{i}: {fruit}")

# 同时遍历多个序列使用zip
names = ['Alice', 'Bob', 'Charlie']
ages = [25, 30, 35]
for name, age in zip(names, ages):
    print(f"{name} is {age} years old")
```

### 5.2 性能考虑

```python
# ========== 避免不必要的计算 ==========
# 在循环外计算不变量
numbers = [1, 2, 3, 4, 5]
threshold = 10  # 假设这是一个复杂的计算结果

# 不推荐：在循环内重复计算
for x in numbers:
    if x > threshold:  # 如果threshold在循环内不变，应该在循环外计算
        print(x)

# 推荐：在循环外计算
for x in numbers:
    if x > threshold:
        print(x)

# ========== 使用局部变量 ==========
# 在循环中使用局部变量可以提高性能
def calculate_squares(numbers):
    result = []
    append = result.append  # 局部变量
    for x in numbers:
        append(x**2)  # 比result.append(x**2)快
    return result

# ========== 选择合适的数据结构 ==========
# 成员测试在集合中比在列表中快
large_list = list(range(1000000))
large_set = set(large_list)

# 慢
if 999999 in large_list:  # O(n)
    print("在列表中")

# 快
if 999999 in large_set:   # O(1)
    print("在集合中")
```

## 总结

Python的控制结构提供了强大的流程控制能力。合理使用条件语句、循环和异常处理可以编写出清晰、健壮的代码。记住以下要点：

1. **条件语句**：使用if-elif-else结构，注意条件表达式的布尔值转换。
2. **循环**：for循环用于已知迭代次数，while循环用于条件循环。注意避免修改正在迭代的序列。
3. **异常处理**：具体指定要捕获的异常，合理使用else和finally。
4. **上下文管理器**：使用with语句自动管理资源。
5. **代码可读性**：使用卫语句减少嵌套，用变量分解复杂条件。
6. **性能**：避免不必要的计算，选择合适的数据结构。

通过掌握这些控制结构，你可以编写出更加Pythonic和高效的代码。