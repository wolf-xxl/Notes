
## 1. 数字类型 (Numeric Types)

### 1.1 整数 (int)

#### 基本用法详解
```python
# ========== 整数创建 ==========
# 十进制整数
decimal_int = 123
negative_int = -456
zero = 0

# 不同进制表示（前缀区分）
binary_int = 0b1010        # 二进制，等于十进制的10
octal_int = 0o12           # 八进制，等于十进制的10
hexadecimal_int = 0xA      # 十六进制，等于十进制的10
large_hex = 0x1A3F         # 十六进制，等于十进制的6719

print(f"二进制 0b1010 = {binary_int}")      # 输出: 二进制 0b1010 = 10
print(f"八进制 0o12 = {octal_int}")         # 输出: 八进制 0o12 = 10
print(f"十六进制 0xA = {hexadecimal_int}")  # 输出: 十六进制 0xA = 10

# ========== 整数运算 ==========
a, b = 10, 3

# 基本算术运算
print(f"{a} + {b} = {a + b}")   # 13
print(f"{a} - {b} = {a - b}")   # 7
print(f"{a} * {b} = {a * b}")   # 30
print(f"{a} / {b} = {a / b}")   # 3.333... (注意：在Python 3中，除法总是返回浮点数)

# 整数除法
print(f"{a} // {b} = {a // b}") # 3 (向下取整)
print(f"-{a} // {b} = {-a // b}") # -4 (注意：向下取整，所以-10//3=-4)

# 取模运算
print(f"{a} % {b} = {a % b}")   # 1
print(f"-{a} % {b} = {-a % b}") # 2 (注意：符号与除数相同)

# 幂运算
print(f"{a} ** {b} = {a ** b}") # 1000

# ========== 位运算 ==========
x, y = 5, 3  # 5 = 0b101, 3 = 0b011

print(f"{x} & {y} = {x & y}")   # 按位与: 0b101 & 0b011 = 0b001 = 1
print(f"{x} | {y} = {x | y}")   # 按位或: 0b101 | 0b011 = 0b111 = 7
print(f"{x} ^ {y} = {x ^ y}")   # 按位异或: 0b101 ^ 0b011 = 0b110 = 6
print(f"~{x} = {~x}")           # 按位取反: ~5 = -6 (注意：二进制补码表示)
print(f"{x} << 1 = {x << 1}")   # 左移: 5 << 1 = 10 (0b101 -> 0b1010)
print(f"{x} >> 1 = {x >> 1}")   # 右移: 5 >> 1 = 2 (0b101 -> 0b10)
```

#### 高级用法详解
```python
# ========== 大整数处理 ==========
# Python支持任意大的整数，不会溢出
very_large = 10**1000  # 1000位的数字
print(f"10^1000 的位数: {len(str(very_large))}")  # 1001

# 使用下划线提高大数可读性 (Python 3.6+)
million = 1_000_000
credit_card = 1234_5678_9012_3456
bytes_value = 0b1101_0101_1010_1101

print(f"百万: {million}")                # 1000000
print(f"信用卡号: {credit_card}")        # 1234567890123456
print(f"字节值: {bytes_value}")          # 54701

# ========== 整数方法 ==========
# int.bit_length() - 获取表示该数所需的最小位数
num = 100
print(f"{num} 的位长度: {num.bit_length()}")  # 7 (因为100的二进制是1100100，7位)

# int.to_bytes() 和 int.from_bytes() - 整数和字节序列转换
number = 1024
byte_representation = number.to_bytes(2, byteorder='big')  # 2字节，大端序
print(f"{number} 的字节表示: {byte_representation}")  # b'\x04\x00'

recovered_number = int.from_bytes(byte_representation, byteorder='big')
print(f"从字节恢复的数字: {recovered_number}")  # 1024

# ========== 类型转换 ==========
# 字符串转整数
str_to_int = int("123")
str_to_int_base2 = int("1010", 2)    # 二进制字符串转整数
str_to_int_base16 = int("FF", 16)    # 十六进制字符串转整数

print(f"'123' -> {str_to_int}")              # 123
print(f"'1010'(二进制) -> {str_to_int_base2}") # 10
print(f"'FF'(十六进制) -> {str_to_int_base16}") # 255

# 浮点数转整数 (截断小数部分)
float_to_int = int(3.99)        # 3 (不是四舍五入！)
float_to_int_neg = int(-3.99)   # -3

print(f"3.99 -> {float_to_int}")      # 3
print(f"-3.99 -> {float_to_int_neg}") # -3

# 布尔值转整数
bool_to_int_true = int(True)    # 1
bool_to_int_false = int(False)  # 0
```

#### 易错点详解
```python
# ========== 常见错误 ==========

# 错误1: 字符串包含非数字字符
try:
    invalid_int = int("123.45")  # 包含小数点
except ValueError as e:
    print(f"错误: {e}")  # invalid literal for int() with base 10: '123.45'

try:
    invalid_int2 = int("123abc")  # 包含字母
except ValueError as e:
    print(f"错误: {e}")  # invalid literal for int() with base 10: '123abc'

# 正确做法：先转换为浮点数，再转整数
valid_conversion = int(float("123.45"))  # 123

# 错误2: 整数除法的向下取整行为
print(f"7 // 2 = {7 // 2}")        # 3 (正常)
print(f"-7 // 2 = {-7 // 2}")      # -4 (可能不符合直觉)

# 错误3: 大数表示时的混淆
# 不要混淆数字中的下划线和数学表示
num_with_underscores = 1_000_000  # 这是1000000
# num_with_commas = 1,000,000    # 这是元组 (1, 0, 0)，不是数字！

# 错误4: 位运算的符号处理
negative_num = -5
print(f"~5 = {~5}")                    # -6
print(f"-5 的二进制表示: {bin(negative_num)}")  # -0b101

# 错误5: 不同进制的混淆
decimal_10 = 10
binary_10 = 0b10    # 这是2，不是10！
octal_10 = 0o10     # 这是8，不是10！
hex_10 = 0x10       # 这是16，不是10！

print(f"0b10 = {binary_10}, 0o10 = {octal_10}, 0x10 = {hex_10}")
```

### 1.2 浮点数 (float)

#### 基本用法详解
```python
# ========== 浮点数创建 ==========
# 基本浮点数
pi = 3.14159
negative_float = -2.718
zero_float = 0.0

# 科学计数法
avogadro = 6.022e23        # 6.022 × 10^23
small_number = 1.602e-19   # 1.602 × 10^-19
large_negative = -1.5e-10  # -1.5 × 10^-10

print(f"阿伏伽德罗常数: {avogadro}")      # 6.022e+23
print(f"电子电荷: {small_number}")        # 1.602e-19

# ========== 浮点数运算 ==========
x, y = 2.5, 1.3

print(f"{x} + {y} = {x + y}")   # 3.8
print(f"{x} - {y} = {x - y}")   # 1.2
print(f"{x} * {y} = {x * y}")   # 3.25
print(f"{x} / {y} = {x / y}")   # 1.923076923076923

# 浮点数除法 vs 整数除法
print(f"5 / 2 = {5 / 2}")       # 2.5 (浮点数结果)
print(f"5 // 2 = {5 // 2}")     # 2 (整数除法)

# 浮点数取模
print(f"5.7 % 2.1 = {5.7 % 2.1}")  # 1.5 (近似值)

# ========== 特殊浮点数值 ==========
import math

# 无穷大
positive_inf = float('inf')
negative_inf = float('-inf')

# 非数字 (Not a Number)
nan_value = float('nan')

print(f"正无穷: {positive_inf}")      # inf
print(f"负无穷: {negative_inf}")      # -inf
print(f"非数字: {nan_value}")         # nan

# 检查特殊值
print(f"math.isinf(inf): {math.isinf(positive_inf)}")  # True
print(f"math.isnan(nan): {math.isnan(nan_value)}")     # True
```

#### 高级用法详解
```python
# ========== 浮点数精度控制 ==========
import math
import decimal
from fractions import Fraction

# 问题：浮点数精度误差
a = 0.1
b = 0.2
c = a + b
print(f"0.1 + 0.2 = {c}")                    # 0.30000000000000004
print(f"0.1 + 0.2 == 0.3: {c == 0.3}")      # False

# 解决方案1: 使用math.isclose()进行近似比较
print(f"math.isclose(0.1+0.2, 0.3): {math.isclose(0.1 + 0.2, 0.3)}")  # True

# 解决方案2: 使用decimal模块进行精确计算
d1 = decimal.Decimal('0.1')
d2 = decimal.Decimal('0.2')
d3 = d1 + d2
print(f"Decimal('0.1') + Decimal('0.2') = {d3}")  # 0.3

# 解决方案3: 使用分数
f1 = Fraction(1, 10)  # 1/10
f2 = Fraction(2, 10)  # 2/10 = 1/5
f3 = f1 + f2
print(f"Fraction(1,10) + Fraction(2,10) = {f3}")  # 3/10

# ========== 浮点数方法 ==========
num = 3.14159

# 四舍五入
print(f"round(3.14159, 2) = {round(num, 2)}")    # 3.14
print(f"round(2.675, 2) = {round(2.675, 2)}")   # 2.67 (注意：浮点数精度问题)

# 向上取整和向下取整
print(f"math.ceil(3.2) = {math.ceil(3.2)}")     # 4
print(f"math.floor(3.8) = {math.floor(3.8)}")   # 3

# 绝对值
print(f"abs(-3.14) = {abs(-3.14)}")             # 3.14

# 判断是否为整数
print(f"3.0.is_integer() = {3.0.is_integer()}") # True
print(f"3.14.is_integer() = {3.14.is_integer()}") # False

# ========== 类型转换 ==========
# 字符串转浮点数
str_to_float = float("3.14")
scientific_to_float = float("1.23e-4")  # 0.000123

# 整数转浮点数
int_to_float = float(100)

# 布尔值转浮点数
bool_to_float_true = float(True)   # 1.0
bool_to_float_false = float(False) # 0.0

print(f"'3.14' -> {str_to_float}")            # 3.14
print(f"'1.23e-4' -> {scientific_to_float}")  # 0.000123
```

#### 易错点详解
```python
# ========== 浮点数精度问题 ==========
print("=== 浮点数精度问题演示 ===")

# 经典问题：0.1 + 0.2 ≠ 0.3
result = 0.1 + 0.2
print(f"0.1 + 0.2 = {result}")                # 0.30000000000000004
print(f"0.1 + 0.2 == 0.3: {result == 0.3}")   # False

# 为什么？因为浮点数的二进制表示
print(f"0.1 的二进制表示: {0.1:.20f}")        # 0.10000000000000000555
print(f"0.2 的二进制表示: {0.2:.20f}")        # 0.20000000000000001110
print(f"0.3 的二进制表示: {0.3:.20f}")        # 0.29999999999999998890

# ========== 比较浮点数的正确方法 ==========
a = 0.1 + 0.2
b = 0.3

# 错误方法：直接比较
print(f"直接比较: {a == b}")  # False

# 正确方法1：使用math.isclose()
print(f"math.isclose(): {math.isclose(a, b)}")  # True

# 正确方法2：使用容差比较
tolerance = 1e-10
print(f"容差比较: {abs(a - b) < tolerance}")    # True

# 正确方法3：使用decimal模块
from decimal import Decimal
dec_a = Decimal('0.1') + Decimal('0.2')
dec_b = Decimal('0.3')
print(f"Decimal比较: {dec_a == dec_b}")        # True

# ========== 其他常见错误 ==========
# 错误1：除零错误
try:
    division_by_zero = 1.0 / 0.0
except ZeroDivisionError as e:
    print(f"除零错误: {e}")

# 但实际上，浮点数除零不会抛出异常，而是返回特殊值
print(f"1.0 / 0.0 = {1.0 / 0.0}")    # inf
print(f"-1.0 / 0.0 = {-1.0 / 0.0}")  # -inf
print(f"0.0 / 0.0 = {0.0 / 0.0}")    # nan

# 错误2：NaN的比较行为
nan_val = float('nan')
print(f"nan == nan: {nan_val == nan_val}")  # False (!)
print(f"math.isnan(nan): {math.isnan(nan_val)}")  # True

# 错误3：大数吃小数
large = 1e20
small = 1.0
result = large + small - large
print(f"大数吃小数: {result}")  # 0.0 (small被忽略了)
```

### 1.3 复数 (complex)

#### 基本用法详解
```python
# ========== 复数创建 ==========
# 使用字面量创建
c1 = 3 + 4j        # 实部3，虚部4
c2 = 2 - 3j        # 实部2，虚部-3
c3 = -1j           # 实部0，虚部-1
c4 = 5j            # 实部0，虚部5

# 使用complex()函数创建
c5 = complex(2, 3)    # 2 + 3j
c6 = complex(1)       # 1 + 0j
c7 = complex(0, -2)   # 0 - 2j
c8 = complex("3+4j")  # 从字符串创建

print(f"c1 = {c1}")      # (3+4j)
print(f"c5 = {c5}")      # (2+3j)
print(f"c8 = {c8}")      # (3+4j)

# ========== 复数运算 ==========
a = 2 + 3j
b = 1 - 2j

print(f"({a}) + ({b}) = {a + b}")    # (3+1j)
print(f"({a}) - ({b}) = {a - b}")    # (1+5j)
print(f"({a}) * ({b}) = {a * b}")    # (8-1j)
print(f"({a}) / ({b}) = {a / b}")    # (-0.8+1.4j)

# 共轭复数
print(f"({a}) 的共轭 = {a.conjugate()}")  # (2-3j)

# 幂运算
print(f"({a})^2 = {a**2}")           # (-5+12j)
```

#### 高级用法详解
```python
import cmath  # 复数数学模块
import math

# ========== 复数属性和方法 ==========
c = 3 + 4j

# 实部和虚部
print(f"{c}.real = {c.real}")        # 3.0
print(f"{c}.imag = {c.imag}")        # 4.0

# 共轭复数
print(f"{c}.conjugate() = {c.conjugate()}")  # (3-4j)

# ========== 复数数学函数 ==========
# 模（绝对值）
print(f"|{c}| = {abs(c)}")           # 5.0

# 相位角（弧度）
print(f"{c} 的相位角 = {cmath.phase(c):.4f} 弧度")  # 0.9273

# 极坐标表示
magnitude, phase = cmath.polar(c)
print(f"{c} 的极坐标: 模 = {magnitude}, 相位 = {phase:.4f}")

# 从极坐标创建复数
c_from_polar = cmath.rect(magnitude, phase)
print(f"从极坐标恢复: {c_from_polar}")  # (3+4j)

# ========== 其他复数运算 ==========
# 平方根
print(f"cmath.sqrt({c}) = {cmath.sqrt(c)}")  # (2+1j)

# 指数和对数
print(f"cmath.exp({c}) = {cmath.exp(c)}")    # 复杂的指数值
print(f"cmath.log({c}) = {cmath.log(c)}")    # 复杂的对数值

# 三角函数
print(f"cmath.sin({c}) = {cmath.sin(c)}")    # 复杂的正弦值
print(f"cmath.cos({c}) = {cmath.cos(c)}")    # 复杂的余弦值
```

#### 易错点详解
```python
# ========== 复数易错点 ==========

# 错误1：使用 i 而不是 j
# c = 3 + 4i  # 语法错误！
c = 3 + 4j    # 正确

# 错误2：虚部为1时的简写
c_wrong = 1j     # 正确：虚部为1
# c_wrong2 = j   # 错误：j未定义
c_wrong3 = 0 + 1j  # 正确但冗余

# 错误3：复数的比较
c1 = 3 + 4j
c2 = 3 + 4j
print(f"复数比较: {c1 == c2}")  # True (可以比较相等性)

# 但复数不支持大小比较
try:
    result = c1 < c2  # 复数没有定义顺序
except TypeError as e:
    print(f"复数大小比较错误: {e}")

# 错误4：与数学模块的混淆
c = 1 + 1j

# math模块的函数不能处理复数
try:
    math.sqrt(c)
except TypeError as e:
    print(f"math.sqrt() 错误: {e}")

# 应该使用cmath模块
print(f"cmath.sqrt({c}) = {cmath.sqrt(c)}")  # 正确

# 错误5：类型转换的注意事项
# 复数转整数或浮点数会丢失信息
c = 3 + 4j
try:
    int(c)
except TypeError as e:
    print(f"复数转整数错误: {e}")

try:
    float(c)
except TypeError as e:
    print(f"复数转浮点数错误: {e}")

# 只能获取实部或虚部
print(f"复数的实部: {c.real}")  # 3.0
print(f"复数的虚部: {c.imag}")  # 4.0
```

### 1.4 布尔值 (bool)

#### 基本用法详解
```python
# ========== 布尔值创建 ==========
is_true = True
is_false = False

print(f"True: {is_true}, 类型: {type(is_true)}")    # True, <class 'bool'>
print(f"False: {is_false}, 类型: {type(is_false)}") # False, <class 'bool'>

# ========== 布尔运算 ==========
a, b = True, False

# 逻辑与
print(f"{a} and {b} = {a and b}")    # False
print(f"{a} and {a} = {a and a}")    # True

# 逻辑或
print(f"{a} or {b} = {a or b}")      # True
print(f"{b} or {b} = {b or b}")      # False

# 逻辑非
print(f"not {a} = {not a}")          # False
print(f"not {b} = {not b}")          # True

# ========== 布尔运算的真值表 ==========
print("\n=== 布尔运算真值表 ===")
print("A     B     A and B  A or B   not A")
print("-" * 40)

for A in [False, True]:
    for B in [False, True]:
        print(f"{A:<5} {B:<5} {A and B:<8} {A or B:<7} {not A:<7}")
```

#### 高级用法详解
```python
# ========== 布尔值的本质 ==========
# 布尔值是整数子类
print(f"issubclass(bool, int): {issubclass(bool, int)}")  # True

# True 和 False 实际上是 1 和 0
print(f"True == 1: {True == 1}")        # True
print(f"False == 0: {False == 0}")      # True

# 但它们是不同的对象
print(f"True is 1: {True is 1}")        # False
print(f"False is 0: {False is 0}")      # False

# 可以在算术运算中使用
print(f"True + True = {True + True}")        # 2
print(f"True * 10 = {True * 10}")            # 10
print(f"False + 5 = {False + 5}")            # 5

# ========== 短路求值 ==========
def expensive_operation():
    print("执行昂贵操作...")
    return True

# 短路行为示例
result1 = False and expensive_operation()  # expensive_operation() 不会执行
print(f"结果1: {result1}")

result2 = True or expensive_operation()    # expensive_operation() 不会执行
print(f"结果2: {result2}")

result3 = False or expensive_operation()   # expensive_operation() 会执行
print(f"结果3: {result3}")

# ========== 布尔函数 ==========
# bool() 函数用于将任何值转换为布尔值
values_to_test = [0, 1, 0.0, 0.1, "", "hello", [], [1, 2], None]

print("\n=== 各种值的布尔转换 ===")
for value in values_to_test:
    print(f"bool({value!r:<10}) = {bool(value)}")
```

#### 类型转换和真值测试
```python
# ========== 各种类型的布尔转换规则 ==========

print("=== 数字类型的布尔转换 ===")
print(f"bool(0) = {bool(0)}")              # False
print(f"bool(1) = {bool(1)}")              # True
print(f"bool(-1) = {bool(-1)}")            # True
print(f"bool(0.0) = {bool(0.0)}")          # False
print(f"bool(0.1) = {bool(0.1)}")          # True
print(f"bool(0+0j) = {bool(0+0j)}")        # False
print(f"bool(1+0j) = {bool(1+0j)}")        # True

print("\n=== 序列类型的布尔转换 ===")
print(f"bool('') = {bool('')}")            # False
print(f"bool(' ') = {bool(' ')}")          # True
print(f"bool([]) = {bool([])}")            # False
print(f"bool([0]) = {bool([0])}")          # True
print(f"bool(()) = {bool(())}")            # False
print(f"bool((0,)) = {bool((0,))}")        # True
print(f"bool({{}}) = {bool({})}")          # False
print(f"bool({{0}}) = {bool({0})}")        # True

print("\n=== 其他类型的布尔转换 ===")
print(f"bool(None) = {bool(None)}")        # False
print(f"bool(False) = {bool(False)}")      # False
print(f"bool(True) = {bool(True)}")        # True

# ========== 在条件语句中的应用 ==========
def check_value(value):
    """演示各种值在条件语句中的行为"""
    if value:
        print(f"'{value}' 在条件判断中为 True")
    else:
        print(f"'{value}' 在条件判断中为 False")

# 测试各种值
test_values = [0, 1, "", "hello", [], [1], None, False, True]
for val in test_values:
    check_value(val)
```

#### 易错点详解
```python
# ========== 布尔值易错点 ==========

# 错误1：混淆 == 和 is
a = True
print(f"True == 1: {True == 1}")      # True (值相等)
print(f"True is 1: {True is 1}")      # False (不是同一个对象)

# 正确理解：True 和 1 值相等但身份不同
print(f"id(True): {id(True)}")
print(f"id(1): {id(1)}")

# 错误2：误用布尔运算的返回值
# 布尔运算返回的是操作数之一，不一定是True/False
result1 = 0 and "hello"    # 返回 0 (第一个假值)
result2 = "hello" and "world"  # 返回 "world" (最后一个真值)
result3 = "" or "default"  # 返回 "default" (第一个真值)

print(f"0 and 'hello' = {result1!r}")        # 0
print(f"'hello' and 'world' = {result2!r}")  # 'world'
print(f"'' or 'default' = {result3!r}")      # 'default'

# 错误3：过度复杂的布尔表达式
x = 5
y = 10

# 复杂难懂的写法
if x > 0 and x < 10 and y > 5 and y < 15:
    print("在范围内")

# 更清晰的写法
if 0 < x < 10 and 5 < y < 15:
    print("在范围内")

# 或者使用变量
x_in_range = 0 < x < 10
y_in_range = 5 < y < 15
if x_in_range and y_in_range:
    print("在范围内")

# 错误4：忽略布尔运算的短路特性
def validate_input(value):
    # 错误的顺序：可能先执行 len(value) 导致错误
    # if len(value) > 0 and value[0] == 'A': 
    
    # 正确的顺序：利用短路特性
    if value and value[0] == 'A':  # 如果value为空，不会执行value[0]
        return True
    return False

print(f"validate_input(''): {validate_input('')}")        # False
print(f"validate_input('Apple'): {validate_input('Apple')}") # True

# 错误5：混淆位运算和逻辑运算
a, b = 5, 3  # 5 = 0b101, 3 = 0b011

print(f"{a} & {b} = {a & b}")    # 按位与: 1
print(f"{a} and {b} = {a and b}") # 逻辑与: 3

print(f"{a} | {b} = {a | b}")    # 按位或: 7
print(f"{a} or {b} = {a or b}")  # 逻辑或: 5
```

## 2. 字符串 (str)

### 2.1 基本用法详解

#### 字符串创建和基本操作
```python
# ========== 字符串创建 ==========
# 单引号字符串
single_quoted = 'Hello, World!'
# 双引号字符串
double_quoted = "Hello, Python!"
# 三引号多行字符串
triple_quoted = '''这是
多行
字符串'''
triple_double = """这也是
多行字符串"""

# 空字符串
empty_str = ""
empty_str2 = ''

# 包含引号的字符串
quote_in_str1 = "I'm a programmer"
quote_in_str2 = 'He said "Hello"'
quote_in_str3 = "She said \"Hi\""

print(single_quoted)
print(double_quoted)
print(triple_quoted)
print(quote_in_str1)

# ========== 字符串索引和切片 ==========
text = "Python Programming"

# 正索引（从左到右，从0开始）
print(f"text[0] = '{text[0]}'")      # P
print(f"text[1] = '{text[1]}'")      # y
print(f"text[5] = '{text[5]}'")      # n

# 负索引（从右到左，从-1开始）
print(f"text[-1] = '{text[-1]}'")    # g
print(f"text[-2] = '{text[-2]}'")    # n
print(f"text[-6] = '{text[-6]}'")    # m

# 切片语法：[start:end:step]
print(f"text[0:6] = '{text[0:6]}'")      # Python
print(f"text[7:18] = '{text[7:18]}'")    # Programming
print(f"text[7:] = '{text[7:]}'")        # Programming
print(f"text[:6] = '{text[:6]}'")        # Python
print(f"text[::2] = '{text[::2]}'")      # Pto rgamn（步长为2）
print(f"text[::-1] = '{text[::-1]}'")    # gnimmargorP nohtyP（反转）

# ========== 字符串长度 ==========
print(f"'{text}' 的长度: {len(text)}")  # 18

# ========== 字符串拼接 ==========
str1 = "Hello"
str2 = "World"

# 使用 + 操作符
result1 = str1 + " " + str2
print(result1)  # Hello World

# 使用 * 操作符重复字符串
repeat_str = "Ha" * 3
print(repeat_str)  # HaHaHa

# 相邻字符串自动拼接（仅在字面量时）
auto_concat = "Hello" " " "World"
print(auto_concat)  # Hello World

# ========== 字符串成员检测 ==========
text = "Python Programming"
print(f"'Python' in text: {'Python' in text}")        # True
print(f"'Java' in text: {'Java' in text}")            # False
print(f"'Python' not in text: {'Python' not in text}") # False

# ========== 字符串遍历 ==========
for char in "Python":
    print(char, end=' ')  # P y t h o n
print()

# 同时获取索引和字符
for index, char in enumerate("Python"):
    print(f"索引 {index}: '{char}'")
```

#### 字符串转义序列
```python
# ========== 常见转义序列 ==========
# 换行符
newline_str = "第一行\n第二行"
print(newline_str)

# 制表符
tab_str = "姓名\t年龄\t城市\n张三\t25\t北京"
print(tab_str)

# 退格符
backspace_str = "Hello\bWorld"  # HellWorld
print(backspace_str)

# 回车符
carriage_return = "Hello\rWorld"  # World
print(carriage_return)

# 反斜杠
backslash_str = "这是一个反斜杠: \\"
print(backslash_str)

# 单引号和双引号
quotes_str = "单引号: \', 双引号: \""
print(quotes_str)

# 八进制和十六进制字符
octal_char = "\101"    # 八进制的65，即字符'A'
hex_char = "\x41"      # 十六进制的41，即字符'A'
print(f"八进制 \\101 = {octal_char}, 十六进制 \\x41 = {hex_char}")

# 原始字符串（忽略转义）
raw_str = r"C:\Users\Name\Documents\nonewline"
print(f"原始字符串: {raw_str}")  # C:\Users\Name\Documents\nonewline

# Unicode 转义
unicode_str = "\u4F60\u597D"  # 你好
print(f"Unicode 字符串: {unicode_str}")
```

### 2.2 字符串方法详解

#### 大小写转换方法
```python
# ========== 大小写转换 ==========
text = "hello World, python Programming"

# 转换为大写
upper_text = text.upper()
print(f"upper(): {upper_text}")  # HELLO WORLD, PYTHON PROGRAMMING

# 转换为小写
lower_text = text.lower()
print(f"lower(): {lower_text}")  # hello world, python programming

# 首字母大写
capitalize_text = text.capitalize()
print(f"capitalize(): {capitalize_text}")  # Hello world, python programming

# 每个单词首字母大写
title_text = text.title()
print(f"title(): {title_text}")  # Hello World, Python Programming

# 大小写交换
swapcase_text = text.swapcase()
print(f"swapcase(): {swapcase_text}")  # HELLO wORLD, PYTHON pROGRAMMING

# 案例折叠（用于不区分大小写的比较）
casefold_text = text.casefold()
print(f"casefold(): {casefold_text}")  # hello world, python programming
```

#### 字符串查找和替换方法
```python
# ========== 查找方法 ==========
text = "Python programming is fun. Python is powerful."

# find() - 查找子串，返回第一次出现的索引，找不到返回-1
index1 = text.find("Python")
index2 = text.find("Python", 10)  # 从索引10开始查找
index3 = text.find("Java")
print(f"find('Python'): {index1}")      # 0
print(f"find('Python', 10): {index2}")  # 24
print(f"find('Java'): {index3}")        # -1

# rfind() - 从右边开始查找
rindex = text.rfind("Python")
print(f"rfind('Python'): {rindex}")     # 24

# index() - 类似find()，但找不到时抛出ValueError
try:
    index4 = text.index("Python")
    index5 = text.index("Java")  # 这会抛出异常
except ValueError as e:
    print(f"index() 错误: {e}")

# count() - 统计子串出现次数
count_python = text.count("Python")
count_is = text.count("is")
print(f"count('Python'): {count_python}")  # 2
print(f"count('is'): {count_is}")          # 2

# ========== 替换方法 ==========
text = "I like cats. Cats are cute."

# replace() - 替换子串
replaced1 = text.replace("cats", "dogs")
replaced2 = text.replace("Cats", "Dogs")
replaced3 = text.replace("cats", "dogs", 1)  # 只替换第一次出现
print(f"replace('cats', 'dogs'): {replaced1}")  # I like dogs. Dogs are cute.
print(f"replace('Cats', 'Dogs'): {replaced2}")  # I like cats. Dogs are cute.
print(f"replace('cats', 'dogs', 1): {replaced3}")  # I like dogs. Cats are cute.

# 翻译表替换
translation_table = str.maketrans("aeiou", "12345")
translated_text = "hello world".translate(translation_table)
print(f"translate(): {translated_text}")  # h2ll4 w4rld

# 删除特定字符
remove_table = str.maketrans('', '', 'aeiou')  # 删除所有元音
removed_text = "hello world".translate(remove_table)
print(f"删除元音: {removed_text}")  # hll wrld
```

#### 字符串分割和连接方法
```python
# ========== 分割方法 ==========
text = "apple,banana,orange,grape"

# split() - 按分隔符分割
fruits = text.split(",")
print(f"split(','): {fruits}")  # ['apple', 'banana', 'orange', 'grape']

# 限制分割次数
fruits_limited = text.split(",", 2)
print(f"split(',', 2): {fruits_limited}")  # ['apple', 'banana', 'orange,grape']

# rsplit() - 从右边开始分割
fruits_right = text.rsplit(",", 2)
print(f"rsplit(',', 2): {fruits_right}")  # ['apple,banana', 'orange', 'grape']

# splitlines() - 按行分割
multiline_text = "第一行\n第二行\n第三行"
lines = multiline_text.splitlines()
print(f"splitlines(): {lines}")  # ['第一行', '第二行', '第三行']

# partition() - 分割为三部分（分隔符前，分隔符，分隔符后）
result = "python-programming".partition("-")
print(f"partition('-'): {result}")  # ('python', '-', 'programming')

# ========== 连接方法 ==========
# join() - 用字符串连接序列元素
fruits = ['apple', 'banana', 'orange']
joined1 = ", ".join(fruits)
joined2 = " - ".join(fruits)
print(f"join(', '): {joined1}")  # apple, banana, orange
print(f"join(' - '): {joined2}")  # apple - banana - orange

# 连接各种序列
numbers = [1, 2, 3, 4, 5]
joined_numbers = "|".join(str(x) for x in numbers)
print(f"连接数字: {joined_numbers}")  # 1|2|3|4|5
```

#### 字符串修剪和填充方法
```python
# ========== 修剪方法 ==========
text = "   hello world   "
text_with_chars = "***hello***"

# strip() - 去除两端空白字符
stripped = text.strip()
print(f"strip(): '{stripped}'")  # 'hello world'

# lstrip() - 去除左端空白字符
left_stripped = text.lstrip()
print(f"lstrip(): '{left_stripped}'")  # 'hello world   '

# rstrip() - 去除右端空白字符
right_stripped = text.rstrip()
print(f"rstrip(): '{right_stripped}'")  # '   hello world'

# 去除特定字符
custom_strip = text_with_chars.strip("*")
print(f"strip('*'): '{custom_strip}'")  # 'hello'

# ========== 填充方法 ==========
text = "hello"

# center() - 居中填充
centered = text.center(20, "-")
print(f"center(20, '-'): '{centered}'")  # '-------hello--------'

# ljust() - 左对齐填充
left_just = text.ljust(15, "*")
print(f"ljust(15, '*'): '{left_just}'")  # 'hello**********'

# rjust() - 右对齐填充
right_just = text.rjust(15, "*")
print(f"rjust(15, '*'): '{right_just}'")  # '**********hello'

# zfill() - 用0填充（常用于数字）
number_str = "42"
zfilled = number_str.zfill(5)
print(f"zfill(5): '{zfilled}'")  # '00042'
```

#### 字符串判断方法
```python
# ========== 字符类型判断 ==========
text1 = "Hello123"
text2 = "HELLO"
text3 = "hello"
text4 = "12345"
text5 = "   "
text6 = "Hello World"

# 字母数字判断
print(f"'{text1}'.isalnum(): {text1.isalnum()}")  # True
print(f"'{text6}'.isalnum(): {text6.isalnum()}")  # False（包含空格）

# 字母判断
print(f"'{text2}'.isalpha(): {text2.isalpha()}")  # True
print(f"'{text1}'.isalpha(): {text1.isalpha()}")  # False

# 数字判断
print(f"'{text4}'.isdigit(): {text4.isdigit()}")  # True
print(f"'{text1}'.isdigit(): {text1.isdigit()}")  # False

# 十进制数字判断
print(f"'{text4}'.isdecimal(): {text4.isdecimal()}")  # True

# 空白字符判断
print(f"'{text5}'.isspace(): {text5.isspace()}")  # True
print(f"'{text1}'.isspace(): {text1.isspace()}")  # False

# 大小写判断
print(f"'{text2}'.isupper(): {text2.isupper()}")  # True
print(f"'{text3}'.islower(): {text3.islower()}")  # True

# 标题格式判断
title_text = "Hello World"
print(f"'{title_text}'.istitle(): {title_text.istitle()}")  # True

# ========== 开始和结束判断 ==========
text = "Hello World"

print(f"startswith('Hello'): {text.startswith('Hello')}")  # True
print(f"startswith('Hello', 6): {text.startswith('Hello', 6)}")  # False
print(f"endswith('World'): {text.endswith('World')}")  # True
print(f"endswith('World', 0, 5): {text.endswith('World', 0, 5)}")  # False
```

### 2.3 字符串格式化详解

#### 多种格式化方法
```python
# ========== % 格式化（旧式） ==========
name = "Alice"
age = 25
height = 1.65

# 基本格式化
message1 = "Name: %s, Age: %d" % (name, age)
print(message1)  # Name: Alice, Age: 25

# 浮点数格式化
message2 = "Height: %.2f meters" % height
print(message2)  # Height: 1.65 meters

# 字典格式化
data = {"name": "Bob", "age": 30}
message3 = "Name: %(name)s, Age: %(age)d" % data
print(message3)  # Name: Bob, Age: 30

# ========== str.format() 方法 ==========
# 位置参数
message4 = "Name: {}, Age: {}".format(name, age)
print(message4)  # Name: Alice, Age: 25

# 索引参数
message5 = "Age: {1}, Name: {0}".format(name, age)
print(message5)  # Age: 25, Name: Alice

# 关键字参数
message6 = "Name: {name}, Age: {age}".format(name=name, age=age)
print(message6)  # Name: Alice, Age: 25

# 格式化规范
pi = 3.1415926535
message7 = "Pi: {:.2f}".format(pi)
print(message7)  # Pi: 3.14

# 对齐和填充
message8 = "{:<10} | {:^10} | {:>10}".format("left", "center", "right")
print(message8)  # left       |  center   |     right

# ========== f-string（Python 3.6+） ==========
# 基本用法
message9 = f"Name: {name}, Age: {age}"
print(message9)  # Name: Alice, Age: 25

# 表达式计算
message10 = f"Next year: {age + 1}"
print(message10)  # Next year: 26

# 方法调用
message11 = f"Name uppercase: {name.upper()}"
print(message11)  # Name uppercase: ALICE

# 格式化数字
message12 = f"Pi: {pi:.3f}"
print(message12)  # Pi: 3.142

# 对齐和填充
message13 = f"Left: {name:<10} | Right: {name:>10}"
print(message13)  # Left: Alice      | Right:      Alice

# 千位分隔符
large_number = 1000000
message14 = f"Number: {large_number:,}"
print(message14)  # Number: 1,000,000

# 进制转换
number = 255
message15 = f"Decimal: {number}, Hex: {number:#x}, Binary: {number:b}"
print(message15)  # Decimal: 255, Hex: 0xff, Binary: 11111111
```

#### 格式化规范详解
```python
# ========== 格式规范迷你语言 ==========
number = 1234.56789

print("=== 数字格式化 ===")
print(f"默认: {number}")              # 1234.56789
print(f"两位小数: {number:.2f}")      # 1234.57
print(f"整数: {number:.0f}")          # 1235
print(f"科学计数法: {number:.2e}")    # 1.23e+03
print(f"百分比: {0.256:.1%}")         # 25.6%

print("\n=== 对齐和填充 ===")
text = "Python"
print(f"居中: |{text:^10}|")          # |  Python  |
print(f"左对齐: |{text:<10}|")        # |Python    |
print(f"右对齐: |{text:>10}|")        # |    Python|
print(f"填充: |{text:_^10}|")         # |__Python__|

print("\n=== 符号显示 ===")
positive = 42
negative = -42
print(f"正数: {positive:+}")          # +42
print(f"负数: {negative:+}")          # -42
print(f"空格: {positive: }")          #  42（正数前加空格）
print(f"负数: {negative: }")          # -42

print("\n=== 字符串截断 ===")
long_text = "This is a very long text"
print(f"截断: {long_text:.10}")       # This is a
```

### 2.4 高级用法详解

#### 字符串编码和解码
```python
# ========== 字符编码 ==========
text = "Hello, 世界！"

# 编码为字节
utf8_bytes = text.encode('utf-8')
gbk_bytes = text.encode('gbk')
print(f"UTF-8 字节: {utf8_bytes}")    # b'Hello, \xe4\xb8\x96\xe7\x95\x8c\xef\xbc\x81'
print(f"GBK 字节: {gbk_bytes}")       # b'Hello, \xca\xc0\xbd\xe7\xa3\xa1'

# 解码为字符串
decoded_utf8 = utf8_bytes.decode('utf-8')
decoded_gbk = gbk_bytes.decode('gbk')
print(f"UTF-8 解码: {decoded_utf8}")  # Hello, 世界！
print(f"GBK 解码: {decoded_gbk}")     # Hello, 世界！

# 处理编码错误
try:
    wrong_decode = utf8_bytes.decode('ascii')
except UnicodeDecodeError as e:
    print(f"解码错误: {e}")

# 使用错误处理
ignore_decode = utf8_bytes.decode('ascii', errors='ignore')
replace_decode = utf8_bytes.decode('ascii', errors='replace')
print(f"忽略错误: {ignore_decode}")    # Hello, ！
print(f"替换错误: {replace_decode}")   # Hello, ���！
```

#### 字符串性能优化
```python
# ========== 字符串连接性能比较 ==========
import timeit

# 方法1：使用 + 操作符（不推荐用于大量连接）
def concat_plus(n):
    s = ""
    for i in range(n):
        s += str(i)
    return s

# 方法2：使用列表和 join()（推荐）
def concat_join(n):
    parts = []
    for i in range(n):
        parts.append(str(i))
    return "".join(parts)

# 方法3：使用列表推导式和 join()
def concat_comprehension(n):
    return "".join(str(i) for i in range(n))

# 性能测试
n = 1000
time_plus = timeit.timeit(lambda: concat_plus(n), number=100)
time_join = timeit.timeit(lambda: concat_join(n), number=100)
time_comprehension = timeit.timeit(lambda: concat_comprehension(n), number=100)

print(f"+ 操作符: {time_plus:.4f} 秒")
print(f"列表+join: {time_join:.4f} 秒")
print(f"列表推导式+join: {time_comprehension:.4f} 秒")

# ========== 字符串驻留 ==========
# Python会对小字符串和标识符进行驻留（intern）以节省内存
a = "hello"
b = "hello"
c = "hell" + "o"
d = "".join(['h', 'e', 'l', 'l', 'o'])

print(f"a is b: {a is b}")        # True（驻留）
print(f"a is c: {a is c}")        # True（编译时优化）
print(f"a is d: {a is d}")        # False（运行时创建）

# 手动驻留
import sys
e = sys.intern(d)
print(f"a is e: {a is e}")        # True（手动驻留后）

# ========== 内存视图 ==========
# 对于大型字符串操作，可以使用内存视图避免复制
large_text = "A" * 1000000
mv = memoryview(large_text.encode('utf-8'))

# 切片操作不会复制数据
slice_view = mv[1000:2000]
print(f"内存视图切片长度: {len(slice_view)}")  # 1000
```

#### 字符串模板
```python
# ========== 字符串模板（Template） ==========
from string import Template

# 创建模板
template = Template("Hello, $name! You have $count messages.")

# 安全替换（避免KeyError）
safe_result = template.safe_substitute(name="Alice")
print(safe_result)  # Hello, Alice! You have $count messages.

# 完全替换
full_result = template.substitute(name="Bob", count=5)
print(full_result)  # Hello, Bob! You have 5 messages.

# 使用字典
data = {"name": "Charlie", "count": 10}
dict_result = template.substitute(data)
print(dict_result)  # Hello, Charlie! You have 10 messages.

# 自定义分隔符
class CustomTemplate(Template):
    delimiter = '#'

custom_tpl = CustomTemplate("Hello, #name! Value: #value")
custom_result = custom_tpl.substitute(name="David", value=42)
print(custom_result)  # Hello, David! Value: 42
```

### 2.5 易错点详解

```python
# ========== 字符串不可变性 ==========
print("=== 字符串不可变性 ===")
s = "hello"
print(f"原字符串: {s}")

# 错误：尝试修改字符串
try:
    s[0] = 'H'  # 这会抛出 TypeError
except TypeError as e:
    print(f"错误: {e}")

# 正确：创建新字符串
s_new = 'H' + s[1:]
print(f"新字符串: {s_new}")  # Hello
print(f"原字符串未改变: {s}")  # hello

# ========== 编码相关问题 ==========
print("\n=== 编码问题 ===")

# 错误：编码不匹配
text = "中文"
try:
    # 尝试用ASCII编码中文字符
    encoded = text.encode('ascii')
except UnicodeEncodeError as e:
    print(f"编码错误: {e}")

# 正确：使用合适的编码
encoded_utf8 = text.encode('utf-8')
print(f"UTF-8 编码: {encoded_utf8}")

# 错误：混合字节串和字符串
byte_data = b"hello"
str_data = "world"
try:
    # result = byte_data + str_data  # 这会抛出 TypeError
    pass
except TypeError as e:
    print(f"混合类型错误: {e}")

# 正确：统一类型
result1 = byte_data + str_data.encode('utf-8')
result2 = byte_data.decode('utf-8') + str_data
print(f"统一后结果1: {result1}")
print(f"统一后结果2: {result2}")

# ========== 格式化错误 ==========
print("\n=== 格式化错误 ===")

# 错误：格式不匹配
name = "Alice"
age = "25"  # 字符串，不是数字
try:
    # message = "Age: %d" % age  # 这会抛出 TypeError
    pass
except TypeError as e:
    print(f"格式化类型错误: {e}")

# 正确：确保类型匹配
message1 = "Age: %s" % age  # 使用 %s
message2 = "Age: %d" % int(age)  # 转换为整数
print(f"正确格式化1: {message1}")
print(f"正确格式化2: {message2}")

# ========== 字符串比较陷阱 ==========
print("\n=== 字符串比较 ===")

# 错误：使用 is 进行值比较
a = "hello"
b = "hello"
c = "hello world"[:-6]  # 动态创建的 "hello"

print(f"a == b: {a == b}")      # True（值相等）
print(f"a is b: {a is b}")      # True（由于驻留）
print(f"a == c: {a == c}")      # True（值相等）
print(f"a is c: {a is c}")      # False（可能不是同一个对象）

# 正确：总是使用 == 进行值比较

# ========== 性能陷阱 ==========
print("\n=== 性能问题 ===")

# 错误：在循环中使用 + 连接大量字符串
def bad_concat(n):
    result = ""
    for i in range(n):
        result += str(i)  # 每次循环创建新字符串
    return result

# 正确：使用列表和 join()
def good_concat(n):
    parts = []
    for i in range(n):
        parts.append(str(i))
    return "".join(parts)

# 对于非常大的n，第一种方法会非常慢

# ========== 切片边界问题 ==========
print("\n=== 切片边界 ===")

s = "Python"
print(f"字符串: '{s}'")

# 切片不会引发索引错误
print(f"s[2:100]: '{s[2:100]}'")    # 'thon'（自动截断）
print(f"s[100:200]: '{s[100:200]}'") # ''（空字符串）

# 但索引访问会引发错误
try:
    print(s[100])  # 索引越界
except IndexError as e:
    print(f"索引错误: {e}")

# ========== 字符串方法不修改原字符串 ==========
print("\n=== 方法不修改原字符串 ===")

s = "  Hello World  "
print(f"原字符串: '{s}'")

# 字符串方法返回新字符串，不修改原字符串
stripped = s.strip()
upper = s.upper()
replaced = s.replace("Hello", "Hi")

print(f"strip() 后: '{stripped}'")   # 'Hello World'
print(f"upper() 后: '{upper}'")      # '  HELLO WORLD  '
print(f"replace() 后: '{replaced}'") # '  Hi World  '
print(f"原字符串未变: '{s}'")         # '  Hello World  '
```

## 3. 列表 (list)

### 3.1 基本用法详解

#### 列表创建和基本操作
```python
# ========== 列表创建 ==========
# 空列表
empty_list = []
empty_list2 = list()

# 包含元素的列表
numbers = [1, 2, 3, 4, 5]
fruits = ["apple", "banana", "orange"]
mixed = [1, "hello", 3.14, True, [1, 2, 3]]  # 可以包含不同类型的元素

# 使用list()构造函数
from_range = list(range(5))           # [0, 1, 2, 3, 4]
from_string = list("hello")           # ['h', 'e', 'l', 'l', 'o']
from_tuple = list((1, 2, 3))          # [1, 2, 3]

print(f"numbers: {numbers}")
print(f"fruits: {fruits}")
print(f"mixed: {mixed}")
print(f"from_range: {from_range}")

# ========== 列表索引和切片 ==========
fruits = ["apple", "banana", "orange", "grape", "mango"]

# 正索引（从左到右，从0开始）
print(f"fruits[0] = {fruits[0]}")     # apple
print(f"fruits[2] = {fruits[2]}")     # orange

# 负索引（从右到左，从-1开始）
print(f"fruits[-1] = {fruits[-1]}")   # mango
print(f"fruits[-2] = {fruits[-2]}")   # grape

# 切片操作
print(f"fruits[1:4] = {fruits[1:4]}")     # ['banana', 'orange', 'grape']
print(f"fruits[:3] = {fruits[:3]}")       # ['apple', 'banana', 'orange']
print(f"fruits[2:] = {fruits[2:]}")       # ['orange', 'grape', 'mango']
print(f"fruits[::2] = {fruits[::2]}")     # ['apple', 'orange', 'mango'] (步长为2)
print(f"fruits[::-1] = {fruits[::-1]}")   # ['mango', 'grape', 'orange', 'banana', 'apple'] (反转)

# ========== 列表长度 ==========
print(f"fruits长度: {len(fruits)}")    # 5

# ========== 列表拼接 ==========
list1 = [1, 2, 3]
list2 = [4, 5, 6]

# 使用 + 操作符
combined = list1 + list2
print(f"list1 + list2 = {combined}")  # [1, 2, 3, 4, 5, 6]

# 使用 * 操作符重复
repeated = list1 * 3
print(f"list1 * 3 = {repeated}")      # [1, 2, 3, 1, 2, 3, 1, 2, 3]

# ========== 列表成员检测 ==========
print(f"'apple' in fruits: {'apple' in fruits}")    # True
print(f"'pear' in fruits: {'pear' in fruits}")      # False

# ========== 列表遍历 ==========
# 直接遍历元素
for fruit in fruits:
    print(fruit, end=' ')  # apple banana orange grape mango
print()

# 遍历索引和元素
for index, fruit in enumerate(fruits):
    print(f"索引 {index}: {fruit}")

# 使用while循环
i = 0
while i < len(fruits):
    print(fruits[i], end=' ')
    i += 1
print()
```

#### 列表元素修改
```python
# ========== 修改列表元素 ==========
numbers = [1, 2, 3, 4, 5]

# 通过索引修改
numbers[0] = 10
numbers[-1] = 50
print(f"修改后: {numbers}")  # [10, 2, 3, 4, 50]

# 通过切片修改
numbers[1:4] = [20, 30, 40]
print(f"切片修改后: {numbers}")  # [10, 20, 30, 40, 50]

# 插入元素（通过切片）
numbers[2:2] = [25, 26]  # 在索引2处插入
print(f"插入后: {numbers}")  # [10, 20, 25, 26, 30, 40, 50]

# 删除元素（通过切片）
numbers[1:3] = []  # 删除索引1和2的元素
print(f"删除后: {numbers}")  # [10, 26, 30, 40, 50]
```

### 3.2 列表方法详解

#### 添加元素方法
```python
# ========== 添加元素 ==========
fruits = ["apple", "banana"]

# append() - 在末尾添加单个元素
fruits.append("orange")
print(f"append后: {fruits}")  # ['apple', 'banana', 'orange']

# extend() - 在末尾添加多个元素（扩展列表）
fruits.extend(["grape", "mango"])
print(f"extend后: {fruits}")  # ['apple', 'banana', 'orange', 'grape', 'mango']

# insert() - 在指定位置插入元素
fruits.insert(1, "pear")  # 在索引1处插入
print(f"insert后: {fruits}")  # ['apple', 'pear', 'banana', 'orange', 'grape', 'mango']

# 使用 + 操作符（创建新列表）
new_fruits = fruits + ["pineapple", "kiwi"]
print(f"新列表: {new_fruits}")
print(f"原列表不变: {fruits}")
```

#### 删除元素方法
```python
# ========== 删除元素 ==========
fruits = ["apple", "banana", "orange", "banana", "grape"]

# remove() - 删除第一个匹配的元素
fruits.remove("banana")
print(f"remove后: {fruits}")  # ['apple', 'orange', 'banana', 'grape']

# pop() - 删除并返回指定位置的元素（默认最后一个）
popped = fruits.pop()  # 删除最后一个
print(f"pop() 返回: {popped}")  # grape
print(f"pop后: {fruits}")      # ['apple', 'orange', 'banana']

popped2 = fruits.pop(1)  # 删除索引1的元素
print(f"pop(1) 返回: {popped2}")  # orange
print(f"再次pop后: {fruits}")     # ['apple', 'banana']

# del 语句 - 按索引删除元素
del fruits[0]
print(f"del后: {fruits}")  # ['banana']

# 清空列表
fruits.clear()
print(f"clear后: {fruits}")  # []
```

#### 查找和统计方法
```python
# ========== 查找元素 ==========
numbers = [10, 20, 30, 20, 40, 50]

# index() - 返回第一个匹配元素的索引
index1 = numbers.index(20)
print(f"20的索引: {index1}")  # 1

# 指定搜索范围
index2 = numbers.index(20, 2)  # 从索引2开始搜索
print(f"从索引2开始搜索20: {index2}")  # 3

# count() - 统计元素出现次数
count_20 = numbers.count(20)
count_100 = numbers.count(100)
print(f"20出现次数: {count_20}")    # 2
print(f"100出现次数: {count_100}")  # 0
```

#### 排序和反转方法
```python
# ========== 排序和反转 ==========
numbers = [3, 1, 4, 1, 5, 9, 2, 6]

# sort() - 原地排序（修改原列表）
numbers.sort()
print(f"升序排序: {numbers}")  # [1, 1, 2, 3, 4, 5, 6, 9]

numbers.sort(reverse=True)
print(f"降序排序: {numbers}")  # [9, 6, 5, 4, 3, 2, 1, 1]

# 自定义排序
words = ["apple", "banana", "cherry", "date"]
words.sort(key=len)  # 按字符串长度排序
print(f"按长度排序: {words}")  # ['date', 'apple', 'banana', 'cherry']

# reverse() - 反转列表
numbers.reverse()
print(f"反转后: {numbers}")  # [1, 1, 2, 3, 4, 5, 6, 9]

# sorted() - 返回新排序列表（不修改原列表）
original = [3, 1, 4, 1, 5]
sorted_list = sorted(original)
print(f"原列表: {original}")      # [3, 1, 4, 1, 5]
print(f"排序后: {sorted_list}")   # [1, 1, 3, 4, 5]
```

#### 列表复制方法
```python
# ========== 列表复制 ==========
original = [1, 2, 3, [4, 5]]

# 引用赋值（不是复制！）
reference = original
reference[0] = 100
print(f"原列表: {original}")      # [100, 2, 3, [4, 5]]（被修改了！）

# 浅拷贝
original = [1, 2, 3, [4, 5]]
shallow_copy = original.copy()        # 方法1
shallow_copy2 = original[:]           # 方法2
shallow_copy3 = list(original)        # 方法3

shallow_copy[0] = 100
print(f"原列表: {original}")          # [1, 2, 3, [4, 5]]（第一层没被修改）
print(f"浅拷贝: {shallow_copy}")      # [100, 2, 3, [4, 5]]

# 但嵌套列表还是共享引用！
shallow_copy[3][0] = 400
print(f"原列表: {original}")          # [1, 2, 3, [400, 5]]（嵌套列表被修改了！）

# 深拷贝
import copy
original = [1, 2, 3, [4, 5]]
deep_copy = copy.deepcopy(original)
deep_copy[3][0] = 400
print(f"原列表: {original}")          # [1, 2, 3, [4, 5]]（完全不受影响）
print(f"深拷贝: {deep_copy}")         # [1, 2, 3, [400, 5]]
```

### 3.3 高级用法详解

#### 列表推导式
```python
# ========== 基本列表推导式 ==========
# 创建平方数列表
squares = [x**2 for x in range(10)]
print(f"平方数: {squares}")  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

# 创建偶数平方数列表
even_squares = [x**2 for x in range(10) if x % 2 == 0]
print(f"偶数平方数: {even_squares}")  # [0, 4, 16, 36, 64]

# 处理字符串
words = ["hello", "world", "python"]
lengths = [len(word) for word in words]
print(f"单词长度: {lengths}")  # [5, 5, 6]

# ========== 条件表达式 ==========
# 将负数替换为0
numbers = [-1, 2, -3, 4, -5]
non_negative = [x if x >= 0 else 0 for x in numbers]
print(f"非负数: {non_negative}")  # [0, 2, 0, 4, 0]

# 字符串处理
words = ["apple", "banana", "cherry", "date"]
processed = [word.upper() if len(word) > 5 else word.lower() for word in words]
print(f"处理后的单词: {processed}")  # ['apple', 'BANANA', 'CHERRY', 'date']

# ========== 嵌套列表推导式 ==========
# 创建二维列表
matrix = [[i * 3 + j for j in range(3)] for i in range(3)]
print(f"3x3矩阵: {matrix}")  # [[0, 1, 2], [3, 4, 5], [6, 7, 8]]

# 扁平化二维列表
flat = [num for row in matrix for num in row]
print(f"扁平化: {flat}")  # [0, 1, 2, 3, 4, 5, 6, 7, 8]

# 多重条件
pairs = [(x, y) for x in range(3) for y in range(3) if x != y]
print(f"不同值对: {pairs}")  # [(0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1)]
```

#### 列表解包
```python
# ========== 基本解包 ==========
# 简单解包
point = [10, 20]
x, y = point
print(f"x={x}, y={y}")  # x=10, y=20

# 交换变量
a, b = 1, 2
a, b = b, a
print(f"a={a}, b={b}")  # a=2, b=1

# ========== 星号解包 ==========
# 收集多余元素
first, *middle, last = [1, 2, 3, 4, 5]
print(f"first={first}")    # 1
print(f"middle={middle}")  # [2, 3, 4]
print(f"last={last}")      # 5

# 函数参数解包
def add(a, b, c):
    return a + b + c

numbers = [1, 2, 3]
result = add(*numbers)  # 相当于 add(1, 2, 3)
print(f"解包结果: {result}")  # 6

# 合并列表
list1 = [1, 2, 3]
list2 = [4, 5, 6]
merged = [*list1, *list2]
print(f"合并列表: {merged}")  # [1, 2, 3, 4, 5, 6]

# ========== 嵌套解包 ==========
nested = [1, [2, 3], 4]
a, (b, c), d = nested
print(f"a={a}, b={b}, c={c}, d={d}")  # a=1, b=2, c=3, d=4
```

#### 列表与函数式编程
```python
# ========== map函数 ==========
numbers = [1, 2, 3, 4, 5]

# 使用map应用函数
squares = list(map(lambda x: x**2, numbers))
print(f"map平方: {squares}")  # [1, 4, 9, 16, 25]

# 多个列表的map
list1 = [1, 2, 3]
list2 = [4, 5, 6]
sums = list(map(lambda x, y: x + y, list1, list2))
print(f"map求和: {sums}")  # [5, 7, 9]

# ========== filter函数 ==========
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# 过滤偶数
evens = list(filter(lambda x: x % 2 == 0, numbers))
print(f"filter偶数: {evens}")  # [2, 4, 6, 8, 10]

# 过滤非空字符串
words = ["hello", "", "world", "", "python"]
non_empty = list(filter(None, words))  # None会过滤掉假值
print(f"非空字符串: {non_empty}")  # ['hello', 'world', 'python']

# ========== reduce函数 ==========
from functools import reduce

# 累加
numbers = [1, 2, 3, 4, 5]
sum_result = reduce(lambda x, y: x + y, numbers)
print(f"reduce累加: {sum_result}")  # 15

# 累乘
product = reduce(lambda x, y: x * y, numbers)
print(f"reduce累乘: {product}")  # 120

# 找出最大值
max_value = reduce(lambda x, y: x if x > y else y, numbers)
print(f"reduce最大值: {max_value}")  # 5
```

#### 列表性能优化
```python
# ========== 列表性能比较 ==========
import timeit

# 测试不同连接方法的性能
def test_plus(n):
    """使用 + 操作符"""
    result = []
    for i in range(n):
        result = result + [i]
    return result

def test_append(n):
    """使用 append() 方法"""
    result = []
    for i in range(n):
        result.append(i)
    return result

def test_comprehension(n):
    """使用列表推导式"""
    return [i for i in range(n)]

def test_extend(n):
    """使用 extend() 方法"""
    result = []
    for i in range(n):
        result.extend([i])
    return result

# 性能测试
n = 1000
print(f"+ 操作符: {timeit.timeit(lambda: test_plus(n), number=100):.4f}秒")
print(f"append(): {timeit.timeit(lambda: test_append(n), number=100):.4f}秒")
print(f"列表推导式: {timeit.timeit(lambda: test_comprehension(n), number=100):.4f}秒")
print(f"extend(): {timeit.timeit(lambda: test_extend(n), number=100):.4f}秒")

# ========== 预分配列表空间 ==========
# 对于已知大小的列表，预分配可以提高性能
size = 1000

# 方法1：使用列表推导式（推荐）
preallocated1 = [0] * size

# 方法2：预分配然后修改
preallocated2 = [None] * size
for i in range(size):
    preallocated2[i] = i

print(f"预分配列表1: {preallocated1[:5]}...")  # [0, 0, 0, 0, 0]...
print(f"预分配列表2: {preallocated2[:5]}...")  # [0, 1, 2, 3, 4]...
```

### 3.4 易错点详解

```python
# ========== 可变性陷阱 ==========
print("=== 列表可变性 ===")

# 错误：多个引用指向同一个列表
original = [1, 2, 3]
reference = original  # 这不是复制，是引用！
reference[0] = 100
print(f"原列表: {original}")  # [100, 2, 3]（被意外修改！）

# 正确：使用拷贝
original = [1, 2, 3]
copy_list = original.copy()  # 或者 original[:]
copy_list[0] = 100
print(f"原列表: {original}")    # [1, 2, 3]（安全）
print(f"拷贝列表: {copy_list}") # [100, 2, 3]

# ========== 浅拷贝陷阱 ==========
print("\n=== 浅拷贝问题 ===")

# 错误：浅拷贝只拷贝第一层
original = [[1, 2], [3, 4]]
shallow_copy = original.copy()

# 修改第一层是安全的
shallow_copy[0] = [5, 6]
print(f"原列表: {original}")      # [[1, 2], [3, 4]]（安全）
print(f"浅拷贝: {shallow_copy}")  # [[5, 6], [3, 4]]

# 但修改嵌套对象会影响原列表！
original = [[1, 2], [3, 4]]
shallow_copy = original.copy()
shallow_copy[1][0] = 300
print(f"原列表: {original}")      # [[1, 2], [300, 4]]（被修改了！）
print(f"浅拷贝: {shallow_copy}")  # [[1, 2], [300, 4]]

# 正确：使用深拷贝
import copy
original = [[1, 2], [3, 4]]
deep_copy = copy.deepcopy(original)
deep_copy[1][0] = 300
print(f"原列表: {original}")    # [[1, 2], [3, 4]]（安全）
print(f"深拷贝: {deep_copy}")   # [[1, 2], [300, 4]]

# ========== 循环中修改列表 ==========
print("\n=== 循环中修改列表 ===")

# 错误：在遍历时删除元素
numbers = [1, 2, 3, 4, 5]
# for num in numbers:
#     if num % 2 == 0:
#         numbers.remove(num)  # 这会导致跳过元素！
# print(numbers)  # 可能得到 [1, 3, 5]，但也可能出错

# 正确方法1：创建新列表
numbers = [1, 2, 3, 4, 5]
numbers = [num for num in numbers if num % 2 != 0]
print(f"方法1结果: {numbers}")  # [1, 3, 5]

# 正确方法2：倒序遍历
numbers = [1, 2, 3, 4, 5]
for i in range(len(numbers)-1, -1, -1):
    if numbers[i] % 2 == 0:
        del numbers[i]
print(f"方法2结果: {numbers}")  # [1, 3, 5]

# 正确方法3：使用切片赋值
numbers = [1, 2, 3, 4, 5]
numbers[:] = [num for num in numbers if num % 2 != 0]
print(f"方法3结果: {numbers}")  # [1, 3, 5]

# ========== 列表作为默认参数 ==========
print("\n=== 默认参数问题 ===")

# 错误：可变对象作为默认参数
def bad_append(item, my_list=[]):
    my_list.append(item)
    return my_list

print(f"第一次调用: {bad_append(1)}")  # [1]
print(f"第二次调用: {bad_append(2)}")  # [1, 2]（默认列表被保留了！）

# 正确：使用None作为默认值
def good_append(item, my_list=None):
    if my_list is None:
        my_list = []
    my_list.append(item)
    return my_list

print(f"第一次调用: {good_append(1)}")  # [1]
print(f"第二次调用: {good_append(2)}")  # [2]（每次都创建新列表）

# ========== 性能陷阱 ==========
print("\n=== 性能问题 ===")

# 错误：在开头插入元素（时间复杂度高）
def test_insert_beginning(n):
    lst = []
    for i in range(n):
        lst.insert(0, i)  # 每次插入都要移动所有元素
    return lst

# 正确：在末尾添加（时间复杂度低）
def test_append_end(n):
    lst = []
    for i in range(n):
        lst.append(i)  # 平均时间复杂度为O(1)
    return lst

# 如果需要频繁在两端操作，使用deque
from collections import deque
def test_deque(n):
    dq = deque()
    for i in range(n):
        dq.appendleft(i)  # 在开头插入，O(1)时间复杂度
    return dq

# ========== 比较陷阱 ==========
print("\n=== 比较问题 ===")

# 列表比较是逐元素比较
list1 = [1, 2, 3]
list2 = [1, 2, 3]
list3 = [1, 2, 4]

print(f"list1 == list2: {list1 == list2}")  # True（值相等）
print(f"list1 == list3: {list1 == list3}")  # False
print(f"list1 is list2: {list1 is list2}")  # False（不是同一个对象）

# 空列表的判断
empty_list = []
print(f"空列表为False: {not empty_list}")  # True
print(f"空列表==False: {empty_list == False}")  # False（列表不是布尔值！）

# 正确判断空列表的方法
print(f"len(empty_list)==0: {len(empty_list) == 0}")  # True
print(f"empty_list == []: {empty_list == []}")        # True
```

## 4. 元组 (tuple)

### 4.1 基本用法详解

#### 元组创建和基本操作
```python
# ========== 元组创建 ==========
# 空元组
empty_tuple = ()
empty_tuple2 = tuple()

# 包含元素的元组
numbers = (1, 2, 3, 4, 5)
fruits = ("apple", "banana", "orange")
mixed = (1, "hello", 3.14, True, [1, 2, 3])  # 可以包含不同类型的元素

# 单元素元组（必须加逗号）
single_element = (1,)           # 这是元组
not_tuple = (1)                 # 这不是元组，是整数
single_string = ("hello",)      # 单字符串元组

# 使用tuple()构造函数
from_list = tuple([1, 2, 3])           # (1, 2, 3)
from_string = tuple("hello")           # ('h', 'e', 'l', 'l', 'o')
from_range = tuple(range(5))           # (0, 1, 2, 3, 4)

print(f"numbers: {numbers}")
print(f"fruits: {fruits}")
print(f"single_element: {single_element} (类型: {type(single_element)})")
print(f"not_tuple: {not_tuple} (类型: {type(not_tuple)})")

# ========== 元组索引和切片 ==========
fruits = ("apple", "banana", "orange", "grape", "mango")

# 正索引（从左到右，从0开始）
print(f"fruits[0] = {fruits[0]}")     # apple
print(f"fruits[2] = {fruits[2]}")     # orange

# 负索引（从右到左，从-1开始）
print(f"fruits[-1] = {fruits[-1]}")   # mango
print(f"fruits[-2] = {fruits[-2]}")   # grape

# 切片操作（返回新元组）
print(f"fruits[1:4] = {fruits[1:4]}")     # ('banana', 'orange', 'grape')
print(f"fruits[:3] = {fruits[:3]}")       # ('apple', 'banana', 'orange')
print(f"fruits[2:] = {fruits[2:]}")       # ('orange', 'grape', 'mango')
print(f"fruits[::2] = {fruits[::2]}")     # ('apple', 'orange', 'mango') (步长为2)
print(f"fruits[::-1] = {fruits[::-1]}")   # ('mango', 'grape', 'orange', 'banana', 'apple') (反转)

# ========== 元组长度 ==========
print(f"fruits长度: {len(fruits)}")    # 5

# ========== 元组拼接 ==========
tuple1 = (1, 2, 3)
tuple2 = (4, 5, 6)

# 使用 + 操作符
combined = tuple1 + tuple2
print(f"tuple1 + tuple2 = {combined}")  # (1, 2, 3, 4, 5, 6)

# 使用 * 操作符重复
repeated = tuple1 * 3
print(f"tuple1 * 3 = {repeated}")      # (1, 2, 3, 1, 2, 3, 1, 2, 3)

# ========== 元组成员检测 ==========
print(f"'apple' in fruits: {'apple' in fruits}")    # True
print(f"'pear' in fruits: {'pear' in fruits}")      # False

# ========== 元组遍历 ==========
# 直接遍历元素
for fruit in fruits:
    print(fruit, end=' ')  # apple banana orange grape mango
print()

# 遍历索引和元素
for index, fruit in enumerate(fruits):
    print(f"索引 {index}: {fruit}")

# 使用while循环
i = 0
while i < len(fruits):
    print(fruits[i], end=' ')
    i += 1
print()
```

#### 元组不可变性
```python
# ========== 元组不可变性 ==========
fruits = ("apple", "banana", "orange")

# 错误：尝试修改元组
try:
    fruits[0] = "pear"  # 这会抛出 TypeError
except TypeError as e:
    print(f"错误: {e}")

# 错误：尝试添加元素
try:
    fruits.append("grape")  # 元组没有append方法
except AttributeError as e:
    print(f"错误: {e}")

# 错误：尝试删除元素
try:
    del fruits[0]  # 这会抛出 TypeError
except TypeError as e:
    print(f"错误: {e}")

# 但元组中的可变对象可以修改
mixed_tuple = (1, 2, [3, 4])
print(f"原元组: {mixed_tuple}")  # (1, 2, [3, 4])

# 修改元组中的列表
mixed_tuple[2].append(5)
mixed_tuple[2].extend([6, 7])
print(f"修改后: {mixed_tuple}")  # (1, 2, [3, 4, 5, 6, 7]) 这是允许的！

# 但不能替换整个列表
try:
    mixed_tuple[2] = [7, 8]  # 错误
except TypeError as e:
    print(f"错误: {e}")
```

### 4.2 元组方法详解

#### 元组方法
```python
# ========== 元组方法 ==========
# 元组只有两个方法：count() 和 index()

numbers = (1, 2, 3, 2, 4, 2, 5)

# count() - 统计元素出现次数
count_2 = numbers.count(2)
count_7 = numbers.count(7)
print(f"2出现次数: {count_2}")  # 3
print(f"7出现次数: {count_7}")  # 0

# index() - 返回第一个匹配元素的索引
index_3 = numbers.index(3)
print(f"3的索引: {index_3}")  # 2

# 指定搜索范围
index_2_after_3 = numbers.index(2, 3)  # 从索引3开始搜索
print(f"从索引3开始搜索2: {index_2_after_3}")  # 4

# 指定搜索范围（开始和结束）
index_2_range = numbers.index(2, 1, 5)  # 在索引1到5之间搜索
print(f"在索引1-5之间搜索2: {index_2_range}")  # 1

# 找不到元素时抛出ValueError
try:
    numbers.index(7)  # 7不在元组中
except ValueError as e:
    print(f"错误: {e}")
```

#### 元组解包
```python
# ========== 元组解包 ==========
# 基本解包
point = (10, 20)
x, y = point
print(f"x={x}, y={y}")  # x=10, y=20

# 交换变量（经典用法）
a, b = 1, 2
print(f"交换前: a={a}, b={b}")
a, b = b, a  # 实际上是 (a, b) = (b, a)
print(f"交换后: a={a}, b={b}")  # a=2, b=1

# 星号解包
numbers = (1, 2, 3, 4, 5)
first, *middle, last = numbers
print(f"first={first}")    # 1
print(f"middle={middle}")  # [2, 3, 4]
print(f"last={last}")      # 5

# 多个星号解包（Python 3.10+）
# first, *middle, last = (1, 2, 3, 4, 5)

# 忽略某些元素
x, _, z = (1, 2, 3)  # 忽略第二个元素
print(f"x={x}, z={z}")  # x=1, z=3

# 忽略多个元素
first, *_, last = (1, 2, 3, 4, 5, 6, 7)
print(f"first={first}, last={last}")  # first=1, last=7

# ========== 函数返回多个值 ==========
def get_stats(numbers):
    """返回最小值、最大值和平均值"""
    return min(numbers), max(numbers), sum(numbers) / len(numbers)

min_val, max_val, avg_val = get_stats([1, 2, 3, 4, 5])
print(f"最小值: {min_val}, 最大值: {max_val}, 平均值: {avg_val}")

# 如果不关心某些返回值
_, max_val, _ = get_stats([1, 2, 3, 4, 5])
print(f"只关心最大值: {max_val}")

# ========== 嵌套解包 ==========
nested = (1, (2, 3), 4)
a, (b, c), d = nested
print(f"a={a}, b={b}, c={c}, d={d}")  # a=1, b=2, c=3, d=4

# 复杂嵌套解包
complex_nested = (1, (2, (3, 4)), 5)
x, (y, (z, w)), v = complex_nested
print(f"x={x}, y={y}, z={z}, w={w}, v={v}")  # x=1, y=2, z=3, w=4, v=5
```

### 4.3 高级用法详解

#### 命名元组
```python
# ========== 命名元组 ==========
from collections import namedtuple

# 定义命名元组类型
Point = namedtuple('Point', ['x', 'y'])
Color = namedtuple('Color', ['red', 'green', 'blue'])
Person = namedtuple('Person', ['name', 'age', 'city'])

# 创建命名元组实例
p = Point(10, 20)
c = Color(255, 0, 0)
person = Person("Alice", 25, "New York")

print(f"点: ({p.x}, {p.y})")        # 点: (10, 20)
print(f"颜色: RGB({c.red}, {c.green}, {c.blue})")  # 颜色: RGB(255, 0, 0)
print(f"人物: {person.name}, {person.age}岁, 来自{person.city}")

# 命名元组也是元组，支持所有元组操作
print(f"点x坐标: {p[0]}")           # 10 (仍然可以通过索引访问)
print(f"点y坐标: {p[1]}")           # 20

# 转换为字典
p_dict = p._asdict()
print(f"转换为字典: {p_dict}")       # {'x': 10, 'y': 20}

# 替换字段值（创建新实例）
p_new = p._replace(x=30)
print(f"原元组: {p}")               # Point(x=10, y=20)
print(f"新元组: {p_new}")           # Point(x=30, y=20)

# 通过字典创建
data = {'x': 5, 'y': 10}
p_from_dict = Point(**data)
print(f"从字典创建: {p_from_dict}")  # Point(x=5, y=10)

# 获取字段列表
print(f"字段列表: {Person._fields}")  # ('name', 'age', 'city')

# 创建默认值命名元组
PersonWithDefaults = namedtuple('PersonWithDefaults', ['name', 'age', 'city'], defaults=["Unknown", "Unknown"])
person_default = PersonWithDefaults("Bob")
print(f"默认值元组: {person_default}")  # PersonWithDefaults(name='Bob', age='Unknown', city='Unknown')
```

#### 元组与函数参数
```python
# ========== 元组与函数参数 ==========
# 使用 * 解包元组作为函数参数
def greet(name, message):
    return f"{message}, {name}!"

person = ("Alice", "Hello")
print(greet(*person))  # Hello, Alice!

# 使用 ** 解包字典作为关键字参数
def introduce(name, age, city):
    return f"我是{name}，今年{age}岁，来自{city}。"

info = {"name": "张三", "age": 25, "city": "北京"}
print(introduce(**info))  # 我是张三，今年25岁，来自北京。

# 收集位置参数和关键字参数
def flexible_function(*args, **kwargs):
    print(f"位置参数: {args} (类型: {type(args)})")
    print(f"关键字参数: {kwargs} (类型: {type(kwargs)})")
    return args, kwargs

# 调用示例
args, kwargs = flexible_function(1, 2, 3, name="Alice", age=25)
# 位置参数: (1, 2, 3) (类型: <class 'tuple'>)
# 关键字参数: {'name': 'Alice', 'age': 25} (类型: <class 'dict'>)

# 在函数调用中使用解包
def connect_to_database(host, port, username, password):
    return f"连接到 {host}:{port}，用户: {username}"

# 使用元组解包位置参数
config_args = ("localhost", 5432)
# 使用字典解包关键字参数  
config_kwargs = {"username": "admin", "password": "secret"}

result = connect_to_database(*config_args, **config_kwargs)
print(result)  # 连接到 localhost:5432，用户: admin
```

#### 元组性能优势
```python
# ========== 元组性能优势 ==========
import timeit
import sys

# 创建速度比较
def test_list_creation(n):
    return [i for i in range(n)]

def test_tuple_creation(n):
    return tuple(i for i in range(n))

n = 1000
list_time = timeit.timeit(lambda: test_list_creation(n), number=10000)
tuple_time = timeit.timeit(lambda: test_tuple_creation(n), number=10000)

print(f"列表创建时间: {list_time:.4f}秒")
print(f"元组创建时间: {tuple_time:.4f}秒")

# 遍历速度比较
test_list = [i for i in range(n)]
test_tuple = tuple(i for i in range(n))

list_iter_time = timeit.timeit(lambda: [x for x in test_list], number=10000)
tuple_iter_time = timeit.timeit(lambda: [x for x in test_tuple], number=10000)

print(f"列表遍历时间: {list_iter_time:.4f}秒")
print(f"元组遍历时间: {tuple_iter_time:.4f}秒")

# 内存占用比较
list_memory = sys.getsizeof(test_list)
tuple_memory = sys.getsizeof(test_tuple)

print(f"列表内存占用: {list_memory} 字节")
print(f"元组内存占用: {tuple_memory} 字节")

# ========== 元组作为字典键 ==========
# 元组可以作为字典的键（因为不可变）
locations = {
    (40.7128, -74.0060): "New York",
    (34.0522, -118.2437): "Los Angeles",
    (51.5074, -0.1278): "London"
}

print(f"纽约坐标: {locations[(40.7128, -74.0060)]}")  # New York

# 列表不能作为字典键（因为可变）
try:
    invalid_dict = {[1, 2]: "value"}  # 这会抛出 TypeError
except TypeError as e:
    print(f"错误: {e}")

# 包含可变元素的元组也不能作为字典键
try:
    invalid_tuple_key = ([1, 2], 3)
    invalid_dict = {invalid_tuple_key: "value"}  # 这会抛出 TypeError
except TypeError as e:
    print(f"错误: {e}")
```

### 4.4 易错点详解

```python
# ========== 元组易错点 ==========

# 错误1：忘记单元素元组的逗号
single_correct = (1,)  # 正确
single_wrong = (1)     # 错误，这是整数1

print(f"正确类型: {type(single_correct)}")  # <class 'tuple'>
print(f"错误类型: {type(single_wrong)}")    # <class 'int'>

# 字符串元组也要注意
string_correct = ("hello",)  # 正确
string_wrong = ("hello")     # 错误，这是字符串

print(f"字符串正确类型: {type(string_correct)}")  # <class 'tuple'>
print(f"字符串错误类型: {type(string_wrong)}")    # <class 'str'>

# 错误2：尝试修改元组
fruits = ("apple", "banana", "orange")
try:
    fruits[0] = "pear"  # 会抛出TypeError
except TypeError as e:
    print(f"修改错误: {e}")

# 但可以重新赋值（创建新元组）
fruits = ("pear", "banana", "orange")  # 这是允许的，创建了新元组
print(f"新元组: {fruits}")

# 错误3：元组中的可变对象陷阱
mixed = (1, 2, [3, 4])
print(f"原元组: {mixed}")  # (1, 2, [3, 4])

# 可以修改元组中的列表
mixed[2].append(5)
print(f"修改后: {mixed}")  # (1, 2, [3, 4, 5])

# 但不能替换整个列表
try:
    mixed[2] = [7, 8]  # 错误
except TypeError as e:
    print(f"替换错误: {e}")

# 错误4：元组比较的陷阱
tuple1 = (1, 2, 3)
tuple2 = (1, 2, 3)
tuple3 = (1, 2, 4)

print(f"tuple1 == tuple2: {tuple1 == tuple2}")  # True
print(f"tuple1 == tuple3: {tuple1 == tuple3}")  # False
print(f"tuple1 is tuple2: {tuple1 is tuple2}")  # False（不是同一个对象）

# 空元组的判断
empty_tuple = ()
print(f"空元组为False: {not empty_tuple}")  # True
print(f"空元组==False: {empty_tuple == False}")  # False（元组不是布尔值！）

# 正确判断空元组的方法
print(f"len(empty_tuple)==0: {len(empty_tuple) == 0}")  # True
print(f"empty_tuple == (): {empty_tuple == ()}")        # True

# 错误5：忽略元组的不可变性带来的优势
# 元组更适合作为字典的键，因为不可变
valid_dict = {(1, 2): "点坐标"}
# invalid_dict = {[1, 2]: "点坐标"}  # 错误，列表不可哈希

# 元组在函数返回值中的使用
def get_multiple_values():
    return "Alice", 25, "Engineer"  # 隐式返回元组

name, age, job = get_multiple_values()  # 解包
print(f"姓名: {name}, 年龄: {age}, 职业: {job}")

# 如果不解包，得到的是元组
result = get_multiple_values()
print(f"函数返回类型: {type(result)}")  # <class 'tuple'>
print(f"函数返回值: {result}")          # ('Alice', 25, 'Engineer')

# 错误6：误用元组方法
numbers = (1, 2, 3, 2, 4)

# 正确使用count和index
print(f"2的出现次数: {numbers.count(2)}")  # 2
print(f"3的索引位置: {numbers.index(3)}")  # 2

# 元组没有sort、append、remove等方法
try:
    numbers.sort()
except AttributeError as e:
    print(f"属性错误: {e}")

# 错误7：解包时的元素数量不匹配
try:
    a, b, c = (1, 2)  # 值太少
except ValueError as e:
    print(f"解包错误1: {e}")

try:
    a, b = (1, 2, 3)  # 值太多
except ValueError as e:
    print(f"解包错误2: {e}")

# 使用星号解包避免数量不匹配
a, *rest = (1, 2, 3, 4, 5)  # 正确，rest收集剩余元素
print(f"a={a}, rest={rest}")  # a=1, rest=[2, 3, 4, 5]

# 错误8：混淆可变和不可变行为
# 虽然元组本身不可变，但包含的可变对象可以改变
problematic = (1, [2, 3])
print(f"问题元组: {problematic}")

# 这看起来违反了元组的不可变性，但实际上没有
problematic[1].append(4)
print(f"修改后: {problematic}")  # (1, [2, 3, 4])

# 元组的引用没有改变，只是引用的对象改变了
print(f"元组ID未变: {id(problematic)}")
```

## 5. 字典 (dict)

### 5.1 基本用法详解

#### 字典创建和基本操作
```python
# ========== 字典创建 ==========
# 空字典
empty_dict = {}
empty_dict2 = dict()

# 包含键值对的字典
person = {"name": "Alice", "age": 25, "city": "New York"}
squares = {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}

# 使用dict()构造函数
from_pairs = dict([("name", "Bob"), ("age", 30), ("city", "London")])
from_kwargs = dict(name="Charlie", age=35, city="Paris")

# 使用字典推导式
squares_dict = {x: x**2 for x in range(1, 6)}

print(f"person: {person}")
print(f"squares: {squares}")
print(f"from_pairs: {from_pairs}")
print(f"from_kwargs: {from_kwargs}")
print(f"squares_dict: {squares_dict}")

# ========== 字典键的特性 ==========
# 键必须是不可变类型：数字、字符串、元组（只包含不可变元素）等
valid_keys = {
    1: "整数键",
    "hello": "字符串键",
    (1, 2): "元组键",
    3.14: "浮点数键"
}

# 无效的键（可变类型）
# invalid_dict = {[1,2]: "列表键"}  # 报错：TypeError: unhashable type: 'list'

print(f"有效键字典: {valid_keys}")

# ========== 访问字典元素 ==========
person = {"name": "Alice", "age": 25, "city": "New York"}

# 通过键访问
print(f"姓名: {person['name']}")   # Alice
print(f"年龄: {person['age']}")    # 25

# 使用get()方法访问（键不存在时返回None或默认值）
print(f"职业: {person.get('job')}")           # None
print(f"职业: {person.get('job', '无')}")     # 无

# 检查键是否存在
print(f"包含name键: {'name' in person}")     # True
print(f"包含job键: {'job' in person}")       # False

# ========== 字典长度 ==========
print(f"person字典长度: {len(person)}")  # 3

# ========== 字典遍历 ==========
# 遍历所有键
print("所有键:")
for key in person:
    print(key, end=' ')  # name age city
print()

# 遍历所有值
print("所有值:")
for value in person.values():
    print(value, end=' ')  # Alice 25 New York
print()

# 遍历所有键值对
print("所有键值对:")
for key, value in person.items():
    print(f"{key}: {value}")

# 同时获取索引和键值对（不常用）
for idx, (key, value) in enumerate(person.items()):
    print(f"索引{idx}: {key} = {value}")
```

#### 字典元素修改
```python
# ========== 添加和修改元素 ==========
person = {"name": "Alice", "age": 25}

# 添加新键值对
person["city"] = "New York"
person["job"] = "Engineer"
print(f"添加后: {person}")  # {'name': 'Alice', 'age': 25, 'city': 'New York', 'job': 'Engineer'}

# 修改现有键的值
person["age"] = 26
person["job"] = "Senior Engineer"
print(f"修改后: {person}")  # {'name': 'Alice', 'age': 26, 'city': 'New York', 'job': 'Senior Engineer'}

# 使用update()方法批量更新
person.update({"age": 27, "city": "Boston", "hobby": "Reading"})
print(f"批量更新后: {person}")  # 包含新键hobby

# ========== 删除元素 ==========
# 使用del语句删除指定键
del person["hobby"]
print(f"删除hobby后: {person}")

# 使用pop()删除并返回值
age = person.pop("age")
print(f"删除的年龄: {age}")        # 27
print(f"pop后: {person}")         # 不再包含age

# 使用popitem()删除并返回最后一个键值对（Python 3.7+保持插入顺序）
key, value = person.popitem()
print(f"删除的键值对: {key} = {value}")
print(f"popitem后: {person}")

# 清空字典
person.clear()
print(f"清空后: {person}")  # {}

# ========== 设置默认值 ==========
person = {"name": "Alice", "age": 25}

# setdefault() - 如果键不存在则设置默认值
city = person.setdefault("city", "Unknown")
job = person.setdefault("job", "Unemployed")
print(f"city: {city}")  # Unknown
print(f"job: {job}")    # Unemployed
print(f"setdefault后: {person}")  # 包含city和job

# 如果键已存在，则返回原有值，不修改
name = person.setdefault("name", "Bob")
print(f"name: {name}")  # Alice（原有值）
print(f"setdefault后: {person}")  # name未改变
```

### 5.2 字典方法详解

#### 字典方法
```python
# ========== 字典方法 ==========
person = {"name": "Alice", "age": 25, "city": "New York"}

# keys() - 返回所有键的视图
keys = person.keys()
print(f"所有键: {keys}")  # dict_keys(['name', 'age', 'city'])

# values() - 返回所有值的视图
values = person.values()
print(f"所有值: {values}")  # dict_values(['Alice', 25, 'New York'])

# items() - 返回所有键值对的视图
items = person.items()
print(f"所有键值对: {items}")  # dict_items([('name', 'Alice'), ('age', 25), ('city', 'New York')])

# 视图是动态的，会反映字典的变化
person["job"] = "Engineer"
print(f"添加后键视图: {keys}")    # 包含job
print(f"添加后值视图: {values}")  # 包含Engineer
print(f"添加后键值对视图: {items}") # 包含('job', 'Engineer')

# copy() - 浅拷贝
person_copy = person.copy()
person_copy["age"] = 30
print(f"原字典: {person}")      # age未改变
print(f"拷贝字典: {person_copy}") # age改变为30

# fromkeys() - 从序列创建字典（所有值相同）
keys_list = ["name", "age", "city"]
default_dict = dict.fromkeys(keys_list, "未知")
print(f"fromkeys创建: {default_dict}")  # {'name': '未知', 'age': '未知', 'city': '未知'}
```

#### 字典视图对象
```python
# ========== 字典视图对象 ==========
person = {"name": "Alice", "age": 25, "city": "New York"}

# 视图对象支持集合操作
keys = person.keys()
values = person.values()
items = person.items()

print(f"键视图: {keys}")
print(f"值视图: {values}")
print(f"键值对视图: {items}")

# 视图可以转换为其他类型
keys_list = list(keys)
values_tuple = tuple(values)
items_set = set(items)  # 注意：键值对必须都是可哈希的

print(f"键列表: {keys_list}")
print(f"值元组: {values_tuple}")
print(f"键值对集合: {items_set}")

# 视图支持集合操作（keys和items）
person2 = {"name": "Bob", "age": 30, "job": "Engineer"}
keys2 = person2.keys()

# 并集
union_keys = keys | keys2
print(f"键并集: {union_keys}")  # {'name', 'age', 'city', 'job'}

# 交集
intersection_keys = keys & keys2
print(f"键交集: {intersection_keys}")  # {'name', 'age'}

# 差集
difference_keys = keys - keys2
print(f"键差集: {difference_keys}")  # {'city'}

# 对称差集
symmetric_difference_keys = keys ^ keys2
print(f"键对称差集: {symmetric_difference_keys}")  # {'city', 'job'}
```

### 5.3 高级用法详解

#### 字典推导式
```python
# ========== 字典推导式 ==========
# 基本字典推导式
squares = {x: x**2 for x in range(1, 6)}
print(f"平方字典: {squares}")  # {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}

# 带条件的字典推导式
even_squares = {x: x**2 for x in range(1, 11) if x % 2 == 0}
print(f"偶数平方字典: {even_squares}")  # {2: 4, 4: 16, 6: 36, 8: 64, 10: 100}

# 处理字符串
words = ["hello", "world", "python"]
word_lengths = {word: len(word) for word in words}
print(f"单词长度字典: {word_lengths}")  # {'hello': 5, 'world': 5, 'python': 6}

# 键值交换
inverted_squares = {v: k for k, v in squares.items()}
print(f"反转平方字典: {inverted_squares}")  # {1: 1, 4: 2, 9: 3, 16: 4, 25: 5}

# 处理两个列表
keys = ["a", "b", "c"]
values = [1, 2, 3]
combined = {k: v for k, v in zip(keys, values)}
print(f"合并字典: {combined}")  # {'a': 1, 'b': 2, 'c': 3}

# 嵌套字典推导式
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
flattened = {f"({i},{j})": matrix[i][j] for i in range(3) for j in range(3)}
print(f"扁平化矩阵: {flattened}")
```

#### 字典合并
```python
# ========== 字典合并 ==========
dict1 = {"a": 1, "b": 2}
dict2 = {"b": 3, "c": 4}
dict3 = {"d": 5}

# 方法1：update()（原地修改）
dict1_copy = dict1.copy()
dict1_copy.update(dict2)
print(f"update合并: {dict1_copy}")  # {'a': 1, 'b': 3, 'c': 4}

# 方法2：字典解包（Python 3.5+）
merged = {**dict1, **dict2, **dict3}
print(f"解包合并: {merged}")  # {'a': 1, 'b': 3, 'c': 4, 'd': 5}

# 方法3：collections.ChainMap（不创建新字典，视图方式）
from collections import ChainMap
chain = ChainMap(dict1, dict2, dict3)
print(f"ChainMap合并: {dict(chain)}")  # {'a': 1, 'b': 2, 'c': 4, 'd': 5}

# 方法4：字典推导式
merged_comprehension = {k: v for d in [dict1, dict2, dict3] for k, v in d.items()}
print(f"推导式合并: {merged_comprehension}")  # {'a': 1, 'b': 3, 'c': 4, 'd': 5}

# 注意：重复键的处理顺序（后面的覆盖前面的）
conflict1 = {"a": 1, "b": 2}
conflict2 = {"b": 20, "c": 3}
conflict3 = {"b": 200, "d": 4}

result = {**conflict1, **conflict2, **conflict3}
print(f"重复键处理: {result}")  # {'a': 1, 'b': 200, 'c': 3, 'd': 4}
```

#### 特殊字典类型
```python
# ========== 特殊字典类型 ==========
from collections import OrderedDict, defaultdict, Counter

# OrderedDict - 保持插入顺序（Python 3.7+普通字典也保持顺序，但OrderedDict有额外方法）
ordered = OrderedDict()
ordered["z"] = 1
ordered["a"] = 2
ordered["c"] = 3
print(f"OrderedDict: {ordered}")  # OrderedDict([('z', 1), ('a', 2), ('c', 3)])

# 移动元素到末尾
ordered.move_to_end("z")
print(f"移动后: {ordered}")  # OrderedDict([('a', 2), ('c', 3), ('z', 1)])

# defaultdict - 带默认值的字典
word_count = defaultdict(int)  # 默认值为int()，即0
for word in ["apple", "banana", "apple", "cherry", "banana", "apple"]:
    word_count[word] += 1
print(f"单词计数: {dict(word_count)}")  # {'apple': 3, 'banana': 2, 'cherry': 1}

# 使用lambda设置默认值
default_list = defaultdict(lambda: [])
default_list["fruits"].append("apple")
default_list["fruits"].append("banana")
default_list["vegetables"].append("carrot")
print(f"默认列表字典: {dict(default_list)}")  # {'fruits': ['apple', 'banana'], 'vegetables': ['carrot']}

# Counter - 计数器
counter = Counter(["apple", "banana", "apple", "cherry", "banana", "apple"])
print(f"计数器: {counter}")  # Counter({'apple': 3, 'banana': 2, 'cherry': 1})

# 计数器操作
counter2 = Counter(apple=2, banana=1, durian=5)
combined = counter + counter2
print(f"计数器相加: {combined}")  # Counter({'apple': 5, 'banana': 3, 'durian': 5, 'cherry': 1})

# 最常见元素
print(f"最常见2个: {counter.most_common(2)}")  # [('apple', 3), ('banana', 2)]
```

### 5.4 易错点详解

```python
# ========== 字典易错点 ==========

# 错误1：访问不存在的键
person = {"name": "Alice", "age": 25}
try:
    print(person["job"])  # 键不存在，KeyError
except KeyError as e:
    print(f"KeyError: {e}")

# 正确：使用get()方法
print(f"职业: {person.get('job', '无')}")  # 无

# 错误2：在循环中修改字典
person = {"a": 1, "b": 2, "c": 3}
# 在遍历时不能添加或删除键
# for key in person:
#     if key == "b":
#         del person[key]  # RuntimeError: dictionary changed size during iteration

# 正确：先收集要修改的键
keys_to_remove = []
for key in person:
    if key == "b":
        keys_to_remove.append(key)

for key in keys_to_remove:
    del person[key]
print(f"删除后: {person}")  # {'a': 1, 'c': 3}

# 或者创建新字典
person = {"a": 1, "b": 2, "c": 3}
person = {k: v for k, v in person.items() if k != "b"}
print(f"推导式删除后: {person}")  # {'a': 1, 'c': 3}

# 错误3：混淆浅拷贝和深拷贝
original = {"a": 1, "b": [2, 3]}
shallow_copy = original.copy()
shallow_copy["b"].append(4)
print(f"原字典: {original}")  # {'a': 1, 'b': [2, 3, 4]}（被修改了！）

# 正确：使用深拷贝
import copy
original = {"a": 1, "b": [2, 3]}
deep_copy = copy.deepcopy(original)
deep_copy["b"].append(4)
print(f"原字典: {original}")    # {'a': 1, 'b': [2, 3]}（安全）
print(f"深拷贝: {deep_copy}")   # {'a': 1, 'b': [2, 3, 4]}

# 错误4：使用可变对象作为键
try:
    invalid_dict = {[1, 2]: "value"}  # 列表不可哈希
except TypeError as e:
    print(f"TypeError: {e}")

# 但元组如果包含可变对象也不行
try:
    invalid_tuple_key = ([1, 2], 3)
    invalid_dict = {invalid_tuple_key: "value"}  # 元组包含列表，不可哈希
except TypeError as e:
    print(f"TypeError: {e}")

# 正确：使用不可变对象作为键
valid_dict = {(1, 2): "元组键", "string": "字符串键", 123: "整数键"}
print(f"有效键字典: {valid_dict}")

# 错误5：字典顺序依赖（Python 3.6之前）
# 在Python 3.6之前，字典不保证顺序，现在保证了，但最好不要依赖顺序

# 错误6：默认参数的可变字典
def bad_function(my_dict={}):  # 危险！默认字典在函数定义时创建
    my_dict["count"] = my_dict.get("count", 0) + 1
    return my_dict

print(f"第一次调用: {bad_function()}")  # {'count': 1}
print(f"第二次调用: {bad_function()}")  # {'count': 2}（保留了状态！）

# 正确：使用None作为默认值
def good_function(my_dict=None):
    if my_dict is None:
        my_dict = {}
    my_dict["count"] = my_dict.get("count", 0) + 1
    return my_dict

print(f"第一次调用: {good_function()}")  # {'count': 1}
print(f"第二次调用: {good_function()}")  # {'count': 1}（每次都创建新字典）

# 错误7：视图对象在字典修改时的行为
person = {"name": "Alice", "age": 25}
keys = person.keys()
values = person.values()
items = person.items()

print(f"原始视图 - keys: {list(keys)}, values: {list(values)}")

# 修改字典
person["city"] = "New York"
print(f"修改后视图 - keys: {list(keys)}, values: {list(values)}")  # 视图动态更新

# 但视图不能直接修改
try:
    keys.add("job")  # 视图没有add方法
except AttributeError as e:
    print(f"AttributeError: {e}")

# 错误8：字典比较的陷阱
dict1 = {"a": 1, "b": 2}
dict2 = {"b": 2, "a": 1}
print(f"dict1 == dict2: {dict1 == dict2}")  # True（顺序不影响相等性）

# 但视图比较考虑顺序
keys1 = dict1.keys()
keys2 = dict2.keys()
print(f"keys1 == keys2: {keys1 == keys2}")  # True（键的集合相同）

# 在Python 3.7+中，如果插入顺序不同，视图比较可能为False
dict3 = {"b": 2, "a": 1}  # 插入顺序与dict1不同
keys3 = dict3.keys()
print(f"keys1 == keys3: {keys1 == keys3}")  # 在Python 3.7+中为False
```

# Python 数据类型超详细完整笔记（续）

## 6. 集合 (set)

### 6.1 基本用法详解

#### 集合创建和基本操作
```python
# ========== 集合创建 ==========
# 空集合（注意：不能用{}创建空集合，{}创建的是空字典）
empty_set = set()
empty_set2 = set()

# 包含元素的集合
numbers = {1, 2, 3, 4, 5}
fruits = {"apple", "banana", "orange"}
mixed = {1, "hello", 3.14, True}  # 可以包含不同类型的元素

# 使用set()构造函数
from_list = set([1, 2, 3, 2, 3])           # {1, 2, 3}（自动去重）
from_string = set("hello")                 # {'h', 'e', 'l', 'o'}（注意：只有一个'l'）
from_tuple = set((1, 2, 3, 2, 3))          # {1, 2, 3}
from_range = set(range(5))                 # {0, 1, 2, 3, 4}
from_dict_keys = set({"a": 1, "b": 2})     # {'a', 'b'}（获取字典的键）

print(f"numbers: {numbers}")
print(f"fruits: {fruits}")
print(f"from_list: {from_list}")
print(f"from_string: {from_string}")

# ========== 集合的特性 ==========
# 集合中的元素必须是不可变类型（数字、字符串、元组等）
valid_set = {1, "hello", (1, 2), 3.14}

# 无效的集合元素（可变类型）
try:
    invalid_set = {[1, 2]}  # 列表不可哈希
except TypeError as e:
    print(f"错误: {e}")

# 集合自动去重
duplicates = {1, 2, 3, 2, 1, 4, 3, 2, 1}
print(f"去重后: {duplicates}")  # {1, 2, 3, 4}

# 布尔值在集合中的行为（True=1, False=0）
bool_set = {True, 1, False, 0}
print(f"布尔值集合: {bool_set}")  # {False, True}（True和1、False和0被认为是相同的）

# ========== 集合长度 ==========
print(f"numbers长度: {len(numbers)}")  # 5

# ========== 集合成员检测 ==========
print(f"1在numbers中: {1 in numbers}")    # True
print(f"6在numbers中: {6 in numbers}")    # False
print(f"1不在numbers中: {1 not in numbers}") # False

# 成员检测的高效性（集合使用哈希表，O(1)时间复杂度）
large_set = set(range(1000000))
print(f"999999在large_set中: {999999 in large_set}")  # True（快速）

# ========== 集合遍历 ==========
# 集合是无序的，遍历顺序不确定（但Python 3.7+保持插入顺序）
for fruit in fruits:
    print(fruit, end=' ')  # 顺序可能每次运行都不同
print()

# 遍历时不能依赖顺序，但可以排序后遍历
for number in sorted(numbers):
    print(number, end=' ')  # 1 2 3 4 5
print()

# 使用enumerate（索引无意义，因为无序）
for index, fruit in enumerate(fruits):
    print(f"索引{index}: {fruit}")

# 集合推导式遍历
squares_set = {x**2 for x in numbers}
print(f"平方数集合: {squares_set}")
```

#### 集合元素修改
```python
# ========== 添加元素 ==========
fruits = {"apple", "banana"}

# add() - 添加单个元素
fruits.add("orange")
fruits.add("apple")  # 重复元素，不会添加
print(f"add后: {fruits}")  # {'apple', 'banana', 'orange'}

# update() - 添加多个元素（可接受任何可迭代对象）
fruits.update(["grape", "mango"])
fruits.update(("pineapple", "kiwi"))
fruits.update({"watermelon", "peach"})
print(f"update后: {fruits}")  # 包含所有新元素

# 使用 | 操作符（并集，创建新集合）
new_fruits = fruits | {"blueberry", "raspberry"}
print(f"并集新集合: {new_fruits}")

# ========== 删除元素 ==========
fruits = {"apple", "banana", "orange", "grape", "mango"}

# remove() - 删除指定元素，如果元素不存在则报错
fruits.remove("banana")
print(f"remove后: {fruits}")

try:
    fruits.remove("pear")  # 不存在，报错
except KeyError as e:
    print(f"remove错误: {e}")

# discard() - 删除指定元素，如果元素不存在不报错
fruits.discard("apple")
fruits.discard("pear")  # 不存在，不报错
print(f"discard后: {fruits}")

# pop() - 随机删除并返回一个元素（因为集合无序）
popped = fruits.pop()
print(f"pop的元素: {popped}")
print(f"pop后: {fruits}")

# clear() - 清空集合
fruits.clear()
print(f"clear后: {fruits}")  # set()

# ========== 集合复制 ==========
original = {1, 2, 3}
copy_set = original.copy()
copy_set.add(4)
print(f"原集合: {original}")  # {1, 2, 3}
print(f"复制集合: {copy_set}") # {1, 2, 3, 4}

# 引用赋值（不是复制！）
reference = original
reference.add(5)
print(f"原集合: {original}")  # {1, 2, 3, 5}（被修改了！）
```

### 6.2 集合方法详解

#### 集合运算方法
```python
# ========== 集合运算 ==========
set1 = {1, 2, 3, 4, 5}
set2 = {4, 5, 6, 7, 8}

print(f"set1: {set1}")
print(f"set2: {set2}")

# 并集 - 所有在set1或set2中的元素
union1 = set1 | set2
union2 = set1.union(set2)
print(f"并集 | : {union1}")        # {1, 2, 3, 4, 5, 6, 7, 8}
print(f"并集 union(): {union2}")   # {1, 2, 3, 4, 5, 6, 7, 8}

# 交集 - 所有同时在set1和set2中的元素
intersection1 = set1 & set2
intersection2 = set1.intersection(set2)
print(f"交集 & : {intersection1}")        # {4, 5}
print(f"交集 intersection(): {intersection2}") # {4, 5}

# 差集 - 在set1中但不在set2中的元素
difference1 = set1 - set2
difference2 = set1.difference(set2)
print(f"差集 - : {difference1}")        # {1, 2, 3}
print(f"差集 difference(): {difference2}") # {1, 2, 3}

# 对称差集 - 在set1或set2中，但不同时在两者中的元素
symmetric_difference1 = set1 ^ set2
symmetric_difference2 = set1.symmetric_difference(set2)
print(f"对称差集 ^ : {symmetric_difference1}")        # {1, 2, 3, 6, 7, 8}
print(f"对称差集 symmetric_difference(): {symmetric_difference2}") # {1, 2, 3, 6, 7, 8}

# 多个集合的运算
set3 = {5, 6, 9, 10}
multi_union = set1 | set2 | set3
multi_intersection = set1 & set2 & set3
print(f"多集合并集: {multi_union}")        # {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
print(f"多集合交集: {multi_intersection}") # {5}
```

#### 集合比较方法
```python
# ========== 集合比较 ==========
setA = {1, 2, 3}
setB = {1, 2, 3, 4, 5}
setC = {4, 5, 6}
setD = {1, 2, 3}

print(f"setA: {setA}")
print(f"setB: {setB}")
print(f"setC: {setC}")
print(f"setD: {setD}")

# 子集判断
print(f"setA是setB的子集: {setA.issubset(setB)}")  # True
print(f"setA <= setB: {setA <= setB}")            # True
print(f"setA是setB的真子集: {setA < setB}")        # True

# 超集判断
print(f"setB是setA的超集: {setB.issuperset(setA)}")  # True
print(f"setB >= setA: {setB >= setA}")              # True
print(f"setB是setA的真超集: {setB > setA}")          # True

# 相等判断
print(f"setA == setD: {setA == setD}")            # True
print(f"setA == setB: {setA == setB}")            # False

# 无交集判断
print(f"setA和setC无交集: {setA.isdisjoint(setC)}")  # True
print(f"setA和setB无交集: {setA.isdisjoint(setB)}")  # False

# 实际应用示例
students_math = {"Alice", "Bob", "Charlie"}
students_physics = {"Bob", "Charlie", "David"}
students_chemistry = {"Charlie", "Eve", "Frank"}

# 同时选修数学和物理的学生
math_physics = students_math & students_physics
print(f"数理双修: {math_physics}")  # {'Bob', 'Charlie'}

# 只选修数学的学生
only_math = students_math - students_physics - students_chemistry
print(f"只修数学: {only_math}")  # {'Alice'}

# 至少选修一门的学生
any_course = students_math | students_physics | students_chemistry
print(f"至少一门: {any_course}")  # 所有学生

# 只选修一门的学生
only_one = (students_math ^ students_physics ^ students_chemistry) - \
          (students_math & students_physics) - \
          (students_math & students_chemistry) - \
          (students_physics & students_chemistry)
print(f"只修一门: {only_one}")  # {'Alice', 'David', 'Eve', 'Frank'}
```

#### 集合更新方法
```python
# ========== 集合更新操作 ==========
# 这些方法会原地修改集合

set1 = {1, 2, 3, 4, 5}
set2 = {4, 5, 6, 7, 8}

print(f"初始 set1: {set1}")
print(f"初始 set2: {set2}")

# update() - 并集更新（添加set2的所有元素）
set1.update(set2)  # 相当于 set1 |= set2
print(f"update后 set1: {set1}")  # {1, 2, 3, 4, 5, 6, 7, 8}

set1 = {1, 2, 3, 4, 5}
set1 |= set2  # 同上
print(f"|= 后 set1: {set1}")

# intersection_update() - 交集更新（只保留共同元素）
set1 = {1, 2, 3, 4, 5}
set1.intersection_update(set2)  # 相当于 set1 &= set2
print(f"intersection_update后 set1: {set1}")  # {4, 5}

set1 = {1, 2, 3, 4, 5}
set1 &= set2  # 同上
print(f"&= 后 set1: {set1}")

# difference_update() - 差集更新（移除set2中的元素）
set1 = {1, 2, 3, 4, 5}
set1.difference_update(set2)  # 相当于 set1 -= set2
print(f"difference_update后 set1: {set1}")  # {1, 2, 3}

set1 = {1, 2, 3, 4, 5}
set1 -= set2  # 同上
print(f"-= 后 set1: {set1}")

# symmetric_difference_update() - 对称差集更新
set1 = {1, 2, 3, 4, 5}
set1.symmetric_difference_update(set2)  # 相当于 set1 ^= set2
print(f"symmetric_difference_update后 set1: {set1}")  # {1, 2, 3, 6, 7, 8}

set1 = {1, 2, 3, 4, 5}
set1 ^= set2  # 同上
print(f"^= 后 set1: {set1}")
```

### 6.3 高级用法详解

#### 集合推导式
```python
# ========== 集合推导式 ==========
# 基本集合推导式
squares = {x**2 for x in range(10)}
print(f"平方数集合: {squares}")  # {0, 1, 4, 9, 16, 25, 36, 49, 64, 81}

# 带条件的集合推导式
even_squares = {x**2 for x in range(10) if x % 2 == 0}
print(f"偶数平方数集合: {even_squares}")  # {0, 4, 16, 36, 64}

# 处理字符串
words = ["hello", "world", "python", "programming"]
unique_chars = {char for word in words for char in word}
print(f"唯一字符: {unique_chars}")

# 去重并转换
numbers = [1, 2, 2, 3, 3, 4, 4, 5, 5, 5]
unique_even = {x for x in numbers if x % 2 == 0}
print(f"唯一偶数: {unique_even}")  # {2, 4}

# 复杂条件的集合推导式
sentence = "The quick brown fox jumps over the lazy dog"
unique_vowels = {char for char in sentence.lower() if char in 'aeiou'}
print(f"唯一元音: {unique_vowels}")  # {'o', 'e', 'u', 'i', 'a'}

# 嵌套集合推导式
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
unique_numbers = {num for row in matrix for num in row}
print(f"矩阵唯一数字: {unique_numbers}")  # {1, 2, 3, 4, 5, 6, 7, 8, 9}
```

#### 不可变集合 (frozenset)
```python
# ========== 不可变集合 ==========
# 创建不可变集合
frozen = frozenset([1, 2, 3, 4, 5])
print(f"不可变集合: {frozen}")  # frozenset({1, 2, 3, 4, 5})

# 不可变集合支持集合运算，但不能修改
frozen2 = frozenset([4, 5, 6, 7, 8])
union_frozen = frozen | frozen2
intersection_frozen = frozen & frozen2
print(f"不可变集合并集: {union_frozen}")        # frozenset({1, 2, 3, 4, 5, 6, 7, 8})
print(f"不可变集合交集: {intersection_frozen}") # frozenset({4, 5})

# 不可变集合可以作为字典的键或另一个集合的元素
valid_dict = {frozen: "value1", frozen2: "value2"}
valid_set = {frozen, frozen2}
print(f"字典: {valid_dict}")
print(f"集合: {valid_set}")

# 尝试修改不可变集合会报错
try:
    frozen.add(6)  # AttributeError
except AttributeError as e:
    print(f"错误: {e}")

try:
    frozen.remove(1)  # AttributeError
except AttributeError as e:
    print(f"错误: {e}")

# 不可变集合的方法（只读）
print(f"frozen长度: {len(frozen)}")
print(f"1在frozen中: {1 in frozen}")
print(f"frozen副本: {frozen.copy()}")  # 返回自身

# 实际应用：配置集合
CONFIG_OPTIONS = frozenset(["debug", "verbose", "quiet", "color"])
user_options = {"debug", "color"}

# 检查用户选项是否有效
valid_options = user_options & CONFIG_OPTIONS
invalid_options = user_options - CONFIG_OPTIONS
print(f"有效选项: {valid_options}")
print(f"无效选项: {invalid_options}")
```

#### 集合性能优势
```python
# ========== 集合性能优势 ==========
import timeit

# 列表和集合的成员检测性能比较
def test_list_membership(n):
    """测试列表成员检测"""
    lst = list(range(n))
    return n-1 in lst  # 最坏情况：遍历整个列表

def test_set_membership(n):
    """测试集合成员检测"""
    s = set(range(n))
    return n-1 in s  # 平均情况：O(1)

# 性能测试
n = 10000
list_time = timeit.timeit(lambda: test_list_membership(n), number=1000)
set_time = timeit.timeit(lambda: test_set_membership(n), number=1000)

print(f"列表成员检测时间: {list_time:.4f}秒")
print(f"集合成员检测时间: {set_time:.4f}秒")
print(f"集合比列表快 {list_time/set_time:.1f} 倍")

# ========== 去重性能比较 ==========
def deduplicate_list(lst):
    """使用列表去重（保持顺序）"""
    seen = set()
    result = []
    for item in lst:
        if item not in seen:
            seen.add(item)
            result.append(item)
    return result

def deduplicate_set(lst):
    """使用集合去重（不保持顺序）"""
    return list(set(lst))

# 测试数据
data_with_duplicates = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5] * 1000

# 性能测试
time_dedup_list = timeit.timeit(lambda: deduplicate_list(data_with_duplicates), number=10)
time_dedup_set = timeit.timeit(lambda: deduplicate_set(data_with_duplicates), number=10)

print(f"保持顺序去重时间: {time_dedup_list:.4f}秒")
print(f"不保持顺序去重时间: {time_dedup_set:.4f}秒")

# ========== 集合运算性能 ==========
large_set1 = set(range(100000))
large_set2 = set(range(50000, 150000))

# 并集性能
union_time = timeit.timeit(lambda: large_set1 | large_set2, number=100)
print(f"大集合并集时间: {union_time:.4f}秒")

# 交集性能
intersection_time = timeit.timeit(lambda: large_set1 & large_set2, number=100)
print(f"大集合交集时间: {intersection_time:.4f}秒")
```

### 6.4 易错点详解

```python
# ========== 集合易错点 ==========

# 错误1：使用{}创建空集合
empty_dict = {}  # 这是空字典
empty_set = set() # 这是空集合
print(f"空字典类型: {type(empty_dict)}")  # <class 'dict'>
print(f"空集合类型: {type(empty_set)}")   # <class 'set'>

# 但有元素的{}创建的是集合
non_empty_set = {1, 2, 3}
print(f"非空集合类型: {type(non_empty_set)}")  # <class 'set'>

# 错误2：集合中的元素必须是可哈希的
try:
    invalid_set = {[1, 2]}  # 列表不可哈希
except TypeError as e:
    print(f"错误: {e}")

try:
    invalid_set2 = {{1, 2}}  # 集合不可哈希
except TypeError as e:
    print(f"错误: {e}")

# 但可以包含元组（如果元组只包含不可变元素）
valid_set = {(1, 2), (3, 4)}
print(f"包含元组的集合: {valid_set}")

# 错误3：集合无序，不能通过索引访问
numbers = {3, 1, 4, 1, 5, 9}
try:
    print(numbers[0])  # TypeError: 'set' object is not subscriptable
except TypeError as e:
    print(f"错误: {e}")

# 正确：转换为列表后访问（但顺序不确定）
numbers_list = list(numbers)
print(f"转换为列表: {numbers_list}")  # 顺序可能为 [1, 3, 4, 5, 9]

# 如果需要有序集合，可以使用sorted()
sorted_numbers = sorted(numbers)
print(f"排序后: {sorted_numbers}")  # [1, 3, 4, 5, 9]

# 错误4：在循环中修改集合
numbers = {1, 2, 3, 4, 5}
# 在遍历时不能添加或删除元素
# for num in numbers:
#     if num % 2 == 0:
#         numbers.remove(num)  # RuntimeError: Set changed size during iteration

# 正确：先收集要修改的元素
numbers = {1, 2, 3, 4, 5}
to_remove = set()
for num in numbers:
    if num % 2 == 0:
        to_remove.add(num)

numbers -= to_remove
print(f"删除偶数后: {numbers}")  # {1, 3, 5}

# 或者使用集合推导式
numbers = {1, 2, 3, 4, 5}
numbers = {num for num in numbers if num % 2 != 0}
print(f"推导式删除后: {numbers}")  # {1, 3, 5}

# 或者创建副本进行遍历
numbers = {1, 2, 3, 4, 5}
for num in numbers.copy():
    if num % 2 == 0:
        numbers.remove(num)
print(f"副本遍历删除后: {numbers}")  # {1, 3, 5}

# 错误5：混淆集合运算的符号和方法
set1 = {1, 2, 3}
set2 = {3, 4, 5}

# 符号运算创建新集合
union1 = set1 | set2
print(f"原set1: {set1}")  # 未改变

# 方法运算可以原地修改
set1.update(set2)  # 修改set1
print(f"update后set1: {set1}")  # 已改变

# 错误6：True和1、False和0的冲突
mixed_set = {True, 1, False, 0}
print(f"混合集合: {mixed_set}")  # {False, True} 因为 True==1, False==0

# 避免这个问题的方法
mixed_set_correct = {True, 1, False, 0, None}  # 添加None或其他不同对象
print(f"修正混合集合: {mixed_set_correct}")  # {False, True, None}

# 或者明确区分
explicit_set = {"True", "1", "False", "0"}
print(f"明确区分集合: {explicit_set}")  # {'True', '1', 'False', '0'}

# 错误7：集合比较的陷阱
setA = {1, 2, 3}
setB = {3, 2, 1}
print(f"setA == setB: {setA == setB}")  # True（集合无序，只要元素相同就相等）

# 但子集比较要注意
setC = {1, 2}
print(f"setC < setA: {setC < setA}")  # True（真子集）
print(f"setC <= setA: {setC <= setA}")  # True（子集）
print(f"setA < setA: {setA < setA}")  # False（不是真子集）

# 错误8：忽略集合的哈希特性
# 集合本身不可哈希，不能作为字典键或其他集合元素
try:
    invalid_dict_key = {{1, 2}: "value"}  # 集合不可哈希
except TypeError as e:
    print(f"错误: {e}")

# 但frozenset可以
valid_dict_key = {frozenset({1, 2}): "value"}
print(f"有效字典键: {valid_dict_key}")  # {frozenset({1, 2}): 'value'}
```

## 7. 其他重要数据类型

### 7.1 None 类型

```python
# ========== None 类型 ==========
# None 表示空值或没有值
value = None

# 检查是否为 None
if value is None:
    print("Value is None")

if value is not None:
    print("Value is not None")

# None 在条件判断中为 False
if not value:
    print("None is False in condition")

# 函数的默认返回值
def do_nothing():
    pass

result = do_nothing()
print(f"无返回值函数返回: {result}")  # None

# 作为默认参数
def greet(name=None):
    if name is None:
        return "Hello, anonymous!"
    return f"Hello, {name}!"

print(greet())          # Hello, anonymous!
print(greet("Alice"))   # Hello, Alice!

# None 是单例对象
none1 = None
none2 = None
print(f"None is None: {none1 is none2}")  # True
print(f"id(None): {id(None)}")

# None 与其他值的比较
print(f"None == False: {None == False}")    # False
print(f"None == 0: {None == 0}")           # False
print(f"None == '': {None == ''}")         # False
print(f"None == []: {None == []}")         # False
```

### 7.2 字节 (bytes) 和字节数组 (bytearray)

```python
# ========== 字节 (bytes) ==========
# 不可变字节序列
b = b"hello"
b_from_list = bytes([65, 66, 67])  # b'ABC'
b_from_hex = bytes.fromhex("2Ef0 F1f2")  # b'.\xf0\xf1\xf2'

print(f"字节: {b}")              # b'hello'
print(f"从列表创建: {b_from_list}") # b'ABC'
print(f"从十六进制创建: {b_from_hex}")

# 字节索引和切片
print(f"b[0]: {b[0]}")          # 104 (ASCII码)
print(f"b[1:4]: {b[1:4]}")      # b'ell'

# 字节遍历
for byte in b:
    print(byte, end=' ')  # 104 101 108 108 111
print()

# 编码和解码
text = "你好，世界"
encoded = text.encode('utf-8')  # 编码为字节
decoded = encoded.decode('utf-8')  # 解码为字符串

print(f"原始文本: {text}")
print(f"编码后: {encoded}")  
print(f"解码后: {decoded}")  # 你好，世界

# ========== 字节数组 (bytearray) ==========
# 可变字节序列
ba = bytearray(b"hello")
ba[0] = 72  # 'H' 的ASCII码
print(f"字节数组: {ba}")  # bytearray(b'Hello')

# 修改操作
ba.append(33)  # '!' 的ASCII码
ba.extend(b" World")
print(f"修改后: {ba}")    # bytearray(b'Hello! World')

# 字节数组方法
ba.reverse()
print(f"反转后: {ba}")    # bytearray(b'dlroW !olleH')

# 内存视图（高效处理大型数据）
data = bytearray(b'0123456789')
mv = memoryview(data)
slice_view = mv[5:8]
slice_view[0] = 65  # 修改原始数据
print(f"原始数据: {data}")  # bytearray(b'01234A6789')
```

## 总结

### Python 数据类型完整对比表

| 类型 | 可变性 | 有序性 | 元素要求 | 使用场景 | 示例 |
|------|--------|--------|----------|----------|------|
| int | 不可变 | - | - | 整数计算 | `x = 10` |
| float | 不可变 | - | - | 浮点数计算 | `x = 3.14` |
| complex | 不可变 | - | - | 复数计算 | `x = 3+4j` |
| bool | 不可变 | - | - | 逻辑判断 | `x = True` |
| str | 不可变 | 有序 | 字符 | 文本处理 | `s = "hello"` |
| list | 可变 | 有序 | 任意类型 | 有序集合 | `lst = [1, 2, 3]` |
| tuple | 不可变 | 有序 | 任意类型 | 不可变有序集合 | `t = (1, 2, 3)` |
| dict | 可变 | 有序(3.7+) | 键:不可变, 值:任意 | 键值对映射 | `d = {"a": 1}` |
| set | 可变 | 无序 | 不可变类型 | 去重、集合运算 | `s = {1, 2, 3}` |
| frozenset | 不可变 | 无序 | 不可变类型 | 不可变集合 | `fs = frozenset([1,2,3])` |
| bytes | 不可变 | 有序 | 0-255整数 | 二进制数据 | `b = b"hello"` |
| bytearray | 可变 | 有序 | 0-255整数 | 可修改二进制数据 | `ba = bytearray(b"hello")` |
| None | 不可变 | - | - | 空值表示 | `x = None` |

### 数据类型选择指南

1. **需要有序集合**：使用 `list` 或 `tuple`
   - 可变：`list`
   - 不可变：`tuple`

2. **需要键值映射**：使用 `dict`
   - 快速查找：`dict`
   - 带默认值：`defaultdict`
   - 保持顺序：`OrderedDict`（Python 3.7+普通dict也保持顺序）

3. **需要去重或集合运算**：使用 `set`
   - 可变：`set`
   - 不可变（可作为字典键）：`frozenset`

4. **处理文本**：使用 `str`
   - 字符串操作、格式化、编码

5. **处理二进制数据**：
   - 不可变：`bytes`
   - 可变：`bytearray`

6. **表示空值**：使用 `None`

### 最佳实践建议

1. **选择合适的数据类型**：根据具体需求选择最合适的数据类型
2. **理解可变性**：清楚知道哪些类型可变，哪些不可变
3. **注意性能特征**：
   - 列表：在末尾操作快，在开头操作慢
   - 集合：成员检测快，但无序
   - 字典：键查找快，但占用内存多

4. **使用类型提示**（Python 3.5+）：
```python
from typing import List, Dict, Set, Optional

def process_data(
    numbers: List[int],
    config: Dict[str, str],
    unique_items: Set[str],
    optional_value: Optional[str] = None
) -> bool:
    # 函数体
    return True
```

5. **处理边界情况**：
   - 空集合、空列表、空字典的判断
   - 类型转换时的异常处理
   - 循环中修改容器的注意事项

这份超详细的Python数据类型笔记涵盖了所有主要数据类型的基础用法、高级用法和易错点，希望对您的Python学习有全面的帮助！