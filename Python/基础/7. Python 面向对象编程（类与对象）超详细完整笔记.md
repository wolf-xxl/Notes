
## 1. 面向对象编程基础概念

### 1.1 什么是面向对象编程

```python
# ========== 面向对象编程基本概念 ==========
"""
面向对象编程（OOP）是一种编程范式，它使用"对象"来设计应用程序
对象包含：
1. 属性（数据）
2. 方法（行为）

OOP的四大特性：
- 封装（Encapsulation）：将数据和操作数据的方法捆绑在一起
- 继承（Inheritance）：子类可以继承父类的属性和方法
- 多态（Polymorphism）：同一操作作用于不同对象可以有不同的行为
- 抽象（Abstraction）：隐藏复杂实现细节，只暴露必要接口
"""

# ========== 类和对象的关系 ==========
"""
类（Class）：是对象的蓝图或模板，定义了对象的属性和方法
对象（Object）：是类的实例，具有具体的属性值

比喻：
类就像是汽车的图纸 - 定义了汽车应该有什么部件和功能
对象就像是根据图纸制造出来的具体汽车 - 有具体的颜色、车牌号等
"""

# ========== 面向对象 vs 面向过程 ==========
# 面向过程的方式：关注的是步骤和函数
def calculate_area_rectangular(width, height):
    return width * height

def calculate_area_circular(radius):
    return 3.14159 * radius ** 2

# 面向对象的方式：关注的是对象和它们的行为
class Shape:
    def area(self):
        pass

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    
    def area(self):
        return 3.14159 * self.radius ** 2

# 使用面向对象的方式：更符合现实世界的思维方式
rect = Rectangle(5, 3)
circle = Circle(4)
print(f"矩形面积: {rect.area()}")
print(f"圆形面积: {circle.area()}")
```

### 1.2 类和对象的基本概念

```python
# ========== 第一个类定义 ==========
class Dog:
    """狗类的简单示例"""
    
    # 类属性（所有实例共享） - 类似于物种这种所有狗都一样的属性
    species = "Canis familiaris"
    
    def __init__(self, name, age):
        """初始化方法（构造函数） - 创建对象时自动调用"""
        # 实例属性（每个实例独有） - 每只狗都有自己的名字和年龄
        self.name = name
        self.age = age
    
    def bark(self):
        """实例方法 - 狗的行为"""
        return f"{self.name} 在汪汪叫！"
    
    def get_info(self):
        """另一个实例方法"""
        return f"{self.name} 是一只 {self.age} 岁的狗"

# ========== 创建对象（实例化） ==========
# 创建Dog类的实例 - 根据类创建具体的对象
dog1 = Dog("Buddy", 3)
dog2 = Dog("Lucy", 5)

print(f"dog1: {dog1.name}, {dog1.age}岁")
print(f"dog2: {dog2.name}, {dog2.age}岁")

# 调用方法 - 让对象执行某些操作
print(dog1.bark())
print(dog2.get_info())

# 访问类属性 - 所有实例共享的属性
print(f"狗的物种: {Dog.species}")
print(f"dog1的物种: {dog1.species}")

# ========== 对象的身份、类型和值 ==========
print(f"dog1的身份（内存地址）: {id(dog1)}")
print(f"dog1的类型: {type(dog1)}")
print(f"dog1的值: {dog1.name}, {dog1.age}")

# 检查类型 - 确认对象属于哪个类
print(f"dog1是Dog类型吗？: {isinstance(dog1, Dog)}")
print(f"Dog是type类型吗？: {isinstance(Dog, type)}")

# ========== 对象的比较 ==========
dog3 = Dog("Buddy", 3)
print(f"dog1 == dog3: {dog1 == dog3}")  # False（不同对象）
print(f"dog1 is dog3: {dog1 is dog3}")  # False

# 注意：即使属性相同，Python默认也会认为是不同的对象
# 如果想根据属性判断相等，需要重写 __eq__ 方法
```

## 2. 类的基本组成

### 2.1 属性详解

```python
# ========== 类属性和实例属性 ==========
class Car:
    """汽车类演示类属性和实例属性"""
    
    # 类属性（所有实例共享） - 比如所有汽车都有4个轮子
    wheels = 4
    manufacturer = "未知制造商"
    
    def __init__(self, brand, model, year):
        # 实例属性（每个实例独有） - 每辆汽车的具体信息
        self.brand = brand
        self.model = model
        self.year = year
        self.mileage = 0  # 初始里程
    
    def drive(self, distance):
        """开车，增加里程"""
        self.mileage += distance
        return f"开了 {distance} 公里，总里程: {self.mileage}"

# 创建实例
car1 = Car("Toyota", "Camry", 2022)
car2 = Car("Honda", "Civic", 2023)

print(f"car1: {car1.brand} {car1.model}")
print(f"car2: {car2.brand} {car2.model}")

# 访问类属性 - 可以通过类名或实例访问
print(f"所有汽车都有 {Car.wheels} 个轮子")
print(f"car1的轮子数: {car1.wheels}")

# 修改类属性会影响所有实例 - 因为所有实例共享类属性
Car.wheels = 6
print(f"修改后car1的轮子数: {car1.wheels}")
print(f"修改后car2的轮子数: {car2.wheels}")

# 实例属性修改只影响该实例 - 每个实例有自己的属性副本
car1.mileage = 1000
print(f"car1里程: {car1.mileage}")
print(f"car2里程: {car2.mileage}")

# ========== 私有属性 ==========
class BankAccount:
    """银行账户类演示私有属性"""
    
    def __init__(self, account_holder, initial_balance=0):
        self.account_holder = account_holder  # 公开属性 - 外部可以直接访问
        self._account_number = "123456789"    # 保护属性（约定）- 外部不应该直接访问
        self.__balance = initial_balance      # 私有属性（名称修饰）- 外部无法直接访问
    
    def get_balance(self):
        """获取余额（公开方法）- 通过方法访问私有属性"""
        return self.__balance
    
    def deposit(self, amount):
        """存款 - 通过方法修改私有属性"""
        if amount > 0:
            self.__balance += amount
            return f"存款 {amount} 成功，当前余额: {self.__balance}"
        else:
            return "存款金额必须大于0"
    
    def withdraw(self, amount):
        """取款 - 通过方法修改私有属性"""
        if 0 < amount <= self.__balance:
            self.__balance -= amount
            return f"取款 {amount} 成功，当前余额: {self.__balance}"
        else:
            return "取款金额无效"

# 创建账户
account = BankAccount("Alice", 1000)
print(f"账户持有人: {account.account_holder}")
print(f"余额: {account.get_balance()}")

# 尝试访问私有属性
print(f"保护属性: {account._account_number}")  # 可以访问但不推荐 - 这是约定

try:
    print(f"私有属性: {account.__balance}")  # 会报错 - Python进行了名称修饰
except AttributeError as e:
    print(f"错误: {e}")

# 实际上私有属性被名称修饰了 - 知道这个机制但不要这样使用
print(f"实际属性名: {account._BankAccount__balance}")  # 可以访问但不推荐

# ========== 属性动态添加和删除 ==========
class DynamicClass:
    """演示动态属性操作 - Python允许运行时动态修改对象"""
    
    def __init__(self, name):
        self.name = name

# 创建实例
obj = DynamicClass("测试对象")

# 动态添加属性 - Python的灵活性
obj.new_attribute = "这是动态添加的属性"
obj.temporary_data = [1, 2, 3]

print(f"动态属性: {obj.new_attribute}")
print(f"临时数据: {obj.temporary_data}")

# 检查属性是否存在
print(f"有name属性吗？: {hasattr(obj, 'name')}")
print(f"有unknown属性吗？: {hasattr(obj, 'unknown')}")

# 获取属性（安全方式）- 如果属性不存在返回默认值
name = getattr(obj, 'name', '默认值')
unknown = getattr(obj, 'unknown', '默认值')
print(f"名称: {name}")
print(f"未知属性: {unknown}")

# 动态设置属性
setattr(obj, 'dynamic_value', 42)
print(f"动态值: {obj.dynamic_value}")

# 删除属性
delattr(obj, 'temporary_data')
print(f"删除后还有temporary_data吗？: {hasattr(obj, 'temporary_data')}")

# 查看所有属性
print(f"所有实例属性: {obj.__dict__}")
```

### 2.2 方法详解

```python
# ========== 实例方法 ==========
class Calculator:
    """计算器类演示实例方法"""
    
    def __init__(self):
        self.history = []  # 计算历史 - 实例属性
    
    def add(self, a, b):
        """加法 - 实例方法，第一个参数是self"""
        result = a + b
        self.history.append(f"{a} + {b} = {result}")
        return result
    
    def subtract(self, a, b):
        """减法"""
        result = a - b
        self.history.append(f"{a} - {b} = {result}")
        return result
    
    def multiply(self, a, b):
        """乘法"""
        result = a * b
        self.history.append(f"{a} × {b} = {result}")
        return result
    
    def divide(self, a, b):
        """除法"""
        if b == 0:
            raise ValueError("除数不能为零")
        result = a / b
        self.history.append(f"{a} ÷ {b} = {result}")
        return result
    
    def show_history(self):
        """显示计算历史"""
        if not self.history:
            return "没有计算历史"
        return "\n".join(self.history)

# 使用计算器
calc = Calculator()
print(f"5 + 3 = {calc.add(5, 3)}")
print(f"10 - 4 = {calc.subtract(10, 4)}")
print(f"6 × 7 = {calc.multiply(6, 7)}")
print(f"15 ÷ 3 = {calc.divide(15, 3)}")

print("\n计算历史:")
print(calc.show_history())

# ========== 类方法 ==========
class Person:
    """人类演示类方法"""
    
    species = "Homo sapiens"
    count = 0  # 统计创建的人数 - 类属性
    
    def __init__(self, name, age):
        self.name = name
        self.age = age
        Person.count += 1  # 每次创建实例时计数增加
    
    @classmethod
    def get_species(cls):
        """类方法 - 操作类属性，第一个参数是cls（类本身）"""
        return f"物种: {cls.species}"
    
    @classmethod
    def get_count(cls):
        """类方法 - 获取实例计数"""
        return f"已创建 {cls.count} 个人"
    
    @classmethod
    def create_baby(cls, name):
        """类方法 - 作为替代构造函数"""
        return cls(name, 0)  # 婴儿年龄为0
    
    @classmethod
    def from_birth_year(cls, name, birth_year):
        """类方法 - 根据出生年份创建"""
        from datetime import datetime
        current_year = datetime.now().year
        age = current_year - birth_year
        return cls(name, age)

# 使用类方法
print(Person.get_species())
print(Person.get_count())

# 创建实例
person1 = Person("Alice", 25)
person2 = Person("Bob", 30)

print(Person.get_count())

# 使用类方法作为替代构造函数 - 提供多种创建对象的方式
baby = Person.create_baby("Charlie")
person3 = Person.from_birth_year("David", 1990)

print(f"婴儿: {baby.name}, {baby.age}岁")
print(f"根据出生年份创建: {person3.name}, {person3.age}岁")

# ========== 静态方法 ==========
class MathUtils:
    """数学工具类演示静态方法"""
    
    @staticmethod
    def factorial(n):
        """静态方法 - 计算阶乘，不需要self或cls参数"""
        if n < 0:
            raise ValueError("阶乘不能为负数")
        result = 1
        for i in range(1, n + 1):
            result *= i
        return result
    
    @staticmethod
    def is_prime(n):
        """静态方法 - 判断质数"""
        if n < 2:
            return False
        for i in range(2, int(n ** 0.5) + 1):
            if n % i == 0:
                return False
        return True
    
    @staticmethod
    def celsius_to_fahrenheit(celsius):
        """静态方法 - 摄氏度转华氏度"""
        return (celsius * 9/5) + 32

# 使用静态方法 - 就像普通函数一样，但逻辑上属于这个类
print(f"5的阶乘: {MathUtils.factorial(5)}")
print(f"17是质数吗？: {MathUtils.is_prime(17)}")
print(f"25是质数吗？: {MathUtils.is_prime(25)}")
print(f"0°C = {MathUtils.celsius_to_fahrenheit(0)}°F")

# 静态方法也可以通过实例调用
utils = MathUtils()
print(f"通过实例调用: {utils.factorial(4)}")

# ========== 方法类型总结 ==========
class MethodDemo:
    """演示不同类型的方法"""
    
    class_variable = "类变量"
    
    def __init__(self, value):
        self.instance_variable = value
    
    def instance_method(self):
        """实例方法 - 可以访问实例和类属性，第一个参数是self"""
        return f"实例方法: 实例变量={self.instance_variable}, 类变量={self.class_variable}"
    
    @classmethod
    def class_method(cls):
        """类方法 - 只能访问类属性，第一个参数是cls"""
        return f"类方法: 类变量={cls.class_variable}"
    
    @staticmethod
    def static_method():
        """静态方法 - 不能访问实例或类属性，就像普通函数"""
        return "静态方法: 不依赖类或实例"

# 测试不同类型的方法
demo = MethodDemo("实例值")

print(demo.instance_method())  # 需要实例
print(MethodDemo.class_method())  # 可以通过类或实例调用
print(MethodDemo.static_method())  # 可以通过类或实例调用
```

## 3. 封装、继承和多态

### 3.1 封装

```python
# ========== 封装的基本概念 ==========
"""
封装（Encapsulation）是将数据和行为包装在一起，并隐藏内部实现细节
在Python中，封装主要通过：
1. 私有属性和方法（名称修饰）
2. 属性装饰器（@property）
3. 公开的接口方法

好处：
- 保护数据不被意外修改
- 隐藏实现细节，只暴露必要接口
- 便于修改内部实现而不影响外部代码
"""

class Employee:
    """员工类演示封装"""
    
    def __init__(self, name, salary):
        self.name = name  # 公开属性
        self._department = "未分配"  # 保护属性
        self.__salary = salary  # 私有属性
        self.__performance_rating = 0
    
    # 公开的接口方法 - 获取信息
    def get_salary_info(self):
        """获取薪资信息（封装了具体实现）"""
        return f"薪资范围: {self.__calculate_salary_range()}"
    
    def set_performance_rating(self, rating):
        """设置绩效评分（带有验证）"""
        if 1 <= rating <= 5:
            self.__performance_rating = rating
            self.__update_salary_based_on_performance()
        else:
            raise ValueError("绩效评分必须在1-5之间")
    
    def get_performance_rating(self):
        """获取绩效评分"""
        return self.__performance_rating
    
    # 私有方法 - 内部实现细节，外部不应该调用
    def __calculate_salary_range(self):
        """计算薪资范围（私有方法）"""
        base = self.__salary
        return f"{base * 0.8:.2f} - {base * 1.2:.2f}"
    
    def __update_salary_based_on_performance(self):
        """根据绩效更新薪资（私有方法）"""
        bonus_multiplier = 1 + (self.__performance_rating - 3) * 0.1
        self.__salary *= bonus_multiplier

# 使用封装后的类
emp = Employee("张三", 5000)
print(f"员工: {emp.name}")
print(emp.get_salary_info())

# 通过公开接口操作 - 不能直接修改私有属性
emp.set_performance_rating(4)
print(f"绩效评分: {emp.get_performance_rating()}")
print(emp.get_salary_info())

# 无法直接访问私有属性 - 保护数据完整性
try:
    print(emp.__salary)
except AttributeError as e:
    print(f"无法直接访问私有属性: {e}")

# ========== 属性装饰器 ==========
class Temperature:
    """温度类演示属性装饰器"""
    
    def __init__(self, celsius=0):
        self._celsius = celsius  # 使用保护属性存储实际数据
    
    @property
    def celsius(self):
        """获取摄氏温度 - 像属性一样使用，实际上是方法"""
        return self._celsius
    
    @celsius.setter
    def celsius(self, value):
        """设置摄氏温度（带验证）"""
        if value < -273.15:
            raise ValueError("温度不能低于绝对零度(-273.15°C)")
        self._celsius = value
    
    @property
    def fahrenheit(self):
        """获取华氏温度（只读属性）- 没有setter"""
        return (self._celsius * 9/5) + 32
    
    @property
    def kelvin(self):
        """获取开氏温度（只读属性）"""
        return self._celsius + 273.15

# 使用属性装饰器
temp = Temperature(25)
print(f"摄氏温度: {temp.celsius}°C")  # 像属性一样访问，实际上是调用方法
print(f"华氏温度: {temp.fahrenheit}°F")
print(f"开氏温度: {temp.kelvin}K")

# 设置温度 - 会调用setter方法进行验证
temp.celsius = 30
print(f"新摄氏温度: {temp.celsius}°C")
print(f"新华氏温度: {temp.fahrenheit}°F")

# 尝试设置无效温度 - setter方法会进行验证
try:
    temp.celsius = -300
except ValueError as e:
    print(f"错误: {e}")

# 尝试设置只读属性 - 因为没有setter会报错
try:
    temp.fahrenheit = 100  # 会报错，因为没有setter
except AttributeError as e:
    print(f"错误: {e}")

# ========== 完整的属性封装示例 ==========
class BankAccount:
    """银行账户完整封装示例"""
    
    def __init__(self, account_holder, initial_balance=0):
        self._account_holder = account_holder
        self._balance = initial_balance
        self._transaction_history = []
    
    @property
    def account_holder(self):
        """账户持有人（只读）"""
        return self._account_holder
    
    @property
    def balance(self):
        """余额（只读）"""
        return self._balance
    
    @property
    def transaction_history(self):
        """交易历史（只读）"""
        return self._transaction_history.copy()  # 返回副本防止外部修改
    
    def deposit(self, amount):
        """存款 - 通过方法修改余额"""
        if amount <= 0:
            raise ValueError("存款金额必须大于0")
        
        self._balance += amount
        self._transaction_history.append(f"存款: +{amount:.2f}")
        return f"存款成功，当前余额: {self._balance:.2f}"
    
    def withdraw(self, amount):
        """取款 - 通过方法修改余额"""
        if amount <= 0:
            raise ValueError("取款金额必须大于0")
        if amount > self._balance:
            raise ValueError("余额不足")
        
        self._balance -= amount
        self._transaction_history.append(f"取款: -{amount:.2f}")
        return f"取款成功，当前余额: {self._balance:.2f}"
    
    def transfer(self, amount, target_account):
        """转账"""
        if not isinstance(target_account, BankAccount):
            raise TypeError("目标账户必须是BankAccount实例")
        
        self.withdraw(amount)  # 从当前账户扣款
        target_account.deposit(amount)  # 向目标账户存款
        
        self._transaction_history.append(f"转账给 {target_account.account_holder}: -{amount:.2f}")
        target_account._transaction_history.append(f"收到 {self.account_holder} 转账: +{amount:.2f}")
        
        return f"转账成功，当前余额: {self._balance:.2f}"

# 使用完整封装的银行账户
account1 = BankAccount("Alice", 1000)
account2 = BankAccount("Bob", 500)

print(f"账户1余额: {account1.balance}")
print(f"账户2余额: {account2.balance}")

account1.deposit(200)
account1.withdraw(100)
account1.transfer(300, account2)

print(f"转账后账户1余额: {account1.balance}")
print(f"转账后账户2余额: {account2.balance}")

print("\n账户1交易历史:")
for transaction in account1.transaction_history:
    print(f"  {transaction}")
```

### 3.2 继承

```python
# ========== 继承的基本概念 ==========
"""
继承（Inheritance）允许一个类继承另一个类的属性和方法
被继承的类称为父类（基类、超类）
继承的类称为子类（派生类）

优点：
1. 代码重用 - 子类可以复用父类的代码
2. 扩展功能 - 子类可以添加新的属性和方法
3. 建立类之间的关系 - 表达"是一个"的关系
"""

class Animal:
    """动物基类"""
    
    def __init__(self, name, age):
        self.name = name
        self.age = age
        self.is_alive = True
    
    def eat(self):
        return f"{self.name} 在吃东西"
    
    def sleep(self):
        return f"{self.name} 在睡觉"
    
    def make_sound(self):
        return "动物发出声音"
    
    def get_info(self):
        return f"{self.name} 是一只 {self.age} 岁的动物"

# ========== 单继承 ==========
class Dog(Animal):
    """狗类继承自动物类"""
    
    def __init__(self, name, age, breed):
        # 调用父类的初始化方法
        super().__init__(name, age)
        self.breed = breed  # 狗特有的属性
    
    # 重写父类方法 - 狗有自己独特的叫声
    def make_sound(self):
        return f"{self.name} 在汪汪叫！"
    
    # 子类特有的方法
    def fetch(self):
        return f"{self.name} 在接飞盘"

class Cat(Animal):
    """猫类继承自动物类"""
    
    def __init__(self, name, age, color):
        super().__init__(name, age)
        self.color = color
    
    def make_sound(self):
        return f"{self.name} 在喵喵叫！"
    
    def climb_tree(self):
        return f"{self.name} 在爬树"

# 使用继承的类
dog = Dog("Buddy", 3, "金毛")
cat = Cat("Whiskers", 2, "橘色")

print(dog.get_info())  # 继承自Animal
print(dog.make_sound())  # 重写的方法
print(dog.fetch())  # 子类特有的方法

print(cat.get_info())
print(cat.make_sound())
print(cat.climb_tree())

# 检查继承关系
print(f"dog是Dog的实例吗？: {isinstance(dog, Dog)}")
print(f"dog是Animal的实例吗？: {isinstance(dog, Animal)}")
print(f"Dog是Animal的子类吗？: {issubclass(Dog, Animal)}")

# ========== 多重继承 ==========
class Flyable:
    """可飞行能力"""
    
    def __init__(self, max_altitude=1000):
        self.max_altitude = max_altitude
    
    def fly(self):
        return f"飞行中，最高海拔: {self.max_altitude}米"
    
    def land(self):
        return "已降落"

class Swimmable:
    """可游泳能力"""
    
    def __init__(self, max_depth=10):
        self.max_depth = max_depth
    
    def swim(self):
        return f"游泳中，最大深度: {self.max_depth}米"
    
    def dive(self):
        return "潜水"

class Duck(Animal, Flyable, Swimmable):
    """鸭子类 - 多重继承（既是动物，又能飞，又能游泳）"""
    
    def __init__(self, name, age):
        Animal.__init__(self, name, age)
        Flyable.__init__(self, 500)  # 鸭子飞行高度有限
        Swimmable.__init__(self, 5)  # 鸭子潜水深度有限
    
    def make_sound(self):
        return f"{self.name} 在嘎嘎叫！"
    
    def all_abilities(self):
        """展示所有能力"""
        abilities = [
            self.eat(),
            self.sleep(),
            self.make_sound(),
            self.fly(),
            self.swim()
        ]
        return "\n".join(abilities)

# 使用多重继承的类
duck = Duck("Donald", 1)
print(duck.all_abilities())

# 查看方法解析顺序（MRO）- Python如何决定调用哪个父类的方法
print("Duck类的MRO:", Duck.__mro__)

# ========== 方法重写和super() ==========
class Vehicle:
    """交通工具基类"""
    
    def __init__(self, brand, model, year):
        self.brand = brand
        self.model = model
        self.year = year
        self.speed = 0
    
    def start(self):
        return f"{self.brand} {self.model} 启动"
    
    def stop(self):
        self.speed = 0
        return f"{self.brand} {self.model} 停止"
    
    def accelerate(self, increment):
        self.speed += increment
        return f"加速到 {self.speed} km/h"

class ElectricCar(Vehicle):
    """电动汽车 - 重写方法"""
    
    def __init__(self, brand, model, year, battery_capacity):
        # 调用父类的__init__
        super().__init__(brand, model, year)
        self.battery_capacity = battery_capacity
        self.battery_level = 100  # 百分比
    
    # 重写start方法 - 电动汽车启动方式不同
    def start(self):
        if self.battery_level > 0:
            return f"{self.brand} {self.model} 电动启动（电池: {self.battery_level}%）"
        else:
            return "电池电量不足，无法启动"
    
    # 重写accelerate方法，添加电池消耗
    def accelerate(self, increment):
        if self.battery_level <= 0:
            return "电池电量不足，无法加速"
        
        result = super().accelerate(increment)  # 调用父类方法
        # 电动汽车加速消耗电池
        battery_consumption = increment * 0.1
        self.battery_level = max(0, self.battery_level - battery_consumption)
        
        return f"{result}，电池剩余: {self.battery_level:.1f}%"
    
    # 电动汽车特有的方法
    def charge(self, amount):
        """充电"""
        self.battery_level = min(100, self.battery_level + amount)
        return f"已充电，电池: {self.battery_level}%"

# 使用方法重写
electric_car = ElectricCar("Tesla", "Model S", 2023, 100)
print(electric_car.start())
print(electric_car.accelerate(50))
print(electric_car.accelerate(30))
print(electric_car.charge(20))
print(electric_car.accelerate(20))
```

### 3.3 多态

```python
# ========== 多态的基本概念 ==========
"""
多态（Polymorphism）指同一个方法在不同类中有不同的实现
"一个接口，多种实现"

多态的优点：
1. 提高代码的灵活性 - 可以处理不同类型的对象
2. 提高代码的可扩展性 - 添加新类时不需要修改现有代码
3. 接口统一，使用方便 - 使用者不需要知道具体类型
"""

class Shape:
    """形状基类"""
    
    def area(self):
        """计算面积（抽象方法）"""
        raise NotImplementedError("子类必须实现area方法")
    
    def perimeter(self):
        """计算周长（抽象方法）"""
        raise NotImplementedError("子类必须实现perimeter方法")

class Rectangle(Shape):
    """矩形"""
    
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height
    
    def perimeter(self):
        return 2 * (self.width + self.height)

class Circle(Shape):
    """圆形"""
    
    def __init__(self, radius):
        self.radius = radius
    
    def area(self):
        return 3.14159 * self.radius ** 2
    
    def perimeter(self):
        return 2 * 3.14159 * self.radius

class Triangle(Shape):
    """三角形"""
    
    def __init__(self, a, b, c):
        self.a = a
        self.b = b
        self.c = c
    
    def area(self):
        # 使用海伦公式计算三角形面积
        s = self.perimeter() / 2
        return (s * (s - self.a) * (s - self.b) * (s - self.c)) ** 0.5
    
    def perimeter(self):
        return self.a + self.b + self.c

# ========== 多态的使用 ==========
def print_shape_info(shape):
    """打印形状信息 - 接受任何Shape子类，这就是多态"""
    if not isinstance(shape, Shape):
        raise TypeError("参数必须是Shape类型")
    
    print(f"面积: {shape.area():.2f}")
    print(f"周长: {shape.perimeter():.2f}")
    print("-" * 20)

# 创建不同形状的对象
shapes = [
    Rectangle(5, 3),
    Circle(4),
    Triangle(3, 4, 5)
]

# 统一处理不同形状 - 多态的体现：同一函数处理不同类型
print("不同形状的信息:")
for shape in shapes:
    print_shape_info(shape)

# ========== 鸭子类型 ==========
"""
鸭子类型（Duck Typing）：
"如果它走起来像鸭子，叫起来像鸭子，那么它就是鸭子"
在Python中，不关心对象的类型，只关心对象是否有需要的方法
"""

class FileReader:
    """文件读取器"""
    
    def read(self):
        return "从文件读取数据"

class DatabaseReader:
    """数据库读取器"""
    
    def read(self):
        return "从数据库读取数据"

class APIReader:
    """API读取器"""
    
    def read(self):
        return "从API读取数据"

def process_data(reader):
    """处理数据 - 不关心reader的具体类型，只关心它有read方法"""
    if hasattr(reader, 'read') and callable(reader.read):
        data = reader.read()
        return f"处理: {data}"
    else:
        raise TypeError("reader必须有read方法")

# 使用鸭子类型 - 只要对象有read方法就可以处理
readers = [FileReader(), DatabaseReader(), APIReader()]

print("使用鸭子类型处理不同数据源:")
for reader in readers:
    print(process_data(reader))

# ========== 运算符重载 ==========
class Vector:
    """向量类演示运算符重载"""
    
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __str__(self):
        """字符串表示 - 使用print时调用"""
        return f"Vector({self.x}, {self.y})"
    
    def __repr__(self):
        """解释器表示 - 在交互式环境显示"""
        return f"Vector({self.x}, {self.y})"
    
    def __add__(self, other):
        """向量加法 + """
        if isinstance(other, Vector):
            return Vector(self.x + other.x, self.y + other.y)
        else:
            raise TypeError("只能与Vector相加")
    
    def __sub__(self, other):
        """向量减法 - """
        if isinstance(other, Vector):
            return Vector(self.x - other.x, self.y - other.y)
        else:
            raise TypeError("只能与Vector相减")
    
    def __mul__(self, scalar):
        """向量数乘 * """
        if isinstance(scalar, (int, float)):
            return Vector(self.x * scalar, self.y * scalar)
        else:
            raise TypeError("只能与标量相乘")
    
    def __rmul__(self, scalar):
        """右乘（标量 * 向量）"""
        return self.__mul__(scalar)
    
    def __eq__(self, other):
        """相等比较 == """
        if isinstance(other, Vector):
            return self.x == other.x and self.y == other.y
        return False
    
    def __abs__(self):
        """向量的模 - 使用abs()函数时调用"""
        return (self.x ** 2 + self.y ** 2) ** 0.5
    
    def dot(self, other):
        """点积"""
        if isinstance(other, Vector):
            return self.x * other.x + self.y * other.y
        else:
            raise TypeError("只能与Vector计算点积")

# 使用运算符重载 - 让自定义类支持数学运算
v1 = Vector(2, 3)
v2 = Vector(1, 4)

print(f"v1 = {v1}")
print(f"v2 = {v2}")
print(f"v1 + v2 = {v1 + v2}")
print(f"v1 - v2 = {v1 - v2}")
print(f"v1 * 3 = {v1 * 3}")
print(f"2 * v2 = {2 * v2}")
print(f"v1 == v2 ? {v1 == v2}")
print(f"|v1| = {abs(v1):.2f}")
print(f"v1 · v2 = {v1.dot(v2)}")
```

## 4. 特殊方法和高级特性

### 4.1 魔术方法

```python
# ========== 构造和析构方法 ==========
class Resource:
    """资源管理类演示构造和析构"""
    
    def __init__(self, name):
        """构造函数 - 创建对象时自动调用"""
        self.name = name
        self.is_open = False
        self.open_resource()
        print(f"创建 {self.name} 资源")
    
    def __del__(self):
        """析构函数 - 对象被销毁时调用（不推荐依赖，最好显式清理）"""
        self.close_resource()
        print(f"清理 {self.name} 资源")
    
    def open_resource(self):
        """打开资源"""
        if not self.is_open:
            self.is_open = True
            print(f"打开 {self.name} 资源")
    
    def close_resource(self):
        """关闭资源"""
        if self.is_open:
            self.is_open = False
            print(f"关闭 {self.name} 资源")
    
    def __enter__(self):
        """上下文管理器入口 - 使用with语句时调用"""
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """上下文管理器出口 - with语句结束时调用"""
        self.close_resource()
        if exc_type:
            print(f"发生错误: {exc_val}")
        return False  # 不抑制异常

# 使用构造和析构
print("创建资源:")
resource = Resource("数据库连接")

print("\n使用上下文管理器（推荐）:")
with Resource("文件句柄") as file_resource:
    print(f"使用 {file_resource.name}")

print("\n程序结束")

# ========== 字符串表示方法 ==========
class Person:
    """人类演示字符串表示方法"""
    
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def __str__(self):
        """用户友好的字符串表示 - 使用print和str()时调用"""
        return f"Person: {self.name}, {self.age}岁"
    
    def __repr__(self):
        """开发者友好的字符串表示 - 在交互式环境和调试时显示"""
        return f"Person('{self.name}', {self.age})"
    
    def __format__(self, format_spec):
        """格式化输出 - 使用format()和f-string时调用"""
        if format_spec == "short":
            return f"{self.name}({self.age})"
        elif format_spec == "long":
            return f"姓名: {self.name}, 年龄: {self.age}"
        else:
            return str(self)

# 使用字符串表示
person = Person("张三", 25)

print(str(person))    # 调用 __str__
print(repr(person))   # 调用 __repr__
print(f"{person}")    # 调用 __str__
print(f"{person:short}")  # 调用 __format__
print(f"{person:long}")   # 调用 __format__

# ========== 比较运算符重载 ==========
class Money:
    """货币类演示比较运算符"""
    
    def __init__(self, amount, currency="USD"):
        self.amount = amount
        self.currency = currency
    
    def __eq__(self, other):
        """等于 == """
        if isinstance(other, Money):
            return self.amount == other.amount and self.currency == other.currency
        return False
    
    def __ne__(self, other):
        """不等于 != """
        return not self.__eq__(other)
    
    def __lt__(self, other):
        """小于 < """
        if isinstance(other, Money) and self.currency == other.currency:
            return self.amount < other.amount
        raise ValueError("只能比较相同货币")
    
    def __le__(self, other):
        """小于等于 <= """
        if isinstance(other, Money) and self.currency == other.currency:
            return self.amount <= other.amount
        raise ValueError("只能比较相同货币")
    
    def __gt__(self, other):
        """大于 > """
        if isinstance(other, Money) and self.currency == other.currency:
            return self.amount > other.amount
        raise ValueError("只能比较相同货币")
    
    def __ge__(self, other):
        """大于等于 >= """
        if isinstance(other, Money) and self.currency == other.currency:
            return self.amount >= other.amount
        raise ValueError("只能比较相同货币")
    
    def __str__(self):
        return f"{self.amount} {self.currency}"

# 使用比较运算符
money1 = Money(100, "USD")
money2 = Money(150, "USD")
money3 = Money(100, "USD")

print(f"money1: {money1}")
print(f"money2: {money2}")
print(f"money3: {money3}")

print(f"money1 == money2: {money1 == money2}")
print(f"money1 == money3: {money1 == money3}")
print(f"money1 != money2: {money1 != money2}")
print(f"money1 < money2: {money1 < money2}")
print(f"money1 <= money2: {money1 <= money2}")
print(f"money1 > money2: {money1 > money2}")
print(f"money1 >= money2: {money1 >= money2}")

# ========== 数值运算方法 ==========
class Fraction:
    """分数类演示数值运算"""
    
    def __init__(self, numerator, denominator=1):
        if denominator == 0:
            raise ValueError("分母不能为零")
        self.numerator = numerator
        self.denominator = denominator
        self._simplify()
    
    def _simplify(self):
        """简化分数"""
        import math
        gcd = math.gcd(self.numerator, self.denominator)
        self.numerator //= gcd
        self.denominator //= gcd
        
        # 确保分母为正
        if self.denominator < 0:
            self.numerator = -self.numerator
            self.denominator = -self.denominator
    
    def __add__(self, other):
        """加法 + """
        if isinstance(other, Fraction):
            new_numerator = (self.numerator * other.denominator + 
                           other.numerator * self.denominator)
            new_denominator = self.denominator * other.denominator
            return Fraction(new_numerator, new_denominator)
        elif isinstance(other, int):
            return self + Fraction(other)
        else:
            return NotImplemented
    
    def __sub__(self, other):
        """减法 - """
        if isinstance(other, Fraction):
            new_numerator = (self.numerator * other.denominator - 
                           other.numerator * self.denominator)
            new_denominator = self.denominator * other.denominator
            return Fraction(new_numerator, new_denominator)
        elif isinstance(other, int):
            return self - Fraction(other)
        else:
            return NotImplemented
    
    def __mul__(self, other):
        """乘法 * """
        if isinstance(other, Fraction):
            return Fraction(self.numerator * other.numerator, 
                          self.denominator * other.denominator)
        elif isinstance(other, int):
            return Fraction(self.numerator * other, self.denominator)
        else:
            return NotImplemented
    
    def __truediv__(self, other):
        """除法 / """
        if isinstance(other, Fraction):
            return Fraction(self.numerator * other.denominator, 
                          self.denominator * other.numerator)
        elif isinstance(other, int):
            return Fraction(self.numerator, self.denominator * other)
        else:
            return NotImplemented
    
    def __str__(self):
        if self.denominator == 1:
            return str(self.numerator)
        else:
            return f"{self.numerator}/{self.denominator}"
    
    def __repr__(self):
        return f"Fraction({self.numerator}, {self.denominator})"

# 使用分数运算
f1 = Fraction(1, 2)
f2 = Fraction(3, 4)

print(f"f1 = {f1}")
print(f"f2 = {f2}")
print(f"f1 + f2 = {f1 + f2}")
print(f"f1 - f2 = {f1 - f2}")
print(f"f1 * f2 = {f1 * f2}")
print(f"f1 / f2 = {f1 / f2}")
print(f"f1 + 1 = {f1 + 1}")
print(f"f1 * 2 = {f1 * 2}")
```

### 4.2 高级特性

```python
# ========== 抽象基类 ==========
from abc import ABC, abstractmethod
from math import pi

class Shape(ABC):
    """形状抽象基类 - 不能直接实例化，只能被继承"""
    
    @abstractmethod
    def area(self):
        """计算面积 - 子类必须实现"""
        pass
    
    @abstractmethod
    def perimeter(self):
        """计算周长 - 子类必须实现"""
        pass
    
    def description(self):
        """具体方法 - 抽象基类也可以有具体实现"""
        return "这是一个形状"

class Circle(Shape):
    """圆形 - 必须实现所有抽象方法"""
    
    def __init__(self, radius):
        self.radius = radius
    
    def area(self):
        return pi * self.radius ** 2
    
    def perimeter(self):
        return 2 * pi * self.radius

class Rectangle(Shape):
    """矩形 - 必须实现所有抽象方法"""
    
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height
    
    def perimeter(self):
        return 2 * (self.width + self.height)

# 使用抽象基类
circle = Circle(5)
rectangle = Rectangle(4, 6)

print(f"圆形面积: {circle.area():.2f}")
print(f"矩形面积: {rectangle.area()}")
print(f"圆形描述: {circle.description()}")

# 不能直接实例化抽象基类
try:
    shape = Shape()
except TypeError as e:
    print(f"错误: {e}")

# ========== 类装饰器 ==========
def singleton(cls):
    """单例装饰器 - 确保一个类只有一个实例"""
    instances = {}
    
    def get_instance(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]
    
    return get_instance

def debug_methods(cls):
    """调试装饰器 - 为所有方法添加调试信息"""
    for attr_name, attr_value in cls.__dict__.items():
        if callable(attr_value):
            setattr(cls, attr_name, _add_debugging(attr_value, attr_name))
    return cls

def _add_debugging(method, method_name):
    """为方法添加调试功能"""
    def wrapper(*args, **kwargs):
        print(f"调用方法: {method_name}")
        print(f"参数: {args}, {kwargs}")
        result = method(*args, **kwargs)
        print(f"返回值: {result}")
        return result
    return wrapper

@singleton
class DatabaseConnection:
    """数据库连接单例"""
    
    def __init__(self):
        print("创建数据库连接")
        self.connected = True
    
    def query(self, sql):
        return f"执行查询: {sql}"

@debug_methods
class Calculator:
    """带调试的计算器"""
    
    def add(self, a, b):
        return a + b
    
    def multiply(self, a, b):
        return a * b

# 使用装饰器
print("=== 单例模式 ===")
db1 = DatabaseConnection()
db2 = DatabaseConnection()
print(f"是同一个实例吗？: {db1 is db2}")

print("\n=== 调试装饰器 ===")
calc = Calculator()
calc.add(5, 3)
calc.multiply(4, 6)

# ========== 数据类 ==========
from dataclasses import dataclass, field
from typing import List, ClassVar

@dataclass
class Product:
    """产品数据类 - 自动生成__init__、__repr__等方法"""
    
    # 实例字段
    name: str
    price: float
    description: str = "暂无描述"
    tags: List[str] = field(default_factory=list)
    
    # 类字段
    currency: ClassVar[str] = "USD"
    
    def total_cost(self, quantity: int) -> float:
        """计算总成本"""
        return self.price * quantity
    
    def add_tag(self, tag: str):
        """添加标签"""
        self.tags.append(tag)

@dataclass(order=True)  # 自动生成比较方法
class Person:
    """人员数据类（可排序）"""
    
    name: str
    age: int
    email: str = ""

# 使用数据类
product = Product("笔记本电脑", 999.99, "高性能笔记本电脑")
product.add_tag("电子")
product.add_tag("电脑")

print(f"产品: {product.name}")
print(f"价格: {product.price} {Product.currency}")
print(f"描述: {product.description}")
print(f"标签: {product.tags}")
print(f"3台总价: {product.total_cost(3):.2f}")

# 数据类自动生成的方法
person1 = Person("Alice", 25, "alice@example.com")
person2 = Person("Bob", 30)
person3 = Person("Alice", 25, "alice@example.com")

print(f"person1: {person1}")
print(f"person1 == person3: {person1 == person3}")
print(f"person1 < person2: {person1 < person2}")

# ========== 枚举类 ==========
from enum import Enum, auto

class Color(Enum):
    """颜色枚举"""
    RED = 1
    GREEN = 2
    BLUE = 3
    YELLOW = auto()  # 自动分配值

class Status(Enum):
    """状态枚举"""
    PENDING = "pending"
    PROCESSING = "processing"
    COMPLETED = "completed"
    FAILED = "failed"

class Direction(Enum):
    """方向枚举（有值和方法）"""
    NORTH = (0, 1)
    SOUTH = (0, -1)
    EAST = (1, 0)
    WEST = (-1, 0)
    
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def move(self, point, distance=1):
        """移动点"""
        return (point[0] + self.x * distance, point[1] + self.y * distance)

# 使用枚举
print("=== 颜色枚举 ===")
for color in Color:
    print(f"{color.name}: {color.value}")

print("\n=== 状态枚举 ===")
current_status = Status.PROCESSING
print(f"当前状态: {current_status.value}")

print("\n=== 方向枚举 ===")
point = (0, 0)
print(f"起点: {point}")
point = Direction.NORTH.move(point, 2)
print(f"向北移动2步: {point}")
point = Direction.EAST.move(point, 3)
print(f"向东移动3步: {point}")
```

## 5. 设计模式和最佳实践

### 5.1 常用设计模式

```python
# ========== 工厂模式 ==========
class PaymentMethod:
    """支付方法基类"""
    
    def process_payment(self, amount):
        raise NotImplementedError

class CreditCardPayment(PaymentMethod):
    def process_payment(self, amount):
        return f"信用卡支付 {amount} 元"

class AlipayPayment(PaymentMethod):
    def process_payment(self, amount):
        return f"支付宝支付 {amount} 元"

class WechatPayment(PaymentMethod):
    def process_payment(self, amount):
        return f"微信支付 {amount} 元"

class PaymentFactory:
    """支付工厂 - 负责创建支付对象"""
    
    @staticmethod
    def create_payment(method):
        methods = {
            'credit_card': CreditCardPayment,
            'alipay': AlipayPayment,
            'wechat': WechatPayment
        }
        
        payment_class = methods.get(method)
        if payment_class:
            return payment_class()
        else:
            raise ValueError(f"不支持的支付方式: {method}")

# 使用工厂模式 - 客户端不需要知道具体实现类
payment_methods = ['credit_card', 'alipay', 'wechat']
amount = 100

for method in payment_methods:
    try:
        payment = PaymentFactory.create_payment(method)
        print(payment.process_payment(amount))
    except ValueError as e:
        print(e)

# ========== 观察者模式 ==========
class Subject:
    """主题（被观察者）"""
    
    def __init__(self):
        self._observers = []
    
    def attach(self, observer):
        """添加观察者"""
        if observer not in self._observers:
            self._observers.append(observer)
    
    def detach(self, observer):
        """移除观察者"""
        try:
            self._observers.remove(observer)
        except ValueError:
            pass
    
    def notify(self, message):
        """通知所有观察者"""
        for observer in self._observers:
            observer.update(message)

class Observer:
    """观察者基类"""
    
    def update(self, message):
        raise NotImplementedError

class EmailNotifier(Observer):
    def update(self, message):
        print(f"邮件通知: {message}")

class SMSNotifier(Observer):
    def update(self, message):
        print(f"短信通知: {message}")

class AppNotifier(Observer):
    def update(self, message):
        print(f"App通知: {message}")

# 使用观察者模式 - 实现发布-订阅机制
subject = Subject()

# 创建观察者
email_notifier = EmailNotifier()
sms_notifier = SMSNotifier()
app_notifier = AppNotifier()

# 注册观察者
subject.attach(email_notifier)
subject.attach(sms_notifier)
subject.attach(app_notifier)

# 通知观察者
print("=== 第一次通知 ===")
subject.notify("系统维护通知")

# 移除一个观察者
subject.detach(sms_notifier)

print("\n=== 第二次通知 ===")
subject.notify("系统更新完成")

# ========== 策略模式 ==========
class SortStrategy:
    """排序策略基类"""
    
    def sort(self, data):
        raise NotImplementedError

class BubbleSort(SortStrategy):
    def sort(self, data):
        # 简化版的冒泡排序
        sorted_data = data.copy()
        n = len(sorted_data)
        for i in range(n):
            for j in range(0, n - i - 1):
                if sorted_data[j] > sorted_data[j + 1]:
                    sorted_data[j], sorted_data[j + 1] = sorted_data[j + 1], sorted_data[j]
        return sorted_data

class QuickSort(SortStrategy):
    def sort(self, data):
        # 简化版的快速排序
        if len(data) <= 1:
            return data
        pivot = data[len(data) // 2]
        left = [x for x in data if x < pivot]
        middle = [x for x in data if x == pivot]
        right = [x for x in data if x > pivot]
        return self.sort(left) + middle + self.sort(right)

class Sorter:
    """排序器 - 可以动态切换排序策略"""
    
    def __init__(self, strategy=None):
        self._strategy = strategy or BubbleSort()
    
    def set_strategy(self, strategy):
        """设置排序策略"""
        self._strategy = strategy
    
    def sort(self, data):
        """执行排序"""
        return self._strategy.sort(data)

# 使用策略模式 - 可以在运行时切换算法
data = [64, 34, 25, 12, 22, 11, 90]
sorter = Sorter()

print("原始数据:", data)

# 使用冒泡排序
sorter.set_strategy(BubbleSort())
print("冒泡排序:", sorter.sort(data))

# 使用快速排序
sorter.set_strategy(QuickSort())
print("快速排序:", sorter.sort(data))
```

### 5.2 最佳实践

```python
# ========== 组合优于继承 ==========
class Engine:
    """发动机"""
    
    def start(self):
        return "发动机启动"
    
    def stop(self):
        return "发动机停止"

class Wheels:
    """车轮"""
    
    def __init__(self, count=4):
        self.count = count
    
    def rotate(self):
        return f"{self.count}个车轮旋转"

class Car:
    """汽车 - 使用组合而非继承"""
    
    def __init__(self):
        self.engine = Engine()  # 组合：汽车有发动机
        self.wheels = Wheels()  # 组合：汽车有车轮
        self._is_running = False
    
    def start(self):
        if not self._is_running:
            self._is_running = True
            return f"{self.engine.start()}, {self.wheels.rotate()}"
        return "汽车已经在运行"
    
    def stop(self):
        if self._is_running:
            self._is_running = False
            return self.engine.stop()
        return "汽车已经停止"

# 使用组合 - 更灵活，避免继承的复杂性
car = Car()
print(car.start())
print(car.stop())

# ========== 单一职责原则 ==========
# 违反单一职责原则的类 - 一个类做了太多事情
class BadUser:
    """违反单一职责原则的用户类"""
    
    def __init__(self, username, email):
        self.username = username
        self.email = email
    
    def authenticate(self, password):
        # 认证逻辑
        pass
    
    def save_to_database(self):
        # 数据库保存逻辑
        pass
    
    def send_email(self, subject, message):
        # 发送邮件逻辑
        pass
    
    def generate_report(self):
        # 生成报告逻辑
        pass

# 遵循单一职责原则的类 - 每个类只负责一个功能
class User:
    """用户类 - 只负责用户数据"""
    
    def __init__(self, username, email):
        self.username = username
        self.email = email

class UserAuthenticator:
    """用户认证类 - 只负责认证"""
    
    @staticmethod
    def authenticate(user, password):
        # 认证逻辑
        return True

class UserRepository:
    """用户数据存储类 - 只负责数据存储"""
    
    @staticmethod
    def save(user):
        # 数据库保存逻辑
        return True
    
    @staticmethod
    def find_by_username(username):
        # 查找用户逻辑
        return User(username, f"{username}@example.com")

class EmailService:
    """邮件服务类 - 只负责发送邮件"""
    
    @staticmethod
    def send_email(to, subject, message):
        # 发送邮件逻辑
        return True

class ReportGenerator:
    """报告生成类 - 只负责生成报告"""
    
    @staticmethod
    def generate_user_report(user):
        # 生成用户报告逻辑
        return f"用户 {user.username} 的报告"

# 使用遵循单一职责原则的类 - 更易于维护和测试
user = User("alice", "alice@example.com")
UserRepository.save(user)

if UserAuthenticator.authenticate(user, "password"):
    EmailService.send_email(user.email, "欢迎", "欢迎使用我们的服务")
    report = ReportGenerator.generate_user_report(user)
    print(report)

# ========== 依赖注入 ==========
class Database:
    """数据库类"""
    
    def execute(self, query):
        return f"执行查询: {query}"

class UserService:
    """用户服务类 - 通过依赖注入使用数据库"""
    
    def __init__(self, database):
        self.database = database  # 依赖注入：从外部传入依赖
    
    def get_user(self, user_id):
        query = f"SELECT * FROM users WHERE id = {user_id}"
        return self.database.execute(query)
    
    def create_user(self, username, email):
        query = f"INSERT INTO users (username, email) VALUES ('{username}', '{email}')"
        return self.database.execute(query)

# 使用依赖注入 - 提高可测试性和灵活性
database = Database()
user_service = UserService(database)  # 注入依赖

print(user_service.get_user(1))
print(user_service.create_user("bob", "bob@example.com"))

# ========== 不可变对象 ==========
from dataclasses import dataclass
from typing import Tuple

@dataclass(frozen=True)  # 不可变数据类
class ImmutablePoint:
    """不可变点 - 创建后不能修改"""
    
    x: float
    y: float
    
    def move(self, dx=0, dy=0):
        """移动点 - 返回新对象而不是修改原对象"""
        return ImmutablePoint(self.x + dx, self.y + dy)
    
    def distance_to(self, other):
        """计算到另一个点的距离"""
        return ((self.x - other.x) ** 2 + (self.y - other.y) ** 2) ** 0.5

# 使用不可变对象 - 线程安全，更易于推理
point1 = ImmutablePoint(0, 0)
point2 = point1.move(3, 4)

print(f"点1: ({point1.x}, {point1.y})")
print(f"点2: ({point2.x}, {point2.y})")
print(f"距离: {point1.distance_to(point2):.2f}")

# 尝试修改不可变对象会报错
try:
    point1.x = 5  # 会抛出异常
except Exception as e:
    print(f"错误: {e}")
```

## 6. 调试和测试

### 6.1 类调试技巧

```python
# ========== 查看类信息 ==========
class DebugClass:
    """调试示例类"""
    
    class_var = "类变量"
    
    def __init__(self, value):
        self.instance_var = value
        self._protected_var = "保护变量"
        self.__private_var = "私有变量"
    
    def public_method(self):
        return "公开方法"
    
    def _protected_method(self):
        return "保护方法"
    
    def __private_method(self):
        return "私有方法"
    
    @classmethod
    def class_method(cls):
        return "类方法"
    
    @staticmethod
    def static_method():
        return "静态方法"

# 创建实例
obj = DebugClass("实例值")

# 查看类的各种信息 - 调试时很有用
print("=== 类信息 ===")
print(f"类名: {DebugClass.__name__}")
print(f"模块: {DebugClass.__module__}")
print(f"文档: {DebugClass.__doc__}")
print(f"基类: {DebugClass.__bases__}")

print("\n=== 实例信息 ===")
print(f"实例字典: {obj.__dict__}")
print(f"类字典: {DebugClass.__dict__.keys()}")

print("\n=== 方法解析顺序 ===")
print(f"MRO: {DebugClass.__mro__}")

print("\n=== 所有属性 ===")
print("所有属性（包括继承的）:")
for attr in dir(obj):
    print(f"  {attr}")

print("\n=== 实例属性 ===")
print("实例自有属性:")
for attr, value in obj.__dict__.items():
    print(f"  {attr}: {value}")

# ========== 属性访问跟踪 ==========
class TraceAccess:
    """跟踪属性访问 - 用于调试属性访问问题"""
    
    def __init__(self):
        self._values = {}
    
    def __getattr__(self, name):
        """访问不存在的属性时调用"""
        print(f"访问不存在的属性: {name}")
        return None
    
    def __setattr__(self, name, value):
        """设置属性时调用"""
        print(f"设置属性: {name} = {value}")
        super().__setattr__(name, value)
    
    def __getattribute__(self, name):
        """访问任何属性时调用"""
        print(f"访问属性: {name}")
        return super().__getattribute__(name)

# 测试属性访问跟踪 - 了解属性访问的详细过程
print("\n=== 属性访问跟踪 ===")
trace_obj = TraceAccess()
trace_obj.existing = "现有值"  # 调用 __setattr__
print(trace_obj.existing)     # 调用 __getattribute__
print(trace_obj.nonexistent)  # 调用 __getattribute__ 和 __getattr__

# ========== 自定义异常 ==========
class ValidationError(Exception):
    """自定义验证异常 - 提供更详细的错误信息"""
    
    def __init__(self, message, field=None, value=None):
        super().__init__(message)
        self.field = field
        self.value = value
        self.message = message
    
    def __str__(self):
        if self.field:
            return f"字段 '{self.field}' 验证失败: {self.message} (值: {self.value})"
        return self.message

class UserValidator:
    """用户验证器"""
    
    @staticmethod
    def validate_username(username):
        if not username:
            raise ValidationError("用户名不能为空", "username", username)
        if len(username) < 3:
            raise ValidationError("用户名至少3个字符", "username", username)
        if len(username) > 20:
            raise ValidationError("用户名最多20个字符", "username", username)
        return True
    
    @staticmethod
    def validate_email(email):
        if not email:
            raise ValidationError("邮箱不能为空", "email", email)
        if "@" not in email:
            raise ValidationError("邮箱格式不正确", "email", email)
        return True

# 测试自定义异常 - 提供更友好的错误信息
test_cases = [
    ("", "alice@example.com"),
    ("ab", "alice@example.com"),
    ("validuser", "invalid-email")
]

for username, email in test_cases:
    try:
        UserValidator.validate_username(username)
        UserValidator.validate_email(email)
        print(f"验证成功: {username}, {email}")
    except ValidationError as e:
        print(f"验证失败: {e}")
```

### 6.2 单元测试

```python
# ========== 简单的单元测试 ==========
import unittest
from unittest.mock import Mock, patch

class Calculator:
    """简单的计算器类"""
    
    def add(self, a, b):
        return a + b
    
    def subtract(self, a, b):
        return a - b
    
    def multiply(self, a, b):
        return a * b
    
    def divide(self, a, b):
        if b == 0:
            raise ValueError("除数不能为零")
        return a / b

class TestCalculator(unittest.TestCase):
    """计算器测试类"""
    
    def setUp(self):
        """每个测试方法前执行 - 准备测试环境"""
        self.calc = Calculator()
    
    def tearDown(self):
        """每个测试方法后执行 - 清理测试环境"""
        pass
    
    def test_add(self):
        """测试加法"""
        self.assertEqual(self.calc.add(2, 3), 5)
        self.assertEqual(self.calc.add(-1, 1), 0)
        self.assertEqual(self.calc.add(0, 0), 0)
    
    def test_subtract(self):
        """测试减法"""
        self.assertEqual(self.calc.subtract(5, 3), 2)
        self.assertEqual(self.calc.subtract(0, 5), -5)
    
    def test_multiply(self):
        """测试乘法"""
        self.assertEqual(self.calc.multiply(3, 4), 12)
        self.assertEqual(self.calc.multiply(0, 5), 0)
    
    def test_divide(self):
        """测试除法"""
        self.assertEqual(self.calc.divide(6, 3), 2)
        self.assertEqual(self.calc.divide(5, 2), 2.5)
    
    def test_divide_by_zero(self):
        """测试除零异常"""
        with self.assertRaises(ValueError):
            self.calc.divide(5, 0)

# 运行测试
if __name__ == '__main__':
    unittest.main()

# ========== 模拟测试 ==========
class WeatherService:
    """天气服务 - 可能调用外部API"""
    
    def get_temperature(self, city):
        # 假设这是调用外部API
        raise NotImplementedError("需要实际实现")

class OutfitRecommender:
    """衣着推荐器"""
    
    def __init__(self, weather_service):
        self.weather_service = weather_service
    
    def recommend_outfit(self, city):
        temp = self.weather_service.get_temperature(city)
        
        if temp > 25:
            return "短袖和短裤"
        elif temp > 15:
            return "长袖和长裤"
        else:
            return "外套和长裤"

class TestOutfitRecommender(unittest.TestCase):
    """衣着推荐器测试"""
    
    def test_recommend_outfit_hot(self):
        """测试炎热天气推荐"""
        # 创建模拟对象 - 避免调用真实的外部服务
        mock_weather = Mock(spec=WeatherService)
        mock_weather.get_temperature.return_value = 30
        
        recommender = OutfitRecommender(mock_weather)
        outfit = recommender.recommend_outfit("Beijing")
        
        self.assertEqual(outfit, "短袖和短裤")
        mock_weather.get_temperature.assert_called_once_with("Beijing")
    
    def test_recommend_outfit_cold(self):
        """测试寒冷天气推荐"""
        mock_weather = Mock()
        mock_weather.get_temperature.return_value = 10
        
        recommender = OutfitRecommender(mock_weather)
        outfit = recommender.recommend_outfit("Harbin")
        
        self.assertEqual(outfit, "外套和长裤")

# ========== 测试覆盖率 ==========
"""
可以使用 coverage.py 来测量测试覆盖率：
1. 安装: pip install coverage
2. 运行测试: coverage run -m unittest test_module.py
3. 生成报告: coverage report
4. 生成HTML报告: coverage html

测试覆盖率帮助了解哪些代码没有被测试到
"""

# ========== 性能测试 ==========
import time

class PerformanceTest(unittest.TestCase):
    """性能测试示例"""
    
    def test_performance(self):
        """测试性能"""
        start_time = time.time()
        
        # 执行需要测试的代码
        result = 0
        for i in range(1000000):
            result += i
        
        end_time = time.time()
        execution_time = end_time - start_time
        
        # 断言执行时间在合理范围内
        self.assertLess(execution_time, 1.0, "执行时间过长")
        print(f"执行时间: {execution_time:.4f}秒")
```

## 总结

Python面向对象编程是构建复杂应用程序的基础。通过深入理解和应用这些概念，你可以设计出结构清晰、易于维护、可扩展的面向对象程序。

### 核心概念：
1. **类和对象**：类是蓝图，对象是实例。类定义了属性和方法，对象是具体的实体。
2. **属性**：类属性（所有实例共享）和实例属性（每个实例独有）。使用私有属性保护数据。
3. **方法**：实例方法（操作实例数据）、类方法（操作类数据）、静态方法（不依赖类或实例）。

### 三大特性：
1. **封装**：隐藏内部实现，提供公开接口。使用私有属性和属性装饰器保护数据完整性。
2. **继承**：代码重用和功能扩展。子类继承父类的属性和方法，可以重写或添加新功能。
3. **多态**：同一接口的不同实现。通过方法重写和鸭子类型实现，提高代码灵活性。

### 高级特性：
1. **魔术方法**：`__init__`（构造）、`__str__`（字符串表示）、运算符重载等，让自定义类更自然。
2. **属性装饰器**：`@property`（像属性一样使用方法）、`@classmethod`（类方法）、`@staticmethod`（静态方法）。
3. **抽象基类**：定义接口规范，确保子类实现必要方法。
4. **数据类**：简化数据容器创建，自动生成常用方法。

### 设计原则：
1. **单一职责**：一个类只负责一个功能，提高可维护性。
2. **开闭原则**：对扩展开放，对修改关闭，通过继承和多态实现。
3. **组合优于继承**：优先使用组合关系，降低耦合度。
4. **依赖注入**：从外部传入依赖，提高可测试性和灵活性。

### 最佳实践：
1. **命名规范**：类名使用驼峰命名法（MyClass），方法名使用蛇形命名法（my_method）。
2. **文档字符串**：为类和方法添加文档，说明用途和参数。
3. **类型提示**：提高代码可读性和可维护性，帮助IDE提供更好的支持。
4. **单元测试**：确保代码质量，便于重构和协作。

### 调试技巧：
1. 使用`dir()`、`__dict__`查看对象属性和方法
2. 使用`isinstance()`和`issubclass()`检查类型关系
3. 自定义异常提供更友好的错误信息
4. 使用单元测试和模拟对象确保代码质量

面向对象编程不仅是一种技术，更是一种思维方式。通过将现实世界的事物抽象为类和对象，可以构建出更加模块化、可重用和易于维护的代码。掌握这些概念和技巧，将大大提高你的Python编程能力。