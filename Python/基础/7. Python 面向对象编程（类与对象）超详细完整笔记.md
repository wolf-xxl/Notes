# Python面向对象编程超详细笔记

## 1. 类和对象的基本概念

### 1.1 什么是类和对象
```python
# 类：具有相同特征和行为的对象的抽象
# 对象：类的具体实例

class Dog:
    """这是一个狗类"""
    
    # 类属性：所有对象共享的属性
    species = "哺乳动物"  # 类属性
    
    def __init__(self, name, age):
        """构造方法，创建对象时自动调用"""
        # 实例属性：每个对象独有的属性
        self.name = name  # 实例属性
        self.age = age    # 实例属性
    
    def bark(self):
        """实例方法"""
        return f"{self.name}在汪汪叫！"
    
    def get_info(self):
        """实例方法"""
        return f"这只狗叫{self.name}，今年{self.age}岁"

# 创建对象（实例化）
dog1 = Dog("小黑", 3)
dog2 = Dog("小白", 2)

print(dog1.bark())        # 小黑在汪汪叫！
print(dog2.get_info())    # 这只狗叫小白，今年2岁
print(Dog.species)        # 哺乳动物
```

### 1.2 self关键字的作用
```python
class Person:
    def __init__(self, name):
        # self代表当前对象的引用
        self.name = name
    
    def introduce(self):
        # 必须要有self参数，Python会自动传递当前对象
        return f"我叫{self.name}"

person = Person("张三")
print(person.introduce())  # 我叫张三

# 实际上Python是这样调用的：
# Person.introduce(person)
```

## 2. 构造方法和析构方法

### 2.1 构造方法 __init__
```python
class Student:
    def __init__(self, name, score):
        print("构造方法被调用")
        self.name = name
        self.score = score
        self.grade = self.calculate_grade()  # 在构造方法中调用其他方法
    
    def calculate_grade(self):
        if self.score >= 90:
            return "优秀"
        elif self.score >= 80:
            return "良好"
        else:
            return "及格"

student = Student("李四", 85)
print(f"{student.name}的成绩等级是：{student.grade}")  # 李四的成绩等级是：良好
```

### 2.2 析构方法 __del__
```python
class FileHandler:
    def __init__(self, filename):
        self.filename = filename
        self.file = open(filename, 'w')
        print(f"文件 {filename} 已打开")
    
    def write_data(self, data):
        self.file.write(data)
    
    def __del__(self):
        """析构方法，对象被销毁时自动调用"""
        if hasattr(self, 'file') and self.file:
            self.file.close()
            print(f"文件 {self.filename} 已关闭")

# 测试析构方法
handler = FileHandler("test.txt")
handler.write_data("Hello, World!")

# 当对象被销毁或程序结束时，__del__会自动调用
del handler  # 删除对象，触发析构方法
# 输出：文件 test.txt 已关闭
```

## 3. 类的三大特性：封装、继承、多态

### 3.1 封装
```python
class BankAccount:
    def __init__(self, account_holder, balance=0):
        self.account_holder = account_holder
        self.__balance = balance  # 私有属性，外部不能直接访问
        self._account_type = "储蓄账户"  # 保护属性，约定俗成不要直接访问
    
    # 公有方法访问私有属性
    def get_balance(self):
        return self.__balance
    
    def deposit(self, amount):
        """存款"""
        if amount > 0:
            self.__balance += amount
            return True
        return False
    
    def withdraw(self, amount):
        """取款"""
        if 0 < amount <= self.__balance:
            self.__balance -= amount
            return True
        return False

account = BankAccount("王五", 1000)
print(account.account_holder)    # 王五
print(account.get_balance())     # 1000
# print(account.__balance)       # 错误！不能直接访问私有属性

account.deposit(500)
print(account.get_balance())     # 1500

account.withdraw(200)
print(account.get_balance())     # 1300
```

### 3.2 继承
```python
# 父类（基类）
class Animal:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def eat(self):
        return f"{self.name}在吃东西"
    
    def sleep(self):
        return f"{self.name}在睡觉"

# 子类（派生类）
class Cat(Animal):  # 继承Animal类
    def __init__(self, name, age, color):
        super().__init__(name, age)  # 调用父类的构造方法
        self.color = color
    
    # 方法重写（override）
    def eat(self):
        return f"{self.name}在吃鱼"
    
    # 子类特有的方法
    def catch_mouse(self):
        return f"{self.name}在抓老鼠"

class Dog(Animal):
    def __init__(self, name, age, breed):
        super().__init__(name, age)
        self.breed = breed
    
    def eat(self):
        return f"{self.name}在吃骨头"
    
    def guard(self):
        return f"{self.name}在看家"

# 测试继承
cat = Cat("咪咪", 2, "白色")
dog = Dog("旺财", 3, "金毛")

print(cat.eat())           # 咪咪在吃鱼
print(dog.eat())           # 旺财在吃骨头
print(cat.catch_mouse())   # 咪咪在抓老鼠
print(dog.guard())         # 旺财在看家
print(cat.sleep())         # 咪咪在睡觉（继承自父类）
```

### 3.3 多态
```python
class Shape:
    def area(self):
        pass
    
    def perimeter(self):
        pass

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height
    
    def perimeter(self):
        return 2 * (self.width + self.height)

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    
    def area(self):
        return 3.14159 * self.radius ** 2
    
    def perimeter(self):
        return 2 * 3.14159 * self.radius

# 多态的使用
def print_shape_info(shape):
    """这个函数可以处理任何Shape子类的对象"""
    print(f"面积: {shape.area():.2f}")
    print(f"周长: {shape.perimeter():.2f}")

# 测试多态
rect = Rectangle(5, 3)
circle = Circle(4)

print("矩形信息：")
print_shape_info(rect)
# 面积: 15.00
# 周长: 16.00

print("圆形信息：")
print_shape_info(circle)
# 面积: 50.27
# 周长: 25.13
```

## 4. 类属性和实例属性

### 4.1 类属性 vs 实例属性
```python
class Counter:
    # 类属性
    count = 0
    
    def __init__(self, name):
        # 实例属性
        self.name = name
        Counter.count += 1  # 修改类属性
        self.instance_count = Counter.count  # 实例属性记录创建时的序号

    @classmethod
    def get_total_count(cls):
        """类方法，通过类名调用"""
        return cls.count

# 测试
c1 = Counter("第一个")
c2 = Counter("第二个")
c3 = Counter("第三个")

print(f"类属性count: {Counter.count}")        # 类属性count: 3
print(f"c1.instance_count: {c1.instance_count}")  # c1.instance_count: 1
print(f"c2.instance_count: {c2.instance_count}")  # c2.instance_count: 2
print(f"c3.instance_count: {c3.instance_count}")  # c3.instance_count: 3

print(Counter.get_total_count())  # 3
```

### 4.2 类属性修改的注意事项
```python
class Test:
    shared_list = []  # 类属性，所有对象共享
    
    def __init__(self, value):
        self.value = value
        # 错误用法：这会影响所有对象！
        Test.shared_list.append(value)
    
    def add_to_instance_list(self):
        # 正确做法：每个对象有自己的列表
        if not hasattr(self, 'instance_list'):
            self.instance_list = []
        self.instance_list.append(self.value)

# 测试
t1 = Test(1)
t2 = Test(2)
t3 = Test(3)

print("共享列表:", Test.shared_list)  # 共享列表: [1, 2, 3]

t1.add_to_instance_list()
t2.add_to_instance_list()
t3.add_to_instance_list()

print("t1的实例列表:", t1.instance_list)  # t1的实例列表: [1]
print("t2的实例列表:", t2.instance_list)  # t2的实例列表: [2]
print("t3的实例列表:", t3.instance_list)  # t3的实例列表: [3]
```

## 5. 类方法、静态方法和实例方法

### 5.1 三种方法的区别
```python
class MyClass:
    class_attribute = "类属性"
    
    def __init__(self, value):
        self.instance_attribute = value
    
    def instance_method(self):
        """实例方法：可以访问实例属性和类属性"""
        return f"实例方法: 实例属性={self.instance_attribute}, 类属性={self.class_attribute}"
    
    @classmethod
    def class_method(cls):
        """类方法：只能访问类属性，不能访问实例属性"""
        return f"类方法: 类属性={cls.class_attribute}"
    
    @staticmethod
    def static_method():
        """静态方法：不能访问类属性或实例属性"""
        return "静态方法: 我什么都不依赖"

# 测试
obj = MyClass("实例值")

# 实例方法调用
print(obj.instance_method())  # 实例方法: 实例属性=实例值, 类属性=类属性

# 类方法调用
print(MyClass.class_method())  # 类方法: 类属性=类属性
print(obj.class_method())      # 类方法: 类属性=类属性

# 静态方法调用
print(MyClass.static_method())  # 静态方法: 我什么都不依赖
print(obj.static_method())      # 静态方法: 我什么都不依赖
```

### 5.2 类方法的实际应用
```python
class Person:
    people = []  # 存储所有Person对象
    
    def __init__(self, name, age):
        self.name = name
        self.age = age
        Person.people.append(self)
    
    @classmethod
    def get_total_people(cls):
        return len(cls.people)
    
    @classmethod
    def get_people_by_age(cls, min_age=0, max_age=150):
        """类方法：根据年龄范围筛选人"""
        return [person for person in cls.people if min_age <= person.age <= max_age]
    
    @classmethod
    def create_from_string(cls, string):
        """类方法：从字符串创建对象（替代构造方法）"""
        name, age_str = string.split(',')
        age = int(age_str.strip())
        return cls(name.strip(), age)

# 使用类方法
p1 = Person("张三", 25)
p2 = Person("李四", 30)
p3 = Person("王五", 35)

print(f"总人数: {Person.get_total_people()}")  # 总人数: 3

adults = Person.get_people_by_age(18, 60)
print(f"成年人: {[p.name for p in adults]}")  # 成年人: ['张三', '李四', '王五']

# 使用类方法创建对象
p4 = Person.create_from_string("赵六, 28")
print(f"新创建: {p4.name}, {p4.age}岁")  # 新创建: 赵六, 28岁
```

## 6. 属性访问控制

### 6.1 私有属性和方法
```python
class SecretKeeper:
    def __init__(self, secret):
        self.public_info = "这是公开信息"
        self._protected_info = "这是受保护的信息（约定）"
        self.__private_info = secret  # 私有属性，名称会被改写
    
    def get_secret(self):
        """公有方法访问私有属性"""
        return self.__private_info
    
    def __private_method(self):
        """私有方法"""
        return "这是私有方法"
    
    def access_private_method(self):
        """在类内部可以访问私有方法"""
        return self.__private_method()

# 测试
keeper = SecretKeeper("我的秘密")

print(keeper.public_info)           # 这是公开信息
print(keeper._protected_info)       # 这是受保护的信息（约定）
# print(keeper.__private_info)      # 错误！AttributeError

# 实际上私有属性被改名为 _SecretKeeper__private_info
print(keeper._SecretKeeper__private_info)  # 我的秘密（但不推荐这样访问）

print(keeper.get_secret())          # 我的秘密
print(keeper.access_private_method())  # 这是私有方法
```

### 6.2 使用property装饰器
```python
class Temperature:
    def __init__(self, celsius=0):
        self._celsius = celsius
    
    @property
    def celsius(self):
        """getter方法"""
        print("获取摄氏温度")
        return self._celsius
    
    @celsius.setter
    def celsius(self, value):
        """setter方法"""
        print("设置摄氏温度")
        if value < -273.15:
            raise ValueError("温度不能低于绝对零度")
        self._celsius = value
    
    @property
    def fahrenheit(self):
        """只读属性"""
        return self._celsius * 9/5 + 32
    
    @fahrenheit.setter
    def fahrenheit(self, value):
        """设置华氏温度时自动转换"""
        self._celsius = (value - 32) * 5/9

# 测试property
temp = Temperature(25)
print(f"摄氏温度: {temp.celsius}")      # 摄氏温度: 25
print(f"华氏温度: {temp.fahrenheit}")   # 华氏温度: 77.0

temp.celsius = 30
print(f"新的摄氏温度: {temp.celsius}")  # 新的摄氏温度: 30
print(f"新的华氏温度: {temp.fahrenheit}") # 新的华氏温度: 86.0

temp.fahrenheit = 100
print(f"设置华氏100度后的摄氏温度: {temp.celsius}")  # 设置华氏100度后的摄氏温度: 37.777...
```

## 7. 特殊方法（魔术方法）

### 7.1 常用的魔术方法
```python
class Book:
    def __init__(self, title, author, pages):
        self.title = title
        self.author = author
        self.pages = pages
    
    # 字符串表示
    def __str__(self):
        return f"《{self.title}》 - {self.author}"
    
    def __repr__(self):
        return f"Book('{self.title}', '{self.author}', {self.pages})"
    
    # 比较操作
    def __eq__(self, other):
        if not isinstance(other, Book):
            return False
        return (self.title, self.author, self.pages) == (other.title, other.author, other.pages)
    
    def __lt__(self, other):
        """小于比较，按页数排序"""
        return self.pages < other.pages
    
    # 数学运算
    def __add__(self, other):
        """两本书的页数相加"""
        if isinstance(other, Book):
            return self.pages + other.pages
        elif isinstance(other, (int, float)):
            return self.pages + other
        else:
            raise TypeError("不支持的类型")
    
    # 长度和布尔值
    def __len__(self):
        return self.pages
    
    def __bool__(self):
        return self.pages > 0

# 测试魔术方法
book1 = Book("Python编程", "张三", 300)
book2 = Book("算法导论", "李四", 500)

print(str(book1))          # 《Python编程》 - 张三
print(repr(book1))         # Book('Python编程', '张三', 300)

print(book1 == book2)      # False
print(book1 < book2)       # True

print(book1 + book2)       # 800
print(book1 + 100)         # 400

print(len(book1))          # 300
print(bool(book1))         # True

# 排序演示
books = [book2, book1]
books.sort()  # 使用__lt__方法排序
print([book.title for book in books])  # ['Python编程', '算法导论']
```

### 7.2 上下文管理 __enter__ 和 __exit__
```python
class DatabaseConnection:
    def __init__(self, db_name):
        self.db_name = db_name
        self.connected = False
    
    def connect(self):
        self.connected = True
        print(f"连接到数据库 {self.db_name}")
    
    def disconnect(self):
        self.connected = False
        print(f"断开数据库连接 {self.db_name}")
    
    def __enter__(self):
        """进入上下文时调用"""
        self.connect()
        return self  # 作为as后的变量
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """退出上下文时调用"""
        self.disconnect()
        if exc_type:
            print(f"发生错误: {exc_val}")
        return False  # 不抑制异常

# 使用with语句自动管理资源
with DatabaseConnection("my_database") as db:
    print("执行数据库操作")
    print(f"连接状态: {db.connected}")
# 输出：
# 连接到数据库 my_database
# 执行数据库操作
# 连接状态: True
# 断开数据库连接 my_database
```

## 8. 继承的高级用法

### 8.1 多重继承
```python
class Flyable:
    def __init__(self, max_speed):
        self.max_speed = max_speed
    
    def fly(self):
        return f"以最高{self.max_speed}km/h的速度飞行"

class Swimmable:
    def __init__(self, max_depth):
        self.max_depth = max_depth
    
    def swim(self):
        return f"下潜到{self.max_depth}米深度"

class Runnable:
    def __init__(self, max_speed):
        self.max_speed = max_speed
    
    def run(self):
        return f"以最高{self.max_speed}km/h的速度奔跑"

# 多重继承
class Duck(Runnable, Flyable, Swimmable):
    def __init__(self, run_speed, fly_speed, swim_depth):
        # 分别调用父类的构造方法
        Runnable.__init__(self, run_speed)
        Flyable.__init__(self, fly_speed)
        Swimmable.__init__(self, swim_depth)
    
    def all_abilities(self):
        return f"鸭子可以：{self.run()}, {self.fly()}, {self.swim()}"

# 测试多重继承
duck = Duck(10, 50, 5)
print(duck.run())            # 以最高10km/h的速度奔跑
print(duck.fly())            # 以最高50km/h的速度飞行
print(duck.swim())           # 下潜到5米深度
print(duck.all_abilities())  # 鸭子可以：以最高10km/h的速度奔跑, 以最高50km/h的速度飞行, 下潜到5米深度

# 查看方法解析顺序(MRO)
print(Duck.__mro__)
# (<class '__main__.Duck'>, <class '__main__.Runnable'>, 
#  <class '__main__.Flyable'>, <class '__main__.Swimmable'>, <class 'object'>)
```

### 8.2 super()函数的使用
```python
class A:
    def __init__(self):
        print("A的构造方法")
        self.value_a = "A"

class B(A):
    def __init__(self):
        print("B的构造方法")
        super().__init__()  # 调用父类A的构造方法
        self.value_b = "B"

class C(A):
    def __init__(self):
        print("C的构造方法")
        super().__init__()
        self.value_c = "C"

class D(B, C):
    def __init__(self):
        print("D的构造方法")
        super().__init__()  # 按照MRO顺序调用
        self.value_d = "D"

# 测试super()
d = D()
print(f"value_a: {d.value_a}")  # value_a: A
print(f"value_b: {d.value_b}")  # value_b: B
print(f"value_c: {d.value_c}")  # value_c: C
print(f"value_d: {d.value_d}")  # value_d: D

# 查看D的MRO
print(D.__mro__)
# (<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, 
#  <class '__main__.A'>, <class 'object'>)
```

## 9. 抽象基类

### 9.1 使用abc模块
```python
from abc import ABC, abstractmethod
import math

class Shape(ABC):
    """抽象基类，不能实例化"""
    
    @abstractmethod
    def area(self):
        """抽象方法，子类必须实现"""
        pass
    
    @abstractmethod
    def perimeter(self):
        """抽象方法，子类必须实现"""
        pass
    
    # 可以有具体实现的方法
    def info(self):
        return f"这是一个形状，面积={self.area():.2f}, 周长={self.perimeter():.2f}"

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    
    def area(self):
        return math.pi * self.radius ** 2
    
    def perimeter(self):
        return 2 * math.pi * self.radius

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height
    
    def perimeter(self):
        return 2 * (self.width + self.height)

# 测试抽象基类
circle = Circle(5)
rect = Rectangle(4, 6)

print(circle.info())  # 这是一个形状，面积=78.54, 周长=31.42
print(rect.info())    # 这是一个形状，面积=24.00, 周长=20.00

# shape = Shape()  # 错误！不能实例化抽象基类
```

## 10. 枚举类

### 10.1 使用Enum创建枚举
```python
from enum import Enum, auto

class Color(Enum):
    RED = 1
    GREEN = 2
    BLUE = 3

class Status(Enum):
    PENDING = auto()  # 自动分配值
    PROCESSING = auto()
    COMPLETED = auto()
    FAILED = auto()

# 使用枚举
print(Color.RED)           # Color.RED
print(Color.RED.name)      # RED
print(Color.RED.value)     # 1

# 遍历枚举
for color in Color:
    print(f"{color.name}: {color.value}")
# RED: 1
# GREEN: 2
# BLUE: 3

# 枚举比较
if Color.RED == Color.RED:
    print("颜色相同")      # 颜色相同

# 通过值获取枚举
print(Color(1))           # Color.RED
print(Color['RED'])       # Color.RED
```

## 11. 数据类

### 11.1 使用dataclass装饰器
```python
from dataclasses import dataclass, field
from typing import List

@dataclass
class Person:
    name: str
    age: int
    email: str = ""  # 默认值
    hobbies: List[str] = field(default_factory=list)  # 可变默认值的正确写法
    
    def is_adult(self):
        return self.age >= 18
    
    def add_hobby(self, hobby):
        self.hobbies.append(hobby)

# 使用数据类
person1 = Person("张三", 25, "zhangsan@email.com")
person2 = Person("李四", 17)
person3 = Person("李四", 17)  # 与person2相同

print(person1)  # Person(name='张三', age=25, email='zhangsan@email.com', hobbies=[])
print(person1 == person2)  # False
print(person2 == person3)  # True（自动实现了__eq__）

person1.add_hobby("游泳")
person1.add_hobby("阅读")
print(person1)  # Person(name='张三', age=25, email='zhangsan@email.com', hobbies=['游泳', '阅读'])
```

## 12. 易错点和注意事项

### 12.1 可变默认参数陷阱
```python
# 错误示例
class BadExample:
    def __init__(self, items=[]):  # 错误！可变默认参数
        self.items = items
    
    def add_item(self, item):
        self.items.append(item)

# 测试问题
obj1 = BadExample()
obj1.add_item("A")

obj2 = BadExample()  # 期望空的items，但实际上共享了同一个列表
obj2.add_item("B")

print("obj1.items:", obj1.items)  # obj1.items: ['A', 'B']
print("obj2.items:", obj2.items)  # obj2.items: ['A', 'B']  # 问题！

# 正确做法
class GoodExample:
    def __init__(self, items=None):
        self.items = items if items is not None else []  # 正确做法
    
    def add_item(self, item):
        self.items.append(item)

# 测试修正
obj3 = GoodExample()
obj3.add_item("A")

obj4 = GoodExample()
obj4.add_item("B")

print("obj3.items:", obj3.items)  # obj3.items: ['A']
print("obj4.items:", obj4.items)  # obj4.items: ['B']  # 正确！
```

### 12.2 属性名称冲突
```python
class ConflictExample:
    def __init__(self, value):
        self.value = value
        # 注意：不要使用与方法同名的属性
        self.get_value = "这是一个属性，不是方法"  # 这会覆盖下面的方法！

    def get_value(self):
        return self.value

# 测试冲突
obj = ConflictExample(42)
# print(obj.get_value())  # 错误！TypeError: 'str' object is not callable

# 正确做法：避免属性名和方法名冲突
class CorrectExample:
    def __init__(self, value):
        self.value = value
        self.value_str = "这是一个属性"  # 使用不同的名称
    
    def get_value(self):
        return self.value

correct_obj = CorrectExample(42)
print(correct_obj.get_value())  # 42
print(correct_obj.value_str)    # 这是一个属性
```

## 13. 高级技巧和最佳实践

### 13.1 使用组合代替继承
```python
# 组合：包含其他类的对象，而不是继承
class Engine:
    def start(self):
        return "引擎启动"
    
    def stop(self):
        return "引擎停止"

class Wheel:
    def __init__(self, position):
        self.position = position
    
    def rotate(self):
        return f"{self.position}轮子旋转"

class Car:
    def __init__(self):
        self.engine = Engine()  # 组合：包含Engine对象
        self.wheels = [Wheel("左前"), Wheel("右前"), Wheel("左后"), Wheel("右后")]
    
    def start(self):
        return self.engine.start()
    
    def drive(self):
        return " + ".join(wheel.rotate() for wheel in self.wheels)

# 使用组合
car = Car()
print(car.start())  # 引擎启动
print(car.drive())  # 左前轮子旋转 + 右前轮子旋转 + 左后轮子旋转 + 右后轮子旋转
```

### 13.2 单例模式
```python
class Singleton:
    _instance = None
    
    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self, name):
        # 注意：每次实例化都会调用__init__，所以需要防止重复初始化
        if not hasattr(self, 'initialized'):
            self.name = name
            self.initialized = True

# 测试单例
s1 = Singleton("第一个实例")
s2 = Singleton("第二个实例")

print(s1 is s2)        # True，是同一个对象
print(s1.name)         # 第一个实例
print(s2.name)         # 第一个实例（因为第二次__init__没有生效）
```

### 13.3 使用描述符
```python
class ValidatedAttribute:
    """描述符类"""
    def __init__(self, min_value=None, max_value=None):
        self.min_value = min_value
        self.max_value = max_value
        self.attr_name = None
    
    def __set_name__(self, owner, name):
        self.attr_name = name
    
    def __get__(self, instance, owner):
        if instance is None:
            return self
        return instance.__dict__.get(self.attr_name)
    
    def __set__(self, instance, value):
        if self.min_value is not None and value < self.min_value:
            raise ValueError(f"{self.attr_name}不能小于{self.min_value}")
        if self.max_value is not None and value > self.max_value:
            raise ValueError(f"{self.attr_name}不能大于{self.max_value}")
        instance.__dict__[self.attr_name] = value

class Person:
    age = ValidatedAttribute(min_value=0, max_value=150)
    height = ValidatedAttribute(min_value=0, max_value=300)
    
    def __init__(self, name, age, height):
        self.name = name
        self.age = age
        self.height = height

# 测试描述符
person = Person("张三", 25, 175)
print(f"{person.name}, {person.age}岁, {person.height}cm")  # 张三, 25岁, 175cm

try:
    person.age = -5  # 会抛出异常
except ValueError as e:
    print(f"错误: {e}")  # 错误: age不能小于0

try:
    person.height = 400  # 会抛出异常
except ValueError as e:
    print(f"错误: {e}")  # 错误: height不能大于300
```

## 14. 综合实例：学生管理系统

```python
from dataclasses import dataclass, field
from typing import List, Dict
from abc import ABC, abstractmethod

class Person(ABC):
    def __init__(self, name: str, age: int):
        self.name = name
        self.age = age
    
    @abstractmethod
    def get_info(self) -> str:
        pass

class Student(Person):
    student_count = 0
    
    def __init__(self, name: str, age: int, student_id: str):
        super().__init__(name, age)
        self.student_id = student_id
        self.__grades: Dict[str, float] = {}  # 课程:成绩
        Student.student_count += 1
    
    def add_grade(self, course: str, grade: float):
        if 0 <= grade <= 100:
            self.__grades[course] = grade
        else:
            raise ValueError("成绩必须在0-100之间")
    
    def get_average_grade(self) -> float:
        if not self.__grades:
            return 0.0
        return sum(self.__grades.values()) / len(self.__grades)
    
    def get_info(self) -> str:
        avg_grade = self.get_average_grade()
        return f"学生: {self.name}({self.student_id}), {self.age}岁, 平均成绩: {avg_grade:.2f}"
    
    @classmethod
    def get_total_students(cls) -> int:
        return cls.student_count
    
    def __str__(self):
        return self.get_info()

class Teacher(Person):
    def __init__(self, name: str, age: int, subject: str):
        super().__init__(name, age)
        self.subject = subject
    
    def get_info(self) -> str:
        return f"老师: {self.name}, {self.age}岁, 教授{self.subject}"
    
    def __str__(self):
        return self.get_info()

class Course:
    def __init__(self, name: str, teacher: Teacher):
        self.name = name
        self.teacher = teacher
        self.students: List[Student] = []
    
    def add_student(self, student: Student):
        if student not in self.students:
            self.students.append(student)
    
    def get_course_info(self) -> str:
        student_names = [student.name for student in self.students]
        return f"课程: {self.name}, 教师: {self.teacher.name}, 学生: {', '.join(student_names)}"
    
    def __str__(self):
        return self.get_course_info()

# 测试综合实例
# 创建教师
math_teacher = Teacher("王老师", 35, "数学")
english_teacher = Teacher("李老师", 40, "英语")

# 创建学生
student1 = Student("张三", 18, "S001")
student2 = Student("李四", 19, "S002")
student3 = Student("王五", 20, "S003")

# 添加成绩
student1.add_grade("数学", 85)
student1.add_grade("英语", 92)
student2.add_grade("数学", 78)
student3.add_grade("英语", 88)

# 创建课程
math_course = Course("高等数学", math_teacher)
english_course = Course("大学英语", english_teacher)

# 添加学生到课程
math_course.add_student(student1)
math_course.add_student(student2)
english_course.add_student(student1)
english_course.add_student(student3)

# 输出信息
print("=== 人员信息 ===")
print(student1)
print(student2)
print(student3)
print(math_teacher)
print(english_teacher)

print("\n=== 课程信息 ===")
print(math_course)
print(english_course)

print(f"\n=== 统计信息 ===")
print(f"总学生数: {Student.get_total_students()}")
```
