# Python变量超详细笔记

## 1. 变量基础概念

### 1.1 什么是变量？
变量是存储数据的容器，可以理解为数据的"标签"或"名字"。在Python中，变量不需要预先声明类型，可以直接赋值使用。

```python
# 基础变量定义示例
name = "张三"           # 字符串变量
age = 25               # 整数变量
height = 1.75          # 浮点数变量
is_student = True      # 布尔变量
scores = [85, 92, 78]  # 列表变量

print("姓名:", name)        # 输出：姓名: 张三
print("年龄:", age)         # 输出：年龄: 25
print("身高:", height)      # 输出：身高: 1.75
print("是否学生:", is_student) # 输出：是否学生: True
print("成绩:", scores)      # 输出：成绩: [85, 92, 78]
```

### 1.2 变量的动态特性
Python是动态类型语言，变量的类型可以在程序运行过程中改变。

```python
# 演示变量的动态特性
x = 10
print("x的初始值和类型:", x, type(x))  # 输出：x的初始值和类型: 10 <class 'int'>

x = "现在我是字符串"
print("x的值和类型变化:", x, type(x))  # 输出：x的值和类型变化: 现在我是字符串 <class 'str'>

x = [1, 2, 3]
print("x的值和类型再次变化:", x, type(x))  # 输出：x的值和类型再次变化: [1, 2, 3] <class 'list'>

x = 3.14
print("x的值和类型最终:", x, type(x))  # 输出：x的值和类型最终: 3.14 <class 'float'>
```

### 1.3 变量的内存机制
Python中的变量实际上存储的是对象的引用（内存地址），而不是对象本身。

```python
# 变量引用机制演示
a = [1, 2, 3]
b = a  # b和a指向同一个列表对象

print("a的id:", id(a))  # 输出：a的id: 140245678945600
print("b的id:", id(b))  # 输出：b的id: 140245678945600

b.append(4)  # 通过b修改列表
print("修改b后a的值:", a)  # 输出：修改b后a的值: [1, 2, 3, 4]
print("a和b是否同一个对象:", a is b)  # 输出：a和b是否同一个对象: True
```

## 2. 变量命名规则和规范

### 2.1 合法的变量命名规则
Python变量命名必须遵循以下规则：
- 由字母、数字、下划线组成
- 不能以数字开头
- 不能使用Python关键字
- 区分大小写

```python
# 合法的变量命名示例
student_name = "李四"    # 使用小写字母和下划线
studentAge = 20         # 驼峰命名法
_count = 5              # 以下划线开头
total_score_2024 = 95   # 包含数字
MAX_SIZE = 100          # 常量通常用全大写

print(student_name, studentAge, _count, total_score_2024, MAX_SIZE)  
# 输出：李四 20 5 95 100
```

### 2.2 非法的变量命名示例
```python
# 以下都是不合法的变量名（取消注释会报错）

# 2name = "错误"        # 错误：不能以数字开头
# class = "Python"     # 错误：不能使用关键字
# my-name = "错误"     # 错误：不能包含连字符
# $price = 100         # 错误：不能包含特殊字符（除了_）
```

### 2.3 Python关键字列表
```python
import keyword
print("Python关键字列表:", keyword.kwlist)
# 输出：Python关键字列表: ['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']
```

### 2.4 命名规范建议
```python
# 好的命名习惯
user_name = "王五"          # 清晰描述用途，使用小写字母和下划线
max_temperature = 38.5      # 易于理解
is_logged_in = True         # 布尔值用is/has开头
MAX_BUFFER_SIZE = 1024      # 常量使用全大写

# 应该避免的命名
a = 10                      # 无意义，不知道代表什么
temp = "临时"               # 含义不明确
x1 = 5                      # 没有描述性

print("好的命名示例:", user_name, max_temperature, is_logged_in, MAX_BUFFER_SIZE)
# 输出：好的命名示例: 王五 38.5 True 1024
```

## 3. 变量赋值操作详解

### 3.1 基本赋值操作
```python
# 简单赋值
x = 10
y = x  # y现在也是10
print(f"x = {x}, y = {y}")  # 输出：x = 10, y = 10

# 多重赋值
a, b, c = 1, 2, 3
print(f"a={a}, b={b}, c={c}")  # 输出：a=1, b=2, c=3

# 链式赋值
x = y = z = 100
print(f"x={x}, y={y}, z={z}")  # 输出：x=100, y=100, z=100

# 交换变量值（Python特色）
x, y = 10, 20
print(f"交换前: x={x}, y={y}")  # 输出：交换前: x=10, y=20
x, y = y, x  # 不需要临时变量
print(f"交换后: x={x}, y={y}")  # 输出：交换后: x=20, y=10
```

### 3.2 增量赋值操作
```python
# 各种增量赋值操作
count = 5
count += 3      # 相当于 count = count + 3
print("count += 3:", count)  # 输出：count += 3: 8

count -= 2      # 相当于 count = count - 2
print("count -= 2:", count)  # 输出：count -= 2: 6

count *= 4      # 相当于 count = count * 4
print("count *= 4:", count)  # 输出：count *= 4: 24

count //= 3     # 相当于 count = count // 3 (整除)
print("count //= 3:", count)  # 输出：count //= 3: 8

count **= 2     # 相当于 count = count ** 2 (幂运算)
print("count **= 2:", count)  # 输出：count **= 2: 64

# 字符串也可以增量赋值
text = "Hello"
text += " World!"
print("text += ' World!':", text)  # 输出：text += ' World!': Hello World!

# 列表增量赋值
numbers = [1, 2]
numbers += [3, 4]  # 相当于 numbers.extend([3, 4])
print("numbers += [3, 4]:", numbers)  # 输出：numbers += [3, 4]: [1, 2, 3, 4]
```

### 3.3 解包赋值操作
```python
# 序列解包
data = [1, 2, 3]
a, b, c = data
print(f"a={a}, b={b}, c={c}")  # 输出：a=1, b=2, c=3

# 使用*收集多余元素
first, *middle, last = [1, 2, 3, 4, 5]
print(f"first={first}, middle={middle}, last={last}")  # 输出：first=1, middle=[2, 3, 4], last=5

# 解包字典
person = {"name": "张三", "age": 20, "city": "北京"}
name, age, city = person.values()
print(f"name={name}, age={age}, city={city}")  # 输出：name=张三, age=20, city=北京

# 使用**解包字典作为函数参数
def introduce(name, age, city):
    print(f"我叫{name}, {age}岁, 来自{city}")

introduce(**person)  # 输出：我叫张三, 20岁, 来自北京

# 忽略某些值
x, _, z = (10, 20, 30)  # 使用_忽略不需要的值
print(f"x={x}, z={z}")  # 输出：x=10, z=30
```

## 4. 变量作用域详解

### 4.1 局部变量和全局变量
```python
# 全局变量
global_var = "我是全局变量"

def test_function():
    # 局部变量
    local_var = "我是局部变量"
    print("函数内访问局部变量:", local_var)  # 输出：函数内访问局部变量: 我是局部变量
    print("函数内访问全局变量:", global_var)  # 输出：函数内访问全局变量: 我是全局变量
    
    # 如果要修改全局变量，需要使用global关键字
    global global_var
    global_var = "全局变量已被修改"
    print("函数内修改后的全局变量:", global_var)  # 输出：函数内修改后的全局变量: 全局变量已被修改

test_function()
print("函数外访问全局变量:", global_var)  # 输出：函数外访问全局变量: 全局变量已被修改
# print("函数外访问局部变量:", local_var)  # 这会报错，因为local_var是局部变量
```

### 4.2 嵌套作用域
```python
def outer_function():
    outer_var = "外部变量"
    
    def inner_function():
        inner_var = "内部变量"
        # 内部函数可以访问外部函数的变量
        print("内部函数访问外部变量:", outer_var)  # 输出：内部函数访问外部变量: 外部变量
        print("内部函数访问内部变量:", inner_var)  # 输出：内部函数访问内部变量: 内部变量
    
    inner_function()
    # print("外部函数访问内部变量:", inner_var)  # 这会报错，inner_var是inner_function的局部变量

outer_function()
```

### 4.3 nonlocal关键字
```python
def outer():
    count = 0
    
    def inner():
        nonlocal count  # 声明count不是局部变量，而是外部函数的变量
        count += 1
        print("inner中的count:", count)  # 输出：inner中的count: 1
    
    inner()
    print("outer中的count:", count)  # 输出：outer中的count: 1

outer()

# 对比不使用nonlocal的情况
def outer2():
    count = 0
    
    def inner2():
        # 这里创建了一个新的局部变量count，而不是修改外部count
        count = 100
        print("inner2中的count:", count)  # 输出：inner2中的count: 100
    
    inner2()
    print("outer2中的count:", count)  # 输出：outer2中的count: 0

outer2()
```

### 4.4 作用域查找规则（LEGB规则）
Python按照LEGB规则查找变量：
- **L**ocal：局部作用域
- **E**nclosing：闭包函数外的函数中
- **G**lobal：全局作用域
- **B**uilt-in：内建作用域

```python
# LEGB规则演示
x = "global x"  # Global

def outer():
    x = "outer x"  # Enclosing
    
    def inner():
        x = "inner x"  # Local
        print("inner中的x:", x)  # 输出：inner中的x: inner x
    
    inner()
    print("outer中的x:", x)  # 输出：outer中的x: outer x

outer()
print("全局的x:", x)  # 输出：全局的x: global x

# 使用globals()和locals()查看作用域
def scope_demo():
    local_var = "局部变量"
    print("locals():", locals())  # 输出：locals(): {'local_var': '局部变量'}
    print("globals()中的x:", globals().get('x'))  # 输出：globals()中的x: global x

scope_demo()
```

## 5. 变量的内存管理和高级特性

### 5.1 可变对象与不可变对象
```python
# 不可变对象：数字、字符串、元组
x = 10
print("整数修改前id:", id(x))  # 输出：整数修改前id: 140734357710752
x = 20  # 创建了新对象
print("整数修改后id:", id(x))  # 输出：整数修改后id: 140734357711072

s = "hello"
print("字符串修改前id:", id(s))  # 输出：字符串修改前id: 140245678945600
s = "world"  # 创建了新对象
print("字符串修改后id:", id(s))  # 输出：字符串修改后id: 140245678946640

# 可变对象：列表、字典、集合
lst = [1, 2, 3]
print("列表修改前id:", id(lst))  # 输出：列表修改前id: 140245678947200
lst.append(4)  # 修改了原对象
print("列表修改后id:", id(lst))  # 输出：列表修改后id: 140245678947200
print("列表内容:", lst)  # 输出：列表内容: [1, 2, 3, 4]
```

### 5.2 对象的引用计数
```python
import sys

# 查看对象的引用计数
a = [1, 2, 3]
print("a的引用计数:", sys.getrefcount(a))  # 输出：a的引用计数: 2

b = a
print("b = a后a的引用计数:", sys.getrefcount(a))  # 输出：b = a后a的引用计数: 3

c = b
print("c = b后a的引用计数:", sys.getrefcount(a))  # 输出：c = b后a的引用计数: 4

del b
print("del b后a的引用计数:", sys.getrefcount(a))  # 输出：del b后a的引用计数: 3

del c
print("del c后a的引用计数:", sys.getrefcount(a))  # 输出：del c后a的引用计数: 2
```

### 5.3 浅拷贝与深拷贝
```python
import copy

# 浅拷贝示例
original_list = [1, 2, [3, 4]]
shallow_copy = copy.copy(original_list)

print("原列表:", original_list)  # 输出：原列表: [1, 2, [3, 4]]
print("浅拷贝:", shallow_copy)  # 输出：浅拷贝: [1, 2, [3, 4]]

# 修改浅拷贝中的可变元素会影响原列表
shallow_copy[2].append(5)
print("修改后原列表:", original_list)  # 输出：修改后原列表: [1, 2, [3, 4, 5]]
print("修改后浅拷贝:", shallow_copy)  # 输出：修改后浅拷贝: [1, 2, [3, 4, 5]]

# 深拷贝示例
original_list2 = [1, 2, [3, 4]]
deep_copy = copy.deepcopy(original_list2)

print("原列表:", original_list2)  # 输出：原列表: [1, 2, [3, 4]]
print("深拷贝:", deep_copy)  # 输出：深拷贝: [1, 2, [3, 4]]

# 修改深拷贝不会影响原列表
deep_copy[2].append(5)
print("修改后原列表:", original_list2)  # 输出：修改后原列表: [1, 2, [3, 4]]
print("修改后深拷贝:", deep_copy)  # 输出：修改后深拷贝: [1, 2, [3, 4, 5]]

# 各种拷贝方式对比
lst = [1, 2, [3, 4]]
copy1 = lst[:]           # 切片拷贝（浅拷贝）
copy2 = list(lst)        # 构造函数拷贝（浅拷贝）
copy3 = copy.copy(lst)   # copy函数（浅拷贝）
copy4 = copy.deepcopy(lst)  # 深拷贝

lst[2].append(5)
print("原列表:", lst)        # 输出：原列表: [1, 2, [3, 4, 5]]
print("切片拷贝:", copy1)    # 输出：切片拷贝: [1, 2, [3, 4, 5]]
print("构造函数拷贝:", copy2) # 输出：构造函数拷贝: [1, 2, [3, 4, 5]]
print("copy函数拷贝:", copy3) # 输出：copy函数拷贝: [1, 2, [3, 4, 5]]
print("深拷贝:", copy4)      # 输出：深拷贝: [1, 2, [3, 4]]
```

### 5.4 小整数池和字符串驻留
```python
# 小整数池（-5到256）
a = 100
b = 100
print("小整数a is b:", a is b)  # 输出：小整数a is b: True

c = 1000
d = 1000
print("大整数c is d:", c is d)  # 输出：大整数c is d: False

# 字符串驻留
s1 = "hello"
s2 = "hello"
print("短字符串s1 is s2:", s1 is s2)  # 输出：短字符串s1 is s2: True

s3 = "hello world!"
s4 = "hello world!"
print("长字符串s3 is s4:", s3 is s4)  # 输出：长字符串s3 is s4: True（Python会优化）

# 强制字符串驻留
s5 = "".join(['h', 'e', 'l', 'l', 'o'])
s6 = "hello"
print("拼接字符串s5 is s6:", s5 is s6)  # 输出：拼接字符串s5 is s6: False

s7 = sys.intern(s5)
print("驻留后s7 is s6:", s7 is s6)  # 输出：驻留后s7 is s6: True
```

## 6. 易错点和难点解析

### 6.1 可变默认参数陷阱
```python
# 错误示例：使用可变对象作为默认参数
def wrong_append(item, items=[]):
    items.append(item)
    return items

print("第一次调用:", wrong_append(1))  # 输出：第一次调用: [1]
print("第二次调用:", wrong_append(2))  # 输出：第二次调用: [1, 2]（意外结果！）
print("第三次调用:", wrong_append(3))  # 输出：第三次调用: [1, 2, 3]（继续累积！）

# 正确做法：使用None作为默认值
def correct_append(item, items=None):
    if items is None:
        items = []
    items.append(item)
    return items

print("第一次调用:", correct_append(1))  # 输出：第一次调用: [1]
print("第二次调用:", correct_append(2))  # 输出：第二次调用: [2]（正常结果）
print("第三次调用:", correct_append(3))  # 输出：第三次调用: [3]（正常结果）
```

### 6.2 变量作用域混淆
```python
# 常见作用域错误
count = 0

def increment():
    # 这里会报错，因为尝试修改全局变量但没有声明
    # count += 1  # UnboundLocalError: local variable 'count' referenced before assignment
    
    # 正确做法：
    global count
    count += 1

increment()
print("count:", count)  # 输出：count: 1

# 另一个常见错误
x = 10

def confusing_scope():
    print("函数内访问x:", x)  # 这里可以读取全局x
    # x = 20  # 如果取消注释，上面一行会报错，因为Python检测到后面有对x的赋值

confusing_scope()
```

### 6.3 等号（==）与is的区别
```python
# == 比较值，is 比较身份（是否是同一个对象）
a = [1, 2, 3]
b = [1, 2, 3]
c = a

print("a == b:", a == b)  # 输出：a == b: True（值相同）
print("a is b:", a is b)  # 输出：a is b: False（不是同一个对象）
print("a is c:", a is c)  # 输出：a is c: True（是同一个对象）

# 对于小整数，Python会缓存，所以is返回True
x = 256
y = 256
print("x is y (小整数):", x is y)  # 输出：x is y (小整数): True

x = 257
y = 257
print("x is y (大整数):", x is y)  # 输出：x is y (大整数): False

# None比较应该使用is
value = None
print("value is None:", value is None)  # 输出：value is None: True
print("value == None:", value == None)  # 输出：value == None: True（但推荐使用is）
```

### 6.4 循环中的变量绑定
```python
# 列表推导式中的变量作用域（Python 3中修复）
x = "原始值"
numbers = [x for x in range(5)]
print("列表推导式后的x:", x)  # 输出：列表推导式后的x: 原始值（Python 3中x不会被修改）

# 但在循环中会有不同表现
x = "原始值"
for x in range(5):
    pass
print("循环后的x:", x)  # 输出：循环后的x: 4（x被修改了）

# 闭包中的变量绑定问题
functions = []
for i in range(3):
    def func():
        return i
    functions.append(func)

print("闭包问题结果:", [f() for f in functions])  # 输出：闭包问题结果: [2, 2, 2]（都是2！）

# 解决方法：使用默认参数
functions2 = []
for i in range(3):
    def func(i=i):  # 使用默认参数捕获当前值
        return i
    functions2.append(func)

print("修复后结果:", [f() for f in functions2])  # 输出：修复后结果: [0, 1, 2]
```

### 6.5 在迭代时修改集合
```python
# 错误：在迭代时修改集合
try:
    s = {1, 2, 3, 4, 5}
    for item in s:
        if item % 2 == 0:
            s.remove(item)  # RuntimeError: Set changed size during iteration
except RuntimeError as e:
    print(f"错误: {e}")  # 输出：错误: Set changed size during iteration

# 正确做法：先创建副本
s = {1, 2, 3, 4, 5}
for item in s.copy():  # 或者 list(s)
    if item % 2 == 0:
        s.remove(item)
print("修改后的集合:", s)  # 输出：修改后的集合: {1, 3, 5}

# 或者使用集合推导式
s = {1, 2, 3, 4, 5}
s = {x for x in s if x % 2 != 0}
print("使用推导式后的集合:", s)  # 输出：使用推导式后的集合: {1, 3, 5}
```

## 7. 高级使用技巧

### 7.1 使用type hints提高代码可读性
```python
from typing import List, Dict, Optional, Union

# 类型提示让代码更清晰
def process_students(
    students: List[Dict[str, Union[str, int]]], 
    max_count: Optional[int] = None
) -> List[str]:
    """
    处理学生数据
    
    Args:
        students: 学生字典列表
        max_count: 最大处理数量
    
    Returns:
        学生姓名列表
    """
    names = [student["name"] for student in students]
    if max_count:
        names = names[:max_count]
    return names

# 使用示例
student_data = [
    {"name": "张三", "grade": "A", "age": 20},
    {"name": "李四", "grade": "B", "age": 21},
    {"name": "王五", "grade": "C", "age": 22}
]

result = process_students(student_data, max_count=2)
print("处理结果:", result)  # 输出：处理结果: ['张三', '李四']
```

### 7.2 使用f-string格式化字符串
```python
# f-string是Python 3.6+的现代字符串格式化方法
name = "张三"
age = 20
score = 95.5

# 基础用法
message = f"姓名: {name}, 年龄: {age}, 分数: {score}"
print(message)  # 输出：姓名: 张三, 年龄: 20, 分数: 95.5

# 表达式计算
print(f"明年年龄: {age + 1}")  # 输出：明年年龄: 21

# 格式化数字
print(f"分数: {score:.1f}")  # 输出：分数: 95.5
print(f"百分比: {score:.1%}")  # 输出：百分比: 9550.0%

# 对齐和填充
print(f"姓名: {name:<10} 年龄: {age:>3}")  # 输出：姓名: 张三        年龄:  20
print(f"分数: {score:^10}")  # 输出：分数:   95.5   

# 在字典中使用
person = {"name": "李四", "age": 22}
print(f"人物: {person['name']}, {person['age']}岁")  # 输出：人物: 李四, 22岁

# 调用方法
text = "hello world"
print(f"大写: {text.upper()}")  # 输出：大写: HELLO WORLD
```

### 7.3 使用enumerate和zip
```python
# enumerate获取索引和值
fruits = ["苹果", "香蕉", "橙子"]
for index, fruit in enumerate(fruits):
    print(f"索引 {index}: {fruit}")
# 输出：
# 索引 0: 苹果
# 索引 1: 香蕉
# 索引 2: 橙子

# 指定起始索引
for index, fruit in enumerate(fruits, start=1):
    print(f"编号 {index}: {fruit}")
# 输出：
# 编号 1: 苹果
# 编号 2: 香蕉
# 编号 3: 橙子

# zip同时遍历多个序列
names = ["张三", "李四", "王五"]
scores = [95, 88, 92]
subjects = ["数学", "英语", "物理"]

for name, score, subject in zip(names, scores, subjects):
    print(f"{name}的{subject}分数: {score}")
# 输出：
# 张三的数学分数: 95
# 李四的英语分数: 88
# 王五的物理分数: 92

# 创建字典
score_dict = dict(zip(names, scores))
print("分数字典:", score_dict)  # 输出：分数字典: {'张三': 95, '李四': 88, '王五': 92}

# 解压zip
zipped = list(zip(names, scores))
print("zipped:", zipped)  # 输出：zipped: [('张三', 95), ('李四', 88), ('王五', 92)]
unzipped_names, unzipped_scores = zip(*zipped)
print("unzipped_names:", unzipped_names)  # 输出：unzipped_names: ('张三', '李四', '王五')
print("unzipped_scores:", unzipped_scores)  # 输出：unzipped_scores: (95, 88, 92)
```

### 7.4 使用walrus运算符（:=）
```python
# Python 3.8+ 海象运算符，在表达式中赋值

# 传统写法
data = "hello world"
n = len(data)
if n > 5:
    print(f"数据长度{n}大于5")  # 输出：数据长度11大于5

# 使用海象运算符
if (n := len(data)) > 5:
    print(f"数据长度{n}大于5")  # 输出：数据长度11大于5

# 在循环中使用
numbers = [1, 2, 3, 4, 5]
while (current := numbers.pop()) != 3:
    print(f"处理数字: {current}")
# 输出：
# 处理数字: 5
# 处理数字: 4

print("剩余数字:", numbers)  # 输出：剩余数字: [1, 2, 3]

# 在列表推导式中使用
data = ["apple", "banana", "cherry", "date"]
result = [last.upper() for word in data if (last := word[-1]) in 'aeiou']
print("以元音结尾的单词的最后一个字母:", result)  # 输出：以元音结尾的单词的最后一个字母: ['E', 'A']
```

### 7.5 使用上下文管理器管理资源
```python
# 传统资源管理方式
file = open('example.txt', 'w')
try:
    file.write("Hello, World!")
finally:
    file.close()

# 使用with语句（推荐）
with open('example.txt', 'w') as file:
    file.write("Hello, World!")

# 自定义上下文管理器
class Timer:
    def __init__(self, name):
        self.name = name
    
    def __enter__(self):
        import time
        self.start = time.time()
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        import time
        self.end = time.time()
        print(f"{self.name} 执行时间: {self.end - self.start:.2f}秒")

with Timer("测试代码"):
    # 模拟耗时操作
    import time
    time.sleep(0.1)
# 输出：测试代码 执行时间: 0.10秒
```

## 8. 调试和性能优化技巧

### 8.1 使用assert进行调试
```python
# assert语句用于调试，在条件为False时抛出AssertionError
def calculate_average(numbers):
    assert len(numbers) > 0, "数字列表不能为空"
    return sum(numbers) / len(numbers)

print("平均值:", calculate_average([1, 2, 3, 4, 5]))  # 输出：平均值: 3.0

try:
    calculate_average([])
except AssertionError as e:
    print(f"断言错误: {e}")  # 输出：断言错误: 数字列表不能为空

# 在生产环境中可以用-O参数禁用assert
# python -O script.py
```

### 8.2 使用__slots__优化内存
```python
# 普通类
class RegularPerson:
    def __init__(self, name, age):
        self.name = name
        self.age = age

# 使用__slots__的类
class SlotsPerson:
    __slots__ = ['name', 'age']
    
    def __init__(self, name, age):
        self.name = name
        self.age = age

import sys

regular = RegularPerson("张三", 25)
slots = SlotsPerson("李四", 25)

print("普通对象内存大小:", sys.getsizeof(regular))  # 输出：普通对象内存大小: 48
print("slots对象内存大小:", sys.getsizeof(slots))   # 输出：slots对象内存大小: 56

# 注意：__slots__会阻止创建__dict__，所以不能动态添加属性
try:
    slots.city = "北京"  # AttributeError: 'SlotsPerson' object has no attribute 'city'
except AttributeError as e:
    print(f"错误: {e}")  # 输出：错误: 'SlotsPerson' object has no attribute 'city'
```

### 8.3 使用生成器节省内存
```python
# 列表推导式（占用内存）
def get_squares_list(n):
    return [x**2 for x in range(n)]

# 生成器表达式（节省内存）
def get_squares_generator(n):
    return (x**2 for x in range(n))

import sys

squares_list = get_squares_list(1000)
squares_gen = get_squares_generator(1000)

print("列表内存大小:", sys.getsizeof(squares_list))  # 输出：列表内存大小: 8856
print("生成器内存大小:", sys.getsizeof(squares_gen))  # 输出：生成器内存大小: 112

# 使用生成器
for i, square in enumerate(get_squares_generator(5)):
    print(f"{i}^2 = {square}")
# 输出：
# 0^2 = 0
# 1^2 = 1
# 2^2 = 4
# 3^2 = 9
# 4^2 = 16
```

## 9. 总结

Python变量的核心要点总结：

### 9.1 重要概念
1. **动态类型**：变量类型在运行时确定，可以随时改变
2. **引用机制**：变量存储的是对象的引用，而不是对象本身
3. **作用域规则**：遵循LEGB规则（Local→Enclosing→Global→Built-in）
4. **可变性区分**：理解可变对象和不可变对象的区别
5. **内存管理**：Python自动处理内存分配和垃圾回收

### 9.2 最佳实践
1. **命名规范**：使用有意义的变量名，遵循命名约定
2. **作用域管理**：合理使用global和nonlocal关键字
3. **避免陷阱**：注意可变默认参数、循环变量绑定等问题
4. **性能优化**：适当使用生成器、__slots__等特性
5. **代码可读性**：使用类型提示、f-string等现代特性

### 9.3 调试技巧
1. 使用assert进行条件检查
2. 使用type()和isinstance()进行类型检查
3. 使用id()查看对象身份
4. 使用sys.getrefcount()查看引用计数
5. 使用内存分析工具优化性能